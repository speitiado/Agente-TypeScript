{"version":3,"file":"server.cjs","names":["items: (UIMessage | RemoveUIMessage)[]","evt: UIMessage<K, PropMap[K] | Partial<PropMap[K]>>","options","evt: RemoveUIMessage"],"sources":["../../../src/react-ui/server/server.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport type { ComponentPropsWithoutRef, ElementType } from \"react\";\nimport type { RemoveUIMessage, UIMessage } from \"../types.js\";\n\ninterface MessageLike {\n  id?: string;\n}\n\n/**\n * Helper to send and persist UI messages. Accepts a map of component names to React components\n * as type argument to provide type safety. Will also write to the `options?.stateKey` state.\n *\n * @param config LangGraphRunnableConfig\n * @param options\n * @returns\n */\nexport const typedUi = <Decl extends Record<string, ElementType>>(\n  config: {\n    writer?: (chunk: unknown) => void;\n    runId?: string;\n    metadata?: Record<string, unknown>;\n    tags?: string[];\n    runName?: string;\n    configurable?: {\n      __pregel_send?: (writes_: [string, unknown][]) => void;\n      [key: string]: unknown;\n    };\n  },\n  options?: {\n    /** The key to write the UI messages to. Defaults to `ui`. */\n    stateKey?: string;\n  }\n) => {\n  type PropMap = { [K in keyof Decl]: ComponentPropsWithoutRef<Decl[K]> };\n  const items: (UIMessage | RemoveUIMessage)[] = [];\n  const stateKey = options?.stateKey ?? \"ui\";\n\n  const runId = (config.metadata?.run_id as string | undefined) ?? config.runId;\n  if (!runId) throw new Error(\"run_id is required\");\n\n  function handlePush<K extends keyof PropMap & string>(\n    message: {\n      id?: string;\n      name: K;\n      props: PropMap[K];\n      metadata?: Record<string, unknown>;\n    },\n    options?: { message?: MessageLike; merge?: boolean }\n  ): UIMessage<K, PropMap[K]>;\n\n  function handlePush<K extends keyof PropMap & string>(\n    message: {\n      id?: string;\n      name: K;\n      props: Partial<PropMap[K]>;\n      metadata?: Record<string, unknown>;\n    },\n    options: { message?: MessageLike; merge: true }\n  ): UIMessage<K, Partial<PropMap[K]>>;\n\n  function handlePush<K extends keyof PropMap & string>(\n    message: {\n      id?: string;\n      name: K;\n      props: PropMap[K] | Partial<PropMap[K]>;\n      metadata?: Record<string, unknown>;\n    },\n    options?: { message?: MessageLike; merge?: boolean }\n  ): UIMessage<K, PropMap[K] | Partial<PropMap[K]>> {\n    const evt: UIMessage<K, PropMap[K] | Partial<PropMap[K]>> = {\n      type: \"ui\" as const,\n      id: message?.id ?? uuidv4(),\n      name: message?.name,\n      props: message?.props,\n      metadata: {\n        merge: options?.merge || undefined,\n        run_id: runId,\n        tags: config.tags,\n        name: config.runName,\n        ...message?.metadata,\n        ...(options?.message ? { message_id: options.message.id } : null),\n      },\n    };\n    items.push(evt);\n    config.writer?.(evt);\n    config.configurable?.__pregel_send?.([[stateKey, evt]]);\n    return evt;\n  }\n\n  const handleDelete = (id: string): RemoveUIMessage => {\n    const evt: RemoveUIMessage = { type: \"remove-ui\", id };\n    items.push(evt);\n    config.writer?.(evt);\n    config.configurable?.__pregel_send?.([[stateKey, evt]]);\n    return evt;\n  };\n\n  return { push: handlePush, delete: handleDelete, items };\n};\n"],"mappings":";;;;;;;;;;;;AAgBA,MAAa,WACX,QAWA,YAIG;CAEH,MAAMA,QAAyC;CAC/C,MAAM,WAAW,SAAS,YAAY;CAEtC,MAAM,QAAS,OAAO,UAAU,UAAiC,OAAO;AACxE,KAAI,CAAC,MAAO,OAAM,IAAI,MAAM;CAsB5B,SAAS,WACP,SAMA,WACgD;EAChD,MAAMC,MAAsD;GAC1D,MAAM;GACN,IAAI,SAAS;GACb,MAAM,SAAS;GACf,OAAO,SAAS;GAChB,UAAU;IACR,OAAOC,WAAS,SAAS;IACzB,QAAQ;IACR,MAAM,OAAO;IACb,MAAM,OAAO;IACb,GAAG,SAAS;IACZ,GAAIA,WAAS,UAAU,EAAE,YAAYA,UAAQ,QAAQ,OAAO;;;AAGhE,QAAM,KAAK;AACX,SAAO,SAAS;AAChB,SAAO,cAAc,gBAAgB,CAAC,CAAC,UAAU;AACjD,SAAO;;CAGT,MAAM,gBAAgB,OAAgC;EACpD,MAAMC,MAAuB;GAAE,MAAM;GAAa;;AAClD,QAAM,KAAK;AACX,SAAO,SAAS;AAChB,SAAO,cAAc,gBAAgB,CAAC,CAAC,UAAU;AACjD,SAAO;;AAGT,QAAO;EAAE,MAAM;EAAY,QAAQ;EAAc"}