{"version":3,"file":"branching.cjs","names":["childrenMap: Record<string, ThreadState<StateType>[]>","queue: string[]","queue","rootSequence: Sequence","queue: Task[]","paths: string[][]","fork: Fork | undefined","pathMap: Record<string, string[][]>","path","history: ThreadState<StateType>[]","branchByCheckpoint: Record<\n    string,\n    { branch: string | undefined; branchOptions: string[] | undefined }\n  >","queue: (Node<StateType> | Fork<StateType>)[]"],"sources":["../../src/ui/branching.ts"],"sourcesContent":["import type { ThreadState } from \"../schema.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninterface Node<StateType = any> {\n  type: \"node\";\n  value: ThreadState<StateType>;\n  path: string[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninterface Fork<StateType = any> {\n  type: \"fork\";\n  items: Array<Sequence<StateType>>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface Sequence<StateType = any> {\n  type: \"sequence\";\n  items: Array<Node<StateType> | Fork<StateType>>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninterface ValidFork<StateType = any> {\n  type: \"fork\";\n  items: Array<ValidSequence<StateType>>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninterface ValidSequence<StateType = any> {\n  type: \"sequence\";\n  items: [Node<StateType>, ...(Node<StateType> | ValidFork<StateType>)[]];\n}\n\nexport function getBranchSequence<StateType extends Record<string, unknown>>(\n  history: ThreadState<StateType>[]\n) {\n  const nodeIds = new Set<string>();\n  const childrenMap: Record<string, ThreadState<StateType>[]> = {};\n\n  // Short circuit if there's only a singular one state\n  if (history.length <= 1) {\n    return {\n      rootSequence: {\n        type: \"sequence\",\n        items: history.map((value) => ({ type: \"node\", value, path: [] })),\n      } satisfies Sequence<StateType>,\n      paths: [],\n    };\n  }\n\n  // First pass - collect nodes for each checkpoint\n  history.forEach((state) => {\n    const checkpointId = state.parent_checkpoint?.checkpoint_id ?? \"$\";\n    childrenMap[checkpointId] ??= [];\n    childrenMap[checkpointId].push(state);\n\n    if (state.checkpoint?.checkpoint_id != null) {\n      nodeIds.add(state.checkpoint.checkpoint_id);\n    }\n  });\n\n  // If dealing with partial history, take the branch\n  // with the latest checkpoint and mark it as the root.\n  const maxId = (...ids: (string | null)[]) =>\n    ids\n      .filter((i) => i != null)\n      .sort((a, b) => a.localeCompare(b))\n      .at(-1)!;\n\n  const lastOrphanedNode =\n    childrenMap.$ == null\n      ? Object.keys(childrenMap)\n          .filter((parentId) => !nodeIds.has(parentId))\n          .map((parentId) => {\n            const queue: string[] = [parentId];\n            const seen = new Set<string>();\n\n            let lastId = parentId;\n\n            while (queue.length > 0) {\n              const current = queue.shift()!;\n\n              if (seen.has(current)) continue;\n              seen.add(current);\n\n              const children = (childrenMap[current] ?? []).flatMap(\n                (i) => i.checkpoint?.checkpoint_id ?? []\n              );\n\n              lastId = maxId(lastId, ...children);\n              queue.push(...children);\n            }\n\n            return { parentId, lastId };\n          })\n          .sort((a, b) => a.lastId.localeCompare(b.lastId))\n          .at(-1)?.parentId\n      : undefined;\n\n  if (lastOrphanedNode != null) childrenMap.$ = childrenMap[lastOrphanedNode];\n\n  // Second pass - create a tree of sequences\n  type Task = { id: string; sequence: Sequence; path: string[] };\n  const rootSequence: Sequence = { type: \"sequence\", items: [] };\n  const queue: Task[] = [{ id: \"$\", sequence: rootSequence, path: [] }];\n\n  const paths: string[][] = [];\n\n  const visited = new Set<string>();\n  while (queue.length > 0) {\n    const task = queue.shift()!;\n    if (visited.has(task.id)) continue;\n    visited.add(task.id);\n\n    const children = childrenMap[task.id];\n    if (children == null || children.length === 0) continue;\n\n    // If we've encountered a fork (2+ children), push the fork\n    // to the sequence and add a new sequence for each child\n    let fork: Fork | undefined;\n    if (children.length > 1) {\n      fork = { type: \"fork\", items: [] };\n      task.sequence.items.push(fork);\n    }\n\n    for (const value of children) {\n      const id = value.checkpoint?.checkpoint_id;\n      if (id == null) continue;\n\n      let { sequence } = task;\n      let { path } = task;\n      if (fork != null) {\n        sequence = { type: \"sequence\", items: [] };\n        fork.items.unshift(sequence);\n\n        path = path.slice();\n        path.push(id);\n        paths.push(path);\n      }\n\n      sequence.items.push({ type: \"node\", value, path });\n      queue.push({ id, sequence, path });\n    }\n  }\n\n  return { rootSequence, paths };\n}\n\nconst PATH_SEP = \">\";\nconst ROOT_ID = \"$\";\n\n// Get flat view\nexport function getBranchView<StateType extends Record<string, unknown>>(\n  sequence: Sequence<StateType>,\n  paths: string[][],\n  branch: string\n) {\n  const path = branch.split(PATH_SEP);\n  const pathMap: Record<string, string[][]> = {};\n\n  for (const path of paths) {\n    const parent = path.at(-2) ?? ROOT_ID;\n    pathMap[parent] ??= [];\n    pathMap[parent].unshift(path);\n  }\n\n  const history: ThreadState<StateType>[] = [];\n  const branchByCheckpoint: Record<\n    string,\n    { branch: string | undefined; branchOptions: string[] | undefined }\n  > = {};\n\n  const forkStack = path.slice();\n  const queue: (Node<StateType> | Fork<StateType>)[] = [...sequence.items];\n\n  while (queue.length > 0) {\n    const item = queue.shift()!;\n\n    if (item.type === \"node\") {\n      history.push(item.value);\n      const checkpointId = item.value.checkpoint?.checkpoint_id;\n      if (checkpointId == null) continue;\n\n      branchByCheckpoint[checkpointId] = {\n        branch: item.path.join(PATH_SEP),\n        branchOptions: (item.path.length > 0\n          ? pathMap[item.path.at(-2) ?? ROOT_ID] ?? []\n          : []\n        ).map((p) => p.join(PATH_SEP)),\n      };\n    }\n    if (item.type === \"fork\") {\n      const forkId = forkStack.shift();\n      const index =\n        forkId != null\n          ? item.items.findIndex((value) => {\n              const firstItem = value.items.at(0);\n              if (!firstItem || firstItem.type !== \"node\") return false;\n              return firstItem.value.checkpoint?.checkpoint_id === forkId;\n            })\n          : -1;\n\n      const nextItems = item.items.at(index)?.items ?? [];\n      queue.push(...nextItems);\n    }\n  }\n\n  return { history, branchByCheckpoint };\n}\n\nexport function getBranchContext<StateType extends Record<string, unknown>>(\n  branch: string,\n  history: ThreadState<StateType>[] | undefined\n) {\n  const { rootSequence: branchTree, paths } = getBranchSequence(history ?? []);\n  const { history: flatHistory, branchByCheckpoint } = getBranchView(\n    branchTree,\n    paths,\n    branch\n  );\n\n  return {\n    branchTree,\n    flatHistory,\n    branchByCheckpoint,\n    threadHead: flatHistory.at(-1),\n  };\n}\n"],"mappings":"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"}