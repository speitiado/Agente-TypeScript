{"version":3,"file":"messages.cjs","names":["RemoveMessage"],"sources":["../../src/ui/messages.ts"],"sourcesContent":["import {\n  type BaseMessage,\n  type BaseMessageChunk,\n  RemoveMessage,\n  convertToChunk,\n  coerceMessageLikeToMessage,\n  isBaseMessageChunk,\n} from \"@langchain/core/messages\";\n\nimport type { Message } from \"../types.messages.js\";\n\nfunction tryConvertToChunk(message: BaseMessage): BaseMessageChunk | null {\n  try {\n    return convertToChunk(message);\n  } catch {\n    return null;\n  }\n}\n\nfunction tryCoerceMessageLikeToMessage(message: Message): BaseMessage {\n  // TODO: this is unnecessary with https://github.com/langchain-ai/langchainjs/pull/8941\n  if (message.type === \"remove\" && message.id != null) {\n    return new RemoveMessage({ ...message, id: message.id });\n  }\n\n  return coerceMessageLikeToMessage(message);\n}\n\nexport class MessageTupleManager {\n  chunks: Record<\n    string,\n    {\n      chunk?: BaseMessageChunk | BaseMessage;\n      metadata?: Record<string, unknown>;\n      index?: number;\n    }\n  > = {};\n\n  constructor() {\n    this.chunks = {};\n  }\n\n  add(\n    serialized: Message,\n    metadata: Record<string, unknown> | undefined\n  ): string | null {\n    // TODO: this is sometimes sent from the API\n    // figure out how to prevent this or move this to LC.js\n    if (serialized.type.endsWith(\"MessageChunk\")) {\n      // eslint-disable-next-line no-param-reassign\n      serialized.type = serialized.type\n        .slice(0, -\"MessageChunk\".length)\n        .toLowerCase() as Message[\"type\"];\n    }\n\n    const message = tryCoerceMessageLikeToMessage(serialized);\n    const chunk = tryConvertToChunk(message);\n\n    const { id } = chunk ?? message;\n    if (!id) {\n      console.warn(\n        \"No message ID found for chunk, ignoring in state\",\n        serialized\n      );\n      return null;\n    }\n\n    this.chunks[id] ??= {};\n    this.chunks[id].metadata = metadata ?? this.chunks[id].metadata;\n    if (chunk) {\n      const prev = this.chunks[id].chunk;\n      this.chunks[id].chunk =\n        (isBaseMessageChunk(prev) ? prev : null)?.concat(chunk) ?? chunk;\n    } else {\n      this.chunks[id].chunk = message;\n    }\n\n    return id;\n  }\n\n  clear() {\n    this.chunks = {};\n  }\n\n  get(id: string | null | undefined, defaultIndex?: number) {\n    if (id == null) return null;\n    if (this.chunks[id] == null) return null;\n    if (defaultIndex != null) this.chunks[id].index ??= defaultIndex;\n    return this.chunks[id];\n  }\n}\n\nexport const toMessageDict = (chunk: BaseMessage): Message => {\n  const { type, data } = chunk.toDict();\n  return { ...data, type } as Message;\n};\n"],"mappings":";;;;AAWA,SAAS,kBAAkB,SAA+C;AACxE,KAAI;AACF,uDAAsB;SAChB;AACN,SAAO;;;AAIX,SAAS,8BAA8B,SAA+B;AAEpE,KAAI,QAAQ,SAAS,YAAY,QAAQ,MAAM,KAC7C,QAAO,IAAIA,wCAAc;EAAE,GAAG;EAAS,IAAI,QAAQ;;AAGrD,kEAAkC;;AAGpC,IAAa,sBAAb,MAAiC;CAC/B,SAOI;CAEJ,cAAc;AACZ,OAAK,SAAS;;CAGhB,IACE,YACA,UACe;AAGf,MAAI,WAAW,KAAK,SAAS,gBAE3B,YAAW,OAAO,WAAW,KAC1B,MAAM,GAAG,KACT;EAGL,MAAM,UAAU,8BAA8B;EAC9C,MAAM,QAAQ,kBAAkB;EAEhC,MAAM,EAAE,OAAO,SAAS;AACxB,MAAI,CAAC,IAAI;AACP,WAAQ,KACN,oDACA;AAEF,UAAO;;AAGT,OAAK,OAAO,QAAQ;AACpB,OAAK,OAAO,IAAI,WAAW,YAAY,KAAK,OAAO,IAAI;AACvD,MAAI,OAAO;GACT,MAAM,OAAO,KAAK,OAAO,IAAI;AAC7B,QAAK,OAAO,IAAI,2DACM,QAAQ,OAAO,OAAO,OAAO,UAAU;QAE7D,MAAK,OAAO,IAAI,QAAQ;AAG1B,SAAO;;CAGT,QAAQ;AACN,OAAK,SAAS;;CAGhB,IAAI,IAA+B,cAAuB;AACxD,MAAI,MAAM,KAAM,QAAO;AACvB,MAAI,KAAK,OAAO,OAAO,KAAM,QAAO;AACpC,MAAI,gBAAgB,KAAM,MAAK,OAAO,IAAI,UAAU;AACpD,SAAO,KAAK,OAAO;;;AAIvB,MAAa,iBAAiB,UAAgC;CAC5D,MAAM,EAAE,MAAM,SAAS,MAAM;AAC7B,QAAO;EAAE,GAAG;EAAM"}