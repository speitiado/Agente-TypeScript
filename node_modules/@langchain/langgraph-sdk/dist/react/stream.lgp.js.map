{"version":3,"file":"stream.lgp.js","names":["client","key","threadId","limit","state","modes: Exclude<StreamMode, \"messages\">[]","error","idx","branch","callbackMeta: RunCallbackMeta | undefined","rejoinKey: `lg:stream:${string}` | undefined","values","callbackMeta: RunCallbackMeta"],"sources":["../../src/react/stream.lgp.tsx"],"sourcesContent":["/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\n\"use client\";\n\nimport {\n  type RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  useSyncExternalStore,\n} from \"react\";\nimport { findLast, unique } from \"../ui/utils.js\";\nimport { StreamError } from \"../ui/errors.js\";\nimport { getBranchContext } from \"../ui/branching.js\";\nimport { EventStreamEvent, StreamManager } from \"../ui/manager.js\";\nimport type {\n  BagTemplate,\n  UseStreamOptions,\n  UseStream,\n  GetUpdateType,\n  GetCustomEventType,\n  GetInterruptType,\n  GetConfigurableType,\n  RunCallbackMeta,\n  SubmitOptions,\n  MessageMetadata,\n  UseStreamThread,\n} from \"./types.js\";\nimport { Client, getClientConfigHash } from \"../client.js\";\nimport type { Message } from \"../types.messages.js\";\nimport type { Interrupt, ThreadState } from \"../schema.js\";\nimport type { StreamMode } from \"../types.stream.js\";\nimport { MessageTupleManager } from \"../ui/messages.js\";\nimport { useControllableThreadId } from \"./thread.js\";\n\nfunction getFetchHistoryKey(\n  client: Client,\n  threadId: string | undefined | null,\n  limit: boolean | number\n) {\n  return [getClientConfigHash(client), threadId, limit].join(\":\");\n}\n\nfunction fetchHistory<StateType extends Record<string, unknown>>(\n  client: Client,\n  threadId: string,\n  options?: { limit?: boolean | number }\n) {\n  if (options?.limit === false) {\n    return client.threads.getState<StateType>(threadId).then((state) => {\n      if (state.checkpoint == null) return [];\n      return [state];\n    });\n  }\n\n  const limit = typeof options?.limit === \"number\" ? options.limit : 10;\n  return client.threads.getHistory<StateType>(threadId, { limit });\n}\n\nfunction useThreadHistory<StateType extends Record<string, unknown>>(\n  client: Client,\n  threadId: string | undefined | null,\n  limit: boolean | number,\n  options: {\n    passthrough: boolean;\n    submittingRef: RefObject<string | null>;\n    onError?: (error: unknown, run?: RunCallbackMeta) => void;\n  }\n): UseStreamThread<StateType> {\n  const key = getFetchHistoryKey(client, threadId, limit);\n  const [state, setState] = useState<{\n    key: string | undefined;\n    data: ThreadState<StateType>[] | undefined;\n    error: unknown | undefined;\n    isLoading: boolean;\n  }>(() => ({\n    key: undefined,\n    data: undefined,\n    error: undefined,\n    isLoading: threadId != null,\n  }));\n\n  const clientRef = useRef(client);\n  clientRef.current = client;\n\n  const onErrorRef = useRef(options?.onError);\n  onErrorRef.current = options?.onError;\n\n  const fetcher = useCallback(\n    (\n      threadId: string | undefined | null,\n      limit: boolean | number\n    ): Promise<ThreadState<StateType>[]> => {\n      // If only passthrough is enabled, don't fetch history\n      if (options.passthrough) return Promise.resolve([]);\n\n      const client = clientRef.current;\n      const key = getFetchHistoryKey(client, threadId, limit);\n\n      if (threadId != null) {\n        setState((state) => {\n          if (state.key === key) return { ...state, isLoading: true };\n          return { key, data: undefined, error: undefined, isLoading: true };\n        });\n        return fetchHistory<StateType>(client, threadId, { limit }).then(\n          (data) => {\n            setState((state) => {\n              if (state.key !== key) return state;\n              return { key, data, error: undefined, isLoading: false };\n            });\n            return data;\n          },\n          (error) => {\n            setState((state) => {\n              if (state.key !== key) return state;\n              return { key, data: state.data, error, isLoading: false };\n            });\n            onErrorRef.current?.(error);\n            return Promise.reject(error);\n          }\n        );\n      }\n\n      setState({ key, data: undefined, error: undefined, isLoading: false });\n      return Promise.resolve([]);\n    },\n    [options.passthrough]\n  );\n\n  useEffect(() => {\n    // Skip if a stream is already in progress, no need to fetch history\n    if (\n      options.submittingRef.current != null &&\n      options.submittingRef.current === threadId\n    ) {\n      return;\n    }\n\n    void fetcher(threadId, limit);\n    // The `threadId` and `limit` arguments are already present in `key`\n    // Thus we don't need to include them in the dependency array\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fetcher, key]);\n\n  return {\n    data: state.data,\n    error: state.error,\n    isLoading: state.isLoading,\n    mutate: (mutateId?: string) => fetcher(mutateId ?? threadId, limit),\n  };\n}\n\nexport function useStreamLGP<\n  StateType extends Record<string, unknown> = Record<string, unknown>,\n  Bag extends {\n    ConfigurableType?: Record<string, unknown>;\n    InterruptType?: unknown;\n    CustomEventType?: unknown;\n    UpdateType?: unknown;\n  } = BagTemplate\n>(options: UseStreamOptions<StateType, Bag>): UseStream<StateType, Bag> {\n  type UpdateType = GetUpdateType<Bag, StateType>;\n  type CustomType = GetCustomEventType<Bag>;\n  type InterruptType = GetInterruptType<Bag>;\n  type ConfigurableType = GetConfigurableType<Bag>;\n\n  const reconnectOnMountRef = useRef(options.reconnectOnMount);\n  const runMetadataStorage = useMemo(() => {\n    if (typeof window === \"undefined\") return null;\n    const storage = reconnectOnMountRef.current;\n    if (storage === true) return window.sessionStorage;\n    if (typeof storage === \"function\") return storage();\n    return null;\n  }, []);\n\n  const client = useMemo(\n    () =>\n      options.client ??\n      new Client({\n        apiUrl: options.apiUrl,\n        apiKey: options.apiKey,\n        callerOptions: options.callerOptions,\n        defaultHeaders: options.defaultHeaders,\n      }),\n    [\n      options.client,\n      options.apiKey,\n      options.apiUrl,\n      options.callerOptions,\n      options.defaultHeaders,\n    ]\n  );\n\n  const [messageManager] = useState(() => new MessageTupleManager());\n  const [stream] = useState(\n    () => new StreamManager<StateType, Bag>(messageManager)\n  );\n\n  useSyncExternalStore(\n    stream.subscribe,\n    stream.getSnapshot,\n    stream.getSnapshot\n  );\n\n  const [threadId, onThreadId] = useControllableThreadId(options);\n  const trackStreamModeRef = useRef<Exclude<StreamMode, \"messages\">[]>([]);\n\n  const trackStreamMode = useCallback(\n    (...mode: Exclude<StreamMode, \"messages\">[]) => {\n      const ref = trackStreamModeRef.current;\n      for (const m of mode) {\n        if (!ref.includes(m)) ref.push(m);\n      }\n    },\n    []\n  );\n\n  const hasUpdateListener = options.onUpdateEvent != null;\n  const hasCustomListener = options.onCustomEvent != null;\n  const hasLangChainListener = options.onLangChainEvent != null;\n  const hasDebugListener = options.onDebugEvent != null;\n  const hasCheckpointListener = options.onCheckpointEvent != null;\n  const hasTaskListener = options.onTaskEvent != null;\n\n  const callbackStreamMode = useMemo(() => {\n    const modes: Exclude<StreamMode, \"messages\">[] = [];\n    if (hasUpdateListener) modes.push(\"updates\");\n    if (hasCustomListener) modes.push(\"custom\");\n    if (hasLangChainListener) modes.push(\"events\");\n    if (hasDebugListener) modes.push(\"debug\");\n    if (hasCheckpointListener) modes.push(\"checkpoints\");\n    if (hasTaskListener) modes.push(\"tasks\");\n    return modes;\n  }, [\n    hasUpdateListener,\n    hasCustomListener,\n    hasLangChainListener,\n    hasDebugListener,\n    hasCheckpointListener,\n    hasTaskListener,\n  ]);\n\n  const clearCallbackRef = useRef<() => void>(null!);\n  clearCallbackRef.current = stream.clear;\n\n  const threadIdRef = useRef<string | null>(threadId);\n  const threadIdStreamingRef = useRef<string | null>(null);\n\n  // Cancel the stream if thread ID has changed\n  useEffect(() => {\n    if (threadIdRef.current !== threadId) {\n      threadIdRef.current = threadId;\n      stream.clear();\n    }\n  }, [threadId, stream]);\n\n  const historyLimit =\n    typeof options.fetchStateHistory === \"object\" &&\n    options.fetchStateHistory != null\n      ? options.fetchStateHistory.limit ?? false\n      : options.fetchStateHistory ?? false;\n\n  const builtInHistory = useThreadHistory<StateType>(\n    client,\n    threadId,\n    historyLimit,\n    {\n      passthrough: options.experimental_thread != null,\n      submittingRef: threadIdStreamingRef,\n      onError: options.onError,\n    }\n  );\n  const history = options.experimental_thread ?? builtInHistory;\n\n  const getMessages = (value: StateType): Message[] => {\n    const messagesKey = options.messagesKey ?? \"messages\";\n    return Array.isArray(value[messagesKey]) ? value[messagesKey] : [];\n  };\n\n  const setMessages = (current: StateType, messages: Message[]): StateType => {\n    const messagesKey = options.messagesKey ?? \"messages\";\n    return { ...current, [messagesKey]: messages };\n  };\n\n  const [branch, setBranch] = useState<string>(\"\");\n  const branchContext = getBranchContext(branch, history.data ?? undefined);\n\n  const historyValues =\n    branchContext.threadHead?.values ??\n    options.initialValues ??\n    ({} as StateType);\n\n  const historyError = (() => {\n    const error = branchContext.threadHead?.tasks?.at(-1)?.error;\n    if (error == null) return undefined;\n    try {\n      const parsed = JSON.parse(error) as unknown;\n      if (StreamError.isStructuredError(parsed)) return new StreamError(parsed);\n      return parsed;\n    } catch {\n      // do nothing\n    }\n    return error;\n  })();\n\n  const messageMetadata = (() => {\n    const alreadyShown = new Set<string>();\n    return getMessages(historyValues).map(\n      (message, idx): Omit<MessageMetadata<StateType>, \"streamMetadata\"> => {\n        const messageId = message.id ?? idx;\n\n        // Find the first checkpoint where the message was seen\n        const firstSeenState = findLast(history.data ?? [], (state) =>\n          getMessages(state.values)\n            .map((m, idx) => m.id ?? idx)\n            .includes(messageId)\n        );\n\n        const checkpointId = firstSeenState?.checkpoint?.checkpoint_id;\n        let branch =\n          checkpointId != null\n            ? branchContext.branchByCheckpoint[checkpointId]\n            : undefined;\n        if (!branch?.branch?.length) branch = undefined;\n\n        // serialize branches\n        const optionsShown = branch?.branchOptions?.flat(2).join(\",\");\n        if (optionsShown) {\n          if (alreadyShown.has(optionsShown)) branch = undefined;\n          alreadyShown.add(optionsShown);\n        }\n\n        return {\n          messageId: messageId.toString(),\n          firstSeenState,\n\n          branch: branch?.branch,\n          branchOptions: branch?.branchOptions,\n        };\n      }\n    );\n  })();\n\n  const stop = () =>\n    stream.stop(historyValues, {\n      onStop: (args) => {\n        if (runMetadataStorage && threadId) {\n          const runId = runMetadataStorage.getItem(`lg:stream:${threadId}`);\n          if (runId) void client.runs.cancel(threadId, runId);\n          runMetadataStorage.removeItem(`lg:stream:${threadId}`);\n        }\n\n        options.onStop?.(args);\n      },\n    });\n\n  // --- TRANSPORT ---\n  const submit = async (\n    values: UpdateType | null | undefined,\n    submitOptions?: SubmitOptions<StateType, ConfigurableType>\n  ) => {\n    // Unbranch things\n    const checkpointId = submitOptions?.checkpoint?.checkpoint_id;\n    setBranch(\n      checkpointId != null\n        ? branchContext.branchByCheckpoint[checkpointId]?.branch ?? \"\"\n        : \"\"\n    );\n\n    // When `fetchStateHistory` is requested, thus we assume that branching\n    // is enabled. We then need to include the implicit branch.\n    const includeImplicitBranch =\n      historyLimit === true || typeof historyLimit === \"number\";\n\n    const shouldRefetch =\n      // We're expecting the whole thread state in onFinish\n      options.onFinish != null ||\n      // We're fetching history, thus we need the latest checkpoint\n      // to ensure we're not accidentally submitting to a wrong branch\n      includeImplicitBranch;\n\n    stream.setStreamValues(() => {\n      const prev = shouldRefetch\n        ? historyValues\n        : { ...historyValues, ...stream.values };\n\n      if (submitOptions?.optimisticValues != null) {\n        return {\n          ...prev,\n          ...(typeof submitOptions.optimisticValues === \"function\"\n            ? submitOptions.optimisticValues(prev)\n            : submitOptions.optimisticValues),\n        };\n      }\n\n      return { ...prev };\n    });\n\n    let callbackMeta: RunCallbackMeta | undefined;\n    let rejoinKey: `lg:stream:${string}` | undefined;\n    let usableThreadId = threadId;\n\n    await stream.start(\n      async (signal: AbortSignal) => {\n        if (!usableThreadId) {\n          const thread = await client.threads.create({\n            threadId: submitOptions?.threadId,\n            metadata: submitOptions?.metadata,\n          });\n\n          usableThreadId = thread.thread_id;\n\n          // Pre-emptively update the thread ID before\n          // stream cancellation is kicked off and thread\n          // is being refetched\n          threadIdRef.current = usableThreadId;\n          threadIdStreamingRef.current = usableThreadId;\n\n          onThreadId(usableThreadId);\n        }\n\n        if (!usableThreadId) {\n          throw new Error(\"Failed to obtain valid thread ID.\");\n        }\n\n        threadIdStreamingRef.current = usableThreadId;\n\n        const streamMode = unique([\n          ...(submitOptions?.streamMode ?? []),\n          ...trackStreamModeRef.current,\n          ...callbackStreamMode,\n        ]);\n\n        let checkpoint =\n          submitOptions?.checkpoint ??\n          (includeImplicitBranch\n            ? branchContext.threadHead?.checkpoint\n            : undefined) ??\n          undefined;\n\n        // Avoid specifying a checkpoint if user explicitly set it to null\n        if (submitOptions?.checkpoint === null) checkpoint = undefined;\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        if (checkpoint != null) delete checkpoint.thread_id;\n        const streamResumable =\n          submitOptions?.streamResumable ?? !!runMetadataStorage;\n\n        return client.runs.stream(usableThreadId, options.assistantId, {\n          input: values as Record<string, unknown>,\n          config: submitOptions?.config,\n          context: submitOptions?.context,\n          command: submitOptions?.command,\n\n          interruptBefore: submitOptions?.interruptBefore,\n          interruptAfter: submitOptions?.interruptAfter,\n          metadata: submitOptions?.metadata,\n          multitaskStrategy: submitOptions?.multitaskStrategy,\n          onCompletion: submitOptions?.onCompletion,\n          onDisconnect:\n            submitOptions?.onDisconnect ??\n            (streamResumable ? \"continue\" : \"cancel\"),\n\n          signal,\n\n          checkpoint,\n          streamMode,\n          streamSubgraphs: submitOptions?.streamSubgraphs,\n          streamResumable,\n          durability: submitOptions?.durability,\n          onRunCreated(params) {\n            callbackMeta = {\n              run_id: params.run_id,\n              thread_id: params.thread_id ?? usableThreadId!,\n            };\n\n            if (runMetadataStorage) {\n              rejoinKey = `lg:stream:${usableThreadId}`;\n              runMetadataStorage.setItem(rejoinKey, callbackMeta.run_id);\n            }\n\n            options.onCreated?.(callbackMeta);\n          },\n        }) as AsyncGenerator<\n          EventStreamEvent<StateType, UpdateType, CustomType>\n        >;\n      },\n      {\n        getMessages,\n        setMessages,\n\n        initialValues: historyValues,\n        callbacks: options,\n\n        async onSuccess() {\n          if (rejoinKey) runMetadataStorage?.removeItem(rejoinKey);\n\n          if (shouldRefetch) {\n            const newHistory = await history.mutate(usableThreadId!);\n            const lastHead = newHistory?.at(0);\n            if (lastHead) {\n              // We now have the latest update from /history\n              // Thus we can clear the local stream state\n              options.onFinish?.(lastHead, callbackMeta);\n              return null;\n            }\n          }\n\n          return undefined;\n        },\n        onError(error) {\n          options.onError?.(error, callbackMeta);\n        },\n        onFinish() {\n          threadIdStreamingRef.current = null;\n        },\n      }\n    );\n  };\n\n  const joinStream = async (\n    runId: string,\n    lastEventId?: string,\n    joinOptions?: { streamMode?: StreamMode | StreamMode[] }\n  ) => {\n    // eslint-disable-next-line no-param-reassign\n    lastEventId ??= \"-1\";\n    if (!threadId) return;\n\n    const callbackMeta: RunCallbackMeta = {\n      thread_id: threadId,\n      run_id: runId,\n    };\n\n    await stream.start(\n      async (signal: AbortSignal) => {\n        threadIdStreamingRef.current = threadId;\n        return client.runs.joinStream(threadId, runId, {\n          signal,\n          lastEventId,\n          streamMode: joinOptions?.streamMode,\n        }) as AsyncGenerator<\n          EventStreamEvent<StateType, UpdateType, CustomType>\n        >;\n      },\n      {\n        getMessages,\n        setMessages,\n\n        initialValues: historyValues,\n        callbacks: options,\n        async onSuccess() {\n          runMetadataStorage?.removeItem(`lg:stream:${threadId}`);\n          const newHistory = await history.mutate(threadId);\n          const lastHead = newHistory?.at(0);\n          if (lastHead) options.onFinish?.(lastHead, callbackMeta);\n        },\n        onError(error) {\n          options.onError?.(error, callbackMeta);\n        },\n        onFinish() {\n          threadIdStreamingRef.current = null;\n        },\n      }\n    );\n  };\n\n  const reconnectKey = useMemo(() => {\n    if (!runMetadataStorage || stream.isLoading) return undefined;\n    if (typeof window === \"undefined\") return undefined;\n    const runId = runMetadataStorage?.getItem(`lg:stream:${threadId}`);\n    if (!runId) return undefined;\n    return { runId, threadId };\n  }, [runMetadataStorage, stream.isLoading, threadId]);\n\n  const shouldReconnect = !!runMetadataStorage;\n  const reconnectRef = useRef({ threadId, shouldReconnect });\n\n  const joinStreamRef = useRef<typeof joinStream>(joinStream);\n  joinStreamRef.current = joinStream;\n\n  useEffect(() => {\n    // reset shouldReconnect when switching threads\n    if (reconnectRef.current.threadId !== threadId) {\n      reconnectRef.current = { threadId, shouldReconnect };\n    }\n  }, [threadId, shouldReconnect]);\n\n  useEffect(() => {\n    if (reconnectKey && reconnectRef.current.shouldReconnect) {\n      reconnectRef.current.shouldReconnect = false;\n      void joinStreamRef.current?.(reconnectKey.runId);\n    }\n  }, [reconnectKey]);\n\n  const error = stream.error ?? historyError ?? history.error;\n  const values = stream.values ?? historyValues;\n\n  return {\n    get values() {\n      trackStreamMode(\"values\");\n      return values;\n    },\n\n    client,\n    assistantId: options.assistantId,\n\n    error,\n    isLoading: stream.isLoading,\n\n    stop,\n    submit,\n\n    joinStream,\n\n    branch,\n    setBranch,\n\n    get history() {\n      if (historyLimit === false) {\n        throw new Error(\n          \"`fetchStateHistory` must be set to `true` to use `history`\"\n        );\n      }\n\n      return branchContext.flatHistory;\n    },\n\n    isThreadLoading: history.isLoading && history.data == null,\n\n    get experimental_branchTree() {\n      if (historyLimit === false) {\n        throw new Error(\n          \"`fetchStateHistory` must be set to `true` to use `experimental_branchTree`\"\n        );\n      }\n\n      return branchContext.branchTree;\n    },\n\n    get interrupt() {\n      if (\n        values != null &&\n        \"__interrupt__\" in values &&\n        Array.isArray(values.__interrupt__)\n      ) {\n        const valueInterrupts = values.__interrupt__;\n        if (valueInterrupts.length === 0) return { when: \"breakpoint\" };\n        if (valueInterrupts.length === 1) return valueInterrupts[0];\n\n        // TODO: fix the typing of interrupts if multiple interrupts are returned\n        return valueInterrupts;\n      }\n\n      // If we're deferring to old interrupt detection logic, don't show the interrupt if the stream is loading\n      if (stream.isLoading) return undefined;\n\n      const interrupts = branchContext.threadHead?.tasks?.at(-1)?.interrupts;\n      if (interrupts == null || interrupts.length === 0) {\n        // check if there's a next task present\n        const next = branchContext.threadHead?.next ?? [];\n        if (!next.length || error != null) return undefined;\n        return { when: \"breakpoint\" };\n      }\n\n      // Return only the current interrupt\n      return interrupts.at(-1) as Interrupt<InterruptType> | undefined;\n    },\n\n    get messages() {\n      trackStreamMode(\"messages-tuple\", \"values\");\n      return getMessages(values);\n    },\n\n    getMessagesMetadata(\n      message: Message,\n      index?: number\n    ): MessageMetadata<StateType> | undefined {\n      trackStreamMode(\"values\");\n\n      const streamMetadata = messageManager.get(message.id)?.metadata;\n      const historyMetadata = messageMetadata?.find(\n        (m) => m.messageId === (message.id ?? index)\n      );\n\n      if (streamMetadata != null || historyMetadata != null) {\n        return {\n          ...historyMetadata,\n          streamMetadata,\n        } as MessageMetadata<StateType>;\n      }\n\n      return undefined;\n    },\n  };\n}\n"],"mappings":"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"}