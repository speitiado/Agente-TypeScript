{"version":3,"file":"memory.cjs","names":["BaseCache"],"sources":["../../src/cache/memory.ts"],"sourcesContent":["import { BaseCache, type CacheFullKey, type CacheNamespace } from \"./base.js\";\n\nexport class InMemoryCache<V = unknown> extends BaseCache<V> {\n  private cache: {\n    [namespace: string]: {\n      [key: string]: {\n        enc: string;\n        val: Uint8Array | string;\n        exp: number | null;\n      };\n    };\n  } = {};\n\n  async get(keys: CacheFullKey[]): Promise<{ key: CacheFullKey; value: V }[]> {\n    if (!keys.length) return [];\n    const now = Date.now();\n    return (\n      await Promise.all(\n        keys.map(\n          async (fullKey): Promise<{ key: CacheFullKey; value: V }[]> => {\n            const [namespace, key] = fullKey;\n            const strNamespace = namespace.join(\",\");\n\n            if (strNamespace in this.cache && key in this.cache[strNamespace]) {\n              const cached = this.cache[strNamespace][key];\n              if (cached.exp == null || now < cached.exp) {\n                const value = await this.serde.loadsTyped(\n                  cached.enc,\n                  cached.val\n                );\n                return [{ key: fullKey, value }];\n              } else {\n                delete this.cache[strNamespace][key];\n              }\n            }\n\n            return [];\n          }\n        )\n      )\n    ).flat();\n  }\n\n  async set(\n    pairs: { key: CacheFullKey; value: V; ttl?: number }[]\n  ): Promise<void> {\n    const now = Date.now();\n    for (const { key: fullKey, value, ttl } of pairs) {\n      const [namespace, key] = fullKey;\n      const strNamespace = namespace.join(\",\");\n      const [enc, val] = await this.serde.dumpsTyped(value);\n      const exp = ttl != null ? ttl * 1000 + now : null;\n\n      this.cache[strNamespace] ??= {};\n      this.cache[strNamespace][key] = { enc, val, exp };\n    }\n  }\n\n  async clear(namespaces: CacheNamespace[]): Promise<void> {\n    if (!namespaces.length) {\n      this.cache = {};\n      return;\n    }\n\n    for (const namespace of namespaces) {\n      const strNamespace = namespace.join(\",\");\n      if (strNamespace in this.cache) delete this.cache[strNamespace];\n    }\n  }\n}\n"],"mappings":";;;AAEA,IAAa,gBAAb,cAAgDA,uBAAa;CAC3D,AAAQ,QAQJ;CAEJ,MAAM,IAAI,MAAkE;AAC1E,MAAI,CAAC,KAAK,OAAQ,QAAO;EACzB,MAAM,MAAM,KAAK;AACjB,UACE,MAAM,QAAQ,IACZ,KAAK,IACH,OAAO,YAAwD;GAC7D,MAAM,CAAC,WAAW,OAAO;GACzB,MAAM,eAAe,UAAU,KAAK;AAEpC,OAAI,gBAAgB,KAAK,SAAS,OAAO,KAAK,MAAM,eAAe;IACjE,MAAM,SAAS,KAAK,MAAM,cAAc;AACxC,QAAI,OAAO,OAAO,QAAQ,MAAM,OAAO,KAAK;KAC1C,MAAM,QAAQ,MAAM,KAAK,MAAM,WAC7B,OAAO,KACP,OAAO;AAET,YAAO,CAAC;MAAE,KAAK;MAAS;;UAExB,QAAO,KAAK,MAAM,cAAc;;AAIpC,UAAO;OAIb;;CAGJ,MAAM,IACJ,OACe;EACf,MAAM,MAAM,KAAK;AACjB,OAAK,MAAM,EAAE,KAAK,SAAS,OAAO,SAAS,OAAO;GAChD,MAAM,CAAC,WAAW,OAAO;GACzB,MAAM,eAAe,UAAU,KAAK;GACpC,MAAM,CAAC,KAAK,OAAO,MAAM,KAAK,MAAM,WAAW;GAC/C,MAAM,MAAM,OAAO,OAAO,MAAM,MAAO,MAAM;AAE7C,QAAK,MAAM,kBAAkB;AAC7B,QAAK,MAAM,cAAc,OAAO;IAAE;IAAK;IAAK;;;;CAIhD,MAAM,MAAM,YAA6C;AACvD,MAAI,CAAC,WAAW,QAAQ;AACtB,QAAK,QAAQ;AACb;;AAGF,OAAK,MAAM,aAAa,YAAY;GAClC,MAAM,eAAe,UAAU,KAAK;AACpC,OAAI,gBAAgB,KAAK,MAAO,QAAO,KAAK,MAAM"}