{"version":3,"file":"utils.js","names":["tokens: string[]","current: string[]","tokens","obj","results: string[]"],"sources":["../../src/store/utils.ts"],"sourcesContent":["/**\n * Tokenize a JSON path into parts.\n * @example\n * tokenizePath(\"metadata.title\") // -> [\"metadata\", \"title\"]\n * tokenizePath(\"chapters[*].content\") // -> [\"chapters[*]\", \"content\"]\n */\nexport function tokenizePath(path: string): string[] {\n  if (!path) {\n    return [];\n  }\n\n  const tokens: string[] = [];\n  let current: string[] = [];\n  let i = 0;\n\n  while (i < path.length) {\n    const char = path[i];\n\n    if (char === \"[\") {\n      // Handle array index\n      if (current.length) {\n        tokens.push(current.join(\"\"));\n        current = [];\n      }\n      let bracketCount = 1;\n      const indexChars = [\"[\"];\n      i += 1;\n      while (i < path.length && bracketCount > 0) {\n        if (path[i] === \"[\") {\n          bracketCount += 1;\n        } else if (path[i] === \"]\") {\n          bracketCount -= 1;\n        }\n        indexChars.push(path[i]);\n        i += 1;\n      }\n      tokens.push(indexChars.join(\"\"));\n      continue;\n    } else if (char === \"{\") {\n      // Handle multi-field selection\n      if (current.length) {\n        tokens.push(current.join(\"\"));\n        current = [];\n      }\n      let braceCount = 1;\n      const fieldChars = [\"{\"];\n      i += 1;\n      while (i < path.length && braceCount > 0) {\n        if (path[i] === \"{\") {\n          braceCount += 1;\n        } else if (path[i] === \"}\") {\n          braceCount -= 1;\n        }\n        fieldChars.push(path[i]);\n        i += 1;\n      }\n      tokens.push(fieldChars.join(\"\"));\n      continue;\n    } else if (char === \".\") {\n      // Handle regular field\n      if (current.length) {\n        tokens.push(current.join(\"\"));\n        current = [];\n      }\n    } else {\n      current.push(char);\n    }\n    i += 1;\n  }\n\n  if (current.length) {\n    tokens.push(current.join(\"\"));\n  }\n\n  return tokens;\n}\n\n/**\n * Represents the supported filter operators\n */\ntype FilterOperators = {\n  $eq?: unknown;\n  $ne?: unknown;\n  $gt?: unknown;\n  $gte?: unknown;\n  $lt?: unknown;\n  $lte?: unknown;\n  $in?: unknown[];\n  $nin?: unknown[];\n};\n\n/**\n * Type guard to check if an object is a FilterOperators\n */\nfunction isFilterOperators(obj: unknown): obj is FilterOperators {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    Object.keys(obj).every(\n      (key) =>\n        key === \"$eq\" ||\n        key === \"$ne\" ||\n        key === \"$gt\" ||\n        key === \"$gte\" ||\n        key === \"$lt\" ||\n        key === \"$lte\" ||\n        key === \"$in\" ||\n        key === \"$nin\"\n    )\n  );\n}\n\n/**\n * Compare values for filtering, supporting operator-based comparisons.\n */\nexport function compareValues(\n  itemValue: unknown,\n  filterValue: unknown\n): boolean {\n  if (isFilterOperators(filterValue)) {\n    const operators = Object.keys(filterValue).filter((k) => k.startsWith(\"$\"));\n    return operators.every((op) => {\n      const value = filterValue[op as keyof FilterOperators];\n      switch (op) {\n        case \"$eq\":\n          return itemValue === value;\n        case \"$ne\":\n          return itemValue !== value;\n        case \"$gt\":\n          return Number(itemValue) > Number(value);\n        case \"$gte\":\n          return Number(itemValue) >= Number(value);\n        case \"$lt\":\n          return Number(itemValue) < Number(value);\n        case \"$lte\":\n          return Number(itemValue) <= Number(value);\n        case \"$in\":\n          return Array.isArray(value) ? value.includes(itemValue) : false;\n        case \"$nin\":\n          return Array.isArray(value) ? !value.includes(itemValue) : true;\n        default:\n          return false;\n      }\n    });\n  }\n\n  // If no operators, do a direct comparison\n  return itemValue === filterValue;\n}\n\n/**\n * Extract text from a value at a specific JSON path.\n *\n * Supports:\n * - Simple paths: \"field1.field2\"\n * - Array indexing: \"[0]\", \"[*]\", \"[-1]\"\n * - Wildcards: \"*\"\n * - Multi-field selection: \"{field1,field2}\"\n * - Nested paths in multi-field: \"{field1,nested.field2}\"\n */\nexport function getTextAtPath(obj: unknown, path: string[] | string): string[] {\n  if (!path || path === \"$\") {\n    return [JSON.stringify(obj, null, 2)];\n  }\n  const tokens = Array.isArray(path) ? path : tokenizePath(path);\n\n  function extractFromObj(\n    obj: unknown,\n    tokens: string[],\n    pos: number\n  ): string[] {\n    if (pos >= tokens.length) {\n      if (\n        typeof obj === \"string\" ||\n        typeof obj === \"number\" ||\n        typeof obj === \"boolean\"\n      ) {\n        return [String(obj)];\n      }\n      if (obj === null || obj === undefined) {\n        return [];\n      }\n      if (Array.isArray(obj) || typeof obj === \"object\") {\n        return [JSON.stringify(obj, null, 2)];\n      }\n      return [];\n    }\n\n    const token = tokens[pos];\n    const results: string[] = [];\n    if (pos === 0 && token === \"$\") {\n      results.push(JSON.stringify(obj, null, 2));\n    }\n\n    if (token.startsWith(\"[\") && token.endsWith(\"]\")) {\n      if (!Array.isArray(obj)) return [];\n\n      const index = token.slice(1, -1);\n      if (index === \"*\") {\n        for (const item of obj) {\n          results.push(...extractFromObj(item, tokens, pos + 1));\n        }\n      } else {\n        try {\n          let idx = parseInt(index, 10);\n          if (idx < 0) {\n            idx = obj.length + idx;\n          }\n          if (idx >= 0 && idx < obj.length) {\n            results.push(...extractFromObj(obj[idx], tokens, pos + 1));\n          }\n        } catch {\n          return [];\n        }\n      }\n    } else if (token.startsWith(\"{\") && token.endsWith(\"}\")) {\n      if (typeof obj !== \"object\" || obj === null) return [];\n\n      const fields = token\n        .slice(1, -1)\n        .split(\",\")\n        .map((f) => f.trim());\n      for (const field of fields) {\n        const nestedTokens = tokenizePath(field);\n        if (nestedTokens.length) {\n          let currentObj = obj as Record<string, unknown> | undefined;\n          for (const nestedToken of nestedTokens) {\n            if (\n              currentObj &&\n              typeof currentObj === \"object\" &&\n              nestedToken in currentObj\n            ) {\n              currentObj = currentObj[nestedToken] as Record<string, unknown>;\n            } else {\n              currentObj = undefined;\n              break;\n            }\n          }\n          if (currentObj !== undefined) {\n            if (\n              typeof currentObj === \"string\" ||\n              typeof currentObj === \"number\" ||\n              typeof currentObj === \"boolean\"\n            ) {\n              results.push(String(currentObj));\n            } else if (\n              Array.isArray(currentObj) ||\n              typeof currentObj === \"object\"\n            ) {\n              results.push(JSON.stringify(currentObj, null, 2));\n            }\n          }\n        }\n      }\n    } else if (token === \"*\") {\n      if (Array.isArray(obj)) {\n        for (const item of obj) {\n          results.push(...extractFromObj(item, tokens, pos + 1));\n        }\n      } else if (typeof obj === \"object\" && obj !== null) {\n        for (const value of Object.values(obj)) {\n          results.push(...extractFromObj(value, tokens, pos + 1));\n        }\n      }\n    } else {\n      if (typeof obj === \"object\" && obj !== null && token in obj) {\n        results.push(\n          ...extractFromObj(\n            (obj as Record<string, unknown>)[token],\n            tokens,\n            pos + 1\n          )\n        );\n      }\n    }\n\n    return results;\n  }\n\n  return extractFromObj(obj, tokens, 0);\n}\n\n/**\n * Calculate cosine similarity between two vectors.\n */\nexport function cosineSimilarity(vector1: number[], vector2: number[]): number {\n  if (vector1.length !== vector2.length) {\n    throw new Error(\"Vectors must have the same length\");\n  }\n\n  const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);\n  const magnitude1 = Math.sqrt(\n    vector1.reduce((acc, val) => acc + val * val, 0)\n  );\n  const magnitude2 = Math.sqrt(\n    vector2.reduce((acc, val) => acc + val * val, 0)\n  );\n\n  if (magnitude1 === 0 || magnitude2 === 0) return 0;\n  return dotProduct / (magnitude1 * magnitude2);\n}\n"],"mappings":"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"}