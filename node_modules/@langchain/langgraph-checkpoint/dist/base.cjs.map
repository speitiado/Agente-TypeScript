{"version":3,"file":"base.cjs","names":["uuid6","JsonPlusSerializer","WRITES_IDX_MAP: Record<string, number>","ERROR","SCHEDULED","INTERRUPT","RESUME"],"sources":["../src/base.ts"],"sourcesContent":["import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport { SerializerProtocol } from \"./serde/base.js\";\nimport { uuid6 } from \"./id.js\";\nimport type {\n  PendingWrite,\n  CheckpointPendingWrite,\n  CheckpointMetadata,\n} from \"./types.js\";\nimport { ERROR, INTERRUPT, RESUME, SCHEDULED } from \"./serde/types.js\";\nimport { JsonPlusSerializer } from \"./serde/jsonplus.js\";\n\n/** @inline */\ntype ChannelVersion = number | string;\n\nexport type ChannelVersions = Record<string, ChannelVersion>;\n\nexport interface Checkpoint<\n  N extends string = string,\n  C extends string = string\n> {\n  /**\n   * The version of the checkpoint format. Currently 4\n   */\n  v: number;\n  /**\n   * Checkpoint ID {uuid6}\n   */\n  id: string;\n  /**\n   * Timestamp {new Date().toISOString()}\n   */\n  ts: string;\n  /**\n   * @default {}\n   */\n  channel_values: Record<C, unknown>;\n  /**\n   * @default {}\n   */\n  channel_versions: Record<C, ChannelVersion>;\n  /**\n   * @default {}\n   */\n  versions_seen: Record<N, Record<C, ChannelVersion>>;\n}\n\nexport interface ReadonlyCheckpoint extends Readonly<Checkpoint> {\n  readonly channel_values: Readonly<Record<string, unknown>>;\n  readonly channel_versions: Readonly<Record<string, ChannelVersion>>;\n  readonly versions_seen: Readonly<\n    Record<string, Readonly<Record<string, ChannelVersion>>>\n  >;\n}\n\nexport function deepCopy<T>(obj: T): T {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      (newObj as Record<PropertyKey, unknown>)[key] = deepCopy(\n        (obj as Record<string, unknown>)[key]\n      );\n    }\n  }\n\n  return newObj as T;\n}\n\n/** @hidden */\nexport function emptyCheckpoint(): Checkpoint {\n  return {\n    v: 4,\n    id: uuid6(-2),\n    ts: new Date().toISOString(),\n    channel_values: {},\n    channel_versions: {},\n    versions_seen: {},\n  };\n}\n\n/** @hidden */\nexport function copyCheckpoint(checkpoint: ReadonlyCheckpoint): Checkpoint {\n  return {\n    v: checkpoint.v,\n    id: checkpoint.id,\n    ts: checkpoint.ts,\n    channel_values: { ...checkpoint.channel_values },\n    channel_versions: { ...checkpoint.channel_versions },\n    versions_seen: deepCopy(checkpoint.versions_seen),\n  };\n}\n\nexport interface CheckpointTuple {\n  config: RunnableConfig;\n  checkpoint: Checkpoint;\n  metadata?: CheckpointMetadata;\n  parentConfig?: RunnableConfig;\n  pendingWrites?: CheckpointPendingWrite[];\n}\n\nexport type CheckpointListOptions = {\n  limit?: number;\n  before?: RunnableConfig;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  filter?: Record<string, any>;\n};\n\nexport abstract class BaseCheckpointSaver<V extends string | number = number> {\n  serde: SerializerProtocol = new JsonPlusSerializer();\n\n  constructor(serde?: SerializerProtocol) {\n    this.serde = serde || this.serde;\n  }\n\n  async get(config: RunnableConfig): Promise<Checkpoint | undefined> {\n    const value = await this.getTuple(config);\n    return value ? value.checkpoint : undefined;\n  }\n\n  abstract getTuple(\n    config: RunnableConfig\n  ): Promise<CheckpointTuple | undefined>;\n\n  abstract list(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncGenerator<CheckpointTuple>;\n\n  abstract put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata,\n    newVersions: ChannelVersions\n  ): Promise<RunnableConfig>;\n\n  /**\n   * Store intermediate writes linked to a checkpoint.\n   */\n  abstract putWrites(\n    config: RunnableConfig,\n    writes: PendingWrite[],\n    taskId: string\n  ): Promise<void>;\n\n  /**\n   * Delete all checkpoints and writes associated with a specific thread ID.\n   * @param threadId The thread ID whose checkpoints should be deleted.\n   */\n  abstract deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Generate the next version ID for a channel.\n   *\n   * Default is to use integer versions, incrementing by 1. If you override, you can use str/int/float versions,\n   * as long as they are monotonically increasing.\n   */\n  getNextVersion(current: V | undefined): V {\n    if (typeof current === \"string\") {\n      throw new Error(\"Please override this method to use string versions.\");\n    }\n    return (\n      current !== undefined && typeof current === \"number\" ? current + 1 : 1\n    ) as V;\n  }\n}\n\nexport function compareChannelVersions(\n  a: ChannelVersion,\n  b: ChannelVersion\n): number {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return Math.sign(a - b);\n  }\n\n  return String(a).localeCompare(String(b));\n}\n\nexport function maxChannelVersion(\n  ...versions: ChannelVersion[]\n): ChannelVersion {\n  return versions.reduce((max, version, idx) => {\n    if (idx === 0) return version;\n    return compareChannelVersions(max, version) >= 0 ? max : version;\n  });\n}\n\n/**\n * Mapping from error type to error index.\n * Regular writes just map to their index in the list of writes being saved.\n * Special writes (e.g. errors) map to negative indices, to avoid those writes from\n * conflicting with regular writes.\n * Each Checkpointer implementation should use this mapping in put_writes.\n */\nexport const WRITES_IDX_MAP: Record<string, number> = {\n  [ERROR]: -1,\n  [SCHEDULED]: -2,\n  [INTERRUPT]: -3,\n  [RESUME]: -4,\n};\n\nexport function getCheckpointId(config: RunnableConfig): string {\n  return (\n    config.configurable?.checkpoint_id || config.configurable?.thread_ts || \"\"\n  );\n}\n"],"mappings":";;;;;AAsDA,SAAgB,SAAY,KAAW;AACrC,KAAI,OAAO,QAAQ,YAAY,QAAQ,KACrC,QAAO;CAGT,MAAM,SAAS,MAAM,QAAQ,OAAO,KAAK;AAEzC,MAAK,MAAM,OAAO,IAChB,KAAI,OAAO,UAAU,eAAe,KAAK,KAAK,KAC5C,CAAC,OAAwC,OAAO,SAC7C,IAAgC;AAKvC,QAAO;;;AAIT,SAAgB,kBAA8B;AAC5C,QAAO;EACL,GAAG;EACH,IAAIA,iBAAM;EACV,qBAAI,IAAI,QAAO;EACf,gBAAgB;EAChB,kBAAkB;EAClB,eAAe;;;;AAKnB,SAAgB,eAAe,YAA4C;AACzE,QAAO;EACL,GAAG,WAAW;EACd,IAAI,WAAW;EACf,IAAI,WAAW;EACf,gBAAgB,EAAE,GAAG,WAAW;EAChC,kBAAkB,EAAE,GAAG,WAAW;EAClC,eAAe,SAAS,WAAW;;;AAmBvC,IAAsB,sBAAtB,MAA8E;CAC5E,QAA4B,IAAIC;CAEhC,YAAY,OAA4B;AACtC,OAAK,QAAQ,SAAS,KAAK;;CAG7B,MAAM,IAAI,QAAyD;EACjE,MAAM,QAAQ,MAAM,KAAK,SAAS;AAClC,SAAO,QAAQ,MAAM,aAAa;;;;;;;;CAwCpC,eAAe,SAA2B;AACxC,MAAI,OAAO,YAAY,SACrB,OAAM,IAAI,MAAM;AAElB,SACE,YAAY,UAAa,OAAO,YAAY,WAAW,UAAU,IAAI;;;AAK3E,SAAgB,uBACd,GACA,GACQ;AACR,KAAI,OAAO,MAAM,YAAY,OAAO,MAAM,SACxC,QAAO,KAAK,KAAK,IAAI;AAGvB,QAAO,OAAO,GAAG,cAAc,OAAO;;AAGxC,SAAgB,kBACd,GAAG,UACa;AAChB,QAAO,SAAS,QAAQ,KAAK,SAAS,QAAQ;AAC5C,MAAI,QAAQ,EAAG,QAAO;AACtB,SAAO,uBAAuB,KAAK,YAAY,IAAI,MAAM;;;;;;;;;;AAW7D,MAAaC,iBAAyC;EACnDC,sBAAQ;EACRC,0BAAY;EACZC,0BAAY;EACZC,uBAAS;;AAGZ,SAAgB,gBAAgB,QAAgC;AAC9D,QACE,OAAO,cAAc,iBAAiB,OAAO,cAAc,aAAa"}