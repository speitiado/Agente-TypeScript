{"version":3,"file":"index.cjs","names":[],"sources":["../../../../src/serde/utils/fast-safe-stringify/index.ts"],"sourcesContent":["/* eslint-disable */\n// @ts-nocheck\n\n// Stringify that can handle circular references.\n// Inlined due to ESM import issues\n// Source: https://www.npmjs.com/package/fast-safe-stringify\n\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\n\nvar arr = [];\nvar replacerStack = [];\n\nfunction defaultOptions() {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER,\n  };\n}\n\n// Regular stringify\nexport function stringify(obj, replacer?, spacer?, options?) {\n  if (typeof options === \"undefined\") {\n    options = defaultOptions();\n  }\n\n  decirc(obj, \"\", 0, [], undefined, 0, options);\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer);\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify(\n      \"[unable to serialize, circular reference is too complex to analyze]\"\n    );\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\n\nfunction setReplace(replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace });\n      arr.push([parent, k, val, propertyDescriptor]);\n    } else {\n      replacerStack.push([val, k, replace]);\n    }\n  } else {\n    parent[k] = replace;\n    arr.push([parent, k, val]);\n  }\n}\n\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (typeof val === \"object\" && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== \"undefined\" &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    if (\n      typeof options.edgesLimit !== \"undefined\" &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      var keys = Object.keys(val);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        decirc(val[key], key, i, stack, val, depth, options);\n      }\n    }\n    stack.pop();\n  }\n}\n\n// Stable-stringify\nfunction compareFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction deterministicStringify(obj, replacer, spacer, options) {\n  if (typeof options === \"undefined\") {\n    options = defaultOptions();\n  }\n\n  var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer);\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify(\n      \"[unable to serialize, circular reference is too complex to analyze]\"\n    );\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\n\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (typeof val === \"object\" && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    try {\n      if (typeof val.toJSON === \"function\") {\n        return;\n      }\n    } catch (_) {\n      return;\n    }\n\n    if (\n      typeof options.depthLimit !== \"undefined\" &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    if (\n      typeof options.edgesLimit !== \"undefined\" &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {};\n      var keys = Object.keys(val).sort(compareFunction);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        deterministicDecirc(val[key], key, i, stack, val, depth, options);\n        tmp[key] = val[key];\n      }\n      if (typeof parent !== \"undefined\") {\n        arr.push([parent, k, val]);\n        parent[k] = tmp;\n      } else {\n        return tmp;\n      }\n    }\n    stack.pop();\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n  replacer =\n    typeof replacer !== \"undefined\"\n      ? replacer\n      : function (k, v) {\n          return v;\n        };\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i];\n        if (part[1] === key && part[0] === val) {\n          val = part[2];\n          replacerStack.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return replacer.call(this, key, val);\n  };\n}\n"],"mappings":";;AAOA,IAAI,qBAAqB;AACzB,IAAI,wBAAwB;AAE5B,IAAI,MAAM;AACV,IAAI,gBAAgB;AAEpB,SAAS,iBAAiB;AACxB,QAAO;EACL,YAAY,OAAO;EACnB,YAAY,OAAO;;;AAKvB,SAAgB,UAAU,KAAK,UAAW,QAAS,SAAU;AAC3D,KAAI,OAAO,YAAY,YACrB,WAAU;AAGZ,QAAO,KAAK,IAAI,GAAG,IAAI,QAAW,GAAG;CACrC,IAAI;AACJ,KAAI;AACF,MAAI,cAAc,WAAW,EAC3B,OAAM,KAAK,UAAU,KAAK,UAAU;MAEpC,OAAM,KAAK,UAAU,KAAK,oBAAoB,WAAW;UAEpD,GAAG;AACV,SAAO,KAAK,UACV;WAEM;AACR,SAAO,IAAI,WAAW,GAAG;GACvB,IAAI,OAAO,IAAI;AACf,OAAI,KAAK,WAAW,EAClB,QAAO,eAAe,KAAK,IAAI,KAAK,IAAI,KAAK;OAE7C,MAAK,GAAG,KAAK,MAAM,KAAK;;;AAI9B,QAAO;;AAGT,SAAS,WAAW,SAAS,KAAK,GAAG,QAAQ;CAC3C,IAAI,qBAAqB,OAAO,yBAAyB,QAAQ;AACjE,KAAI,mBAAmB,QAAQ,OAC7B,KAAI,mBAAmB,cAAc;AACnC,SAAO,eAAe,QAAQ,GAAG,EAAE,OAAO;AAC1C,MAAI,KAAK;GAAC;GAAQ;GAAG;GAAK;;OAE1B,eAAc,KAAK;EAAC;EAAK;EAAG;;MAEzB;AACL,SAAO,KAAK;AACZ,MAAI,KAAK;GAAC;GAAQ;GAAG;;;;AAIzB,SAAS,OAAO,KAAK,GAAG,WAAW,OAAO,QAAQ,OAAO,SAAS;AAChE,UAAS;CACT,IAAI;AACJ,KAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AAC3C,OAAK,IAAI,GAAG,IAAI,MAAM,QAAQ,IAC5B,KAAI,MAAM,OAAO,KAAK;AACpB,cAAW,uBAAuB,KAAK,GAAG;AAC1C;;AAIJ,MACE,OAAO,QAAQ,eAAe,eAC9B,QAAQ,QAAQ,YAChB;AACA,cAAW,oBAAoB,KAAK,GAAG;AACvC;;AAGF,MACE,OAAO,QAAQ,eAAe,eAC9B,YAAY,IAAI,QAAQ,YACxB;AACA,cAAW,oBAAoB,KAAK,GAAG;AACvC;;AAGF,QAAM,KAAK;AAEX,MAAI,MAAM,QAAQ,KAChB,MAAK,IAAI,GAAG,IAAI,IAAI,QAAQ,IAC1B,QAAO,IAAI,IAAI,GAAG,GAAG,OAAO,KAAK,OAAO;OAErC;GACL,IAAI,OAAO,OAAO,KAAK;AACvB,QAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;IAChC,IAAI,MAAM,KAAK;AACf,WAAO,IAAI,MAAM,KAAK,GAAG,OAAO,KAAK,OAAO;;;AAGhD,QAAM;;;AA4GV,SAAS,oBAAoB,UAAU;AACrC,YACE,OAAO,aAAa,cAChB,WACA,SAAU,GAAG,GAAG;AACd,SAAO;;AAEf,QAAO,SAAU,KAAK,KAAK;AACzB,MAAI,cAAc,SAAS,EACzB,MAAK,IAAI,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;GAC7C,IAAI,OAAO,cAAc;AACzB,OAAI,KAAK,OAAO,OAAO,KAAK,OAAO,KAAK;AACtC,UAAM,KAAK;AACX,kBAAc,OAAO,GAAG;AACxB;;;AAIN,SAAO,SAAS,KAAK,MAAM,KAAK"}