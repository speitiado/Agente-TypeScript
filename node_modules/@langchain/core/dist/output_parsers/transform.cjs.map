{"version":3,"file":"transform.cjs","names":["BaseOutputParser","inputGenerator: AsyncGenerator<string | BaseMessage>","options: BaseCallbackConfig","fields?: BaseCumulativeTransformOutputParserInput","prevParsed: T | undefined","accGen: GenerationChunk | undefined","chunkGen: GenerationChunk","isBaseMessageChunk","ChatGenerationChunk","isBaseMessage","convertToChunk","GenerationChunk"],"sources":["../../src/output_parsers/transform.ts"],"sourcesContent":["import { deepCompareStrict } from \"@cfworker/json-schema\";\nimport { BaseOutputParser } from \"./base.js\";\nimport {\n  type BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n} from \"../messages/base.js\";\nimport { convertToChunk } from \"../messages/utils.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  type Generation,\n  type ChatGeneration,\n  GenerationChunk,\n  ChatGenerationChunk,\n} from \"../outputs.js\";\n\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport abstract class BaseTransformOutputParser<\n  T = unknown\n> extends BaseOutputParser<T> {\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{ text: chunk }]);\n      } else {\n        yield this.parseResult([\n          {\n            message: chunk,\n            text: this._baseMessageToString(chunk),\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>,\n    options: BaseCallbackConfig\n  ): AsyncGenerator<T> {\n    yield* this._transformStreamWithConfig(\n      inputGenerator,\n      this._transform.bind(this),\n      {\n        ...options,\n        runType: \"parser\",\n      }\n    );\n  }\n}\n\nexport type BaseCumulativeTransformOutputParserInput = { diff?: boolean };\n\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport abstract class BaseCumulativeTransformOutputParser<\n  T = unknown\n> extends BaseTransformOutputParser<T> {\n  protected diff = false;\n\n  constructor(fields?: BaseCumulativeTransformOutputParserInput) {\n    super(fields);\n    this.diff = fields?.diff ?? this.diff;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected abstract _diff(prev: any | undefined, next: any): any;\n\n  abstract parsePartialResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<T | undefined>;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    let prevParsed: T | undefined;\n    let accGen: GenerationChunk | undefined;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen: GenerationChunk;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content,\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: convertToChunk(chunk),\n          text: chunk.content,\n        });\n      } else {\n        chunkGen = new GenerationChunk({ text: chunk });\n      }\n\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n\n      const parsed = await this.parsePartialResult([accGen]);\n      if (\n        parsed !== undefined &&\n        parsed !== null &&\n        !deepCompareStrict(parsed, prevParsed)\n      ) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n"],"mappings":";;;;;;;;;;;AAmBA,IAAsB,4BAAtB,cAEUA,gCAAoB;CAC5B,OAAO,WACLC,gBACmB;AACnB,aAAW,MAAM,SAAS,eACxB,KAAI,OAAO,UAAU,UACnB,MAAM,KAAK,YAAY,CAAC,EAAE,MAAM,MAAO,CAAC,EAAC;OAEzC,MAAM,KAAK,YAAY,CACrB;GACE,SAAS;GACT,MAAM,KAAK,qBAAqB,MAAM;EACvC,CACF,EAAC;CAGP;;;;;;;;CASD,OAAO,UACLA,gBACAC,SACmB;EACnB,OAAO,KAAK,2BACV,gBACA,KAAK,WAAW,KAAK,KAAK,EAC1B;GACE,GAAG;GACH,SAAS;EACV,EACF;CACF;AACF;;;;;;AASD,IAAsB,sCAAtB,cAEU,0BAA6B;CACrC,AAAU,OAAO;CAEjB,YAAYC,QAAmD;EAC7D,MAAM,OAAO;EACb,KAAK,OAAO,QAAQ,QAAQ,KAAK;CAClC;CASD,OAAO,WACLF,gBACmB;EACnB,IAAIG;EACJ,IAAIC;AACJ,aAAW,MAAM,SAAS,gBAAgB;AACxC,OAAI,OAAO,UAAU,YAAY,OAAO,MAAM,YAAY,SACxD,OAAM,IAAI,MAAM;GAElB,IAAIC;AACJ,OAAIC,gCAAmB,MAAM,EAAE;AAC7B,QAAI,OAAO,MAAM,YAAY,SAC3B,OAAM,IAAI,MAAM;IAElB,WAAW,IAAIC,oCAAoB;KACjC,SAAS;KACT,MAAM,MAAM;IACb;GACF,WAAUC,2BAAc,MAAM,EAAE;AAC/B,QAAI,OAAO,MAAM,YAAY,SAC3B,OAAM,IAAI,MAAM;IAElB,WAAW,IAAID,oCAAoB;KACjC,SAASE,6BAAe,MAAM;KAC9B,MAAM,MAAM;IACb;GACF,OACC,WAAW,IAAIC,gCAAgB,EAAE,MAAM,MAAO;AAGhD,OAAI,WAAW,QACb,SAAS;QAET,SAAS,OAAO,OAAO,SAAS;GAGlC,MAAM,SAAS,MAAM,KAAK,mBAAmB,CAAC,MAAO,EAAC;AACtD,OACE,WAAW,UACX,WAAW,QACX,+CAAmB,QAAQ,WAAW,EACtC;AACA,QAAI,KAAK,MACP,MAAM,KAAK,MAAM,YAAY,OAAO;SAEpC,MAAM;IAER,aAAa;GACd;EACF;CACF;CAED,wBAAgC;AAC9B,SAAO;CACR;AACF"}