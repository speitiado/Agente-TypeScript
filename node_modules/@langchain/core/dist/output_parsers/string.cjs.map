{"version":3,"file":"string.cjs","names":["BaseTransformOutputParser","text: string","content: ContentBlock.Text","_content: ContentBlock.Data.URLContentBlock","content: ContentBlock","content: ContentBlock[]","acc: string","item: ContentBlock"],"sources":["../../src/output_parsers/string.ts"],"sourcesContent":["import { BaseTransformOutputParser } from \"./transform.js\";\nimport { ContentBlock } from \"../messages/index.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nexport class StringOutputParser extends BaseTransformOutputParser<string> {\n  static lc_name() {\n    return \"StrOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"string\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parse(text: string): Promise<string> {\n    return Promise.resolve(text);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  protected _textContentToString(content: ContentBlock.Text): string {\n    return content.text;\n  }\n\n  protected _imageUrlContentToString(\n    _content: ContentBlock.Data.URLContentBlock\n  ): string {\n    throw new Error(\n      `Cannot coerce a multimodal \"image_url\" message part into a string.`\n    );\n  }\n\n  protected _messageContentToString(content: ContentBlock): string {\n    switch (content.type) {\n      case \"text\":\n      case \"text_delta\":\n        if (\"text\" in content) {\n          // Type guard for MessageContentText\n          return this._textContentToString(content as ContentBlock.Text);\n        }\n        break;\n      case \"image_url\":\n        if (\"image_url\" in content) {\n          // Type guard for MessageContentImageUrl\n          return this._imageUrlContentToString(\n            content as ContentBlock.Data.URLContentBlock\n          );\n        }\n        break;\n      default:\n        throw new Error(\n          `Cannot coerce \"${content.type}\" message part into a string.`\n        );\n    }\n    throw new Error(`Invalid content type: ${content.type}`);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return content.reduce(\n      (acc: string, item: ContentBlock) =>\n        acc + this._messageContentToString(item),\n      \"\"\n    );\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAqBA,IAAa,qBAAb,cAAwCA,4CAAkC;CACxE,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAkB;EAAkB;CAAS;CAE7D,kBAAkB;;;;;;;;;CAUlB,MAAMC,MAA+B;AACnC,SAAO,QAAQ,QAAQ,KAAK;CAC7B;CAED,wBAAgC;AAC9B,SAAO;CACR;CAED,AAAU,qBAAqBC,SAAoC;AACjE,SAAO,QAAQ;CAChB;CAED,AAAU,yBACRC,UACQ;AACR,QAAM,IAAI,MACR,CAAC,kEAAkE,CAAC;CAEvE;CAED,AAAU,wBAAwBC,SAA+B;AAC/D,UAAQ,QAAQ,MAAhB;GACE,KAAK;GACL,KAAK;AACH,QAAI,UAAU,QAEZ,QAAO,KAAK,qBAAqB,QAA6B;AAEhE;GACF,KAAK;AACH,QAAI,eAAe,QAEjB,QAAO,KAAK,yBACV,QACD;AAEH;GACF,QACE,OAAM,IAAI,MACR,CAAC,eAAe,EAAE,QAAQ,KAAK,6BAA6B,CAAC;EAElE;AACD,QAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,QAAQ,MAAM;CACxD;CAED,AAAU,4BAA4BC,SAAiC;AACrE,SAAO,QAAQ,OACb,CAACC,KAAaC,SACZ,MAAM,KAAK,wBAAwB,KAAK,EAC1C,GACD;CACF;AACF"}