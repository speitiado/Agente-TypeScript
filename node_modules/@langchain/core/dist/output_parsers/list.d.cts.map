{"version":3,"file":"list.d.cts","names":["BaseMessage","BaseTransformOutputParser","ListOutputParser","RegExp","AsyncGenerator","CommaSeparatedListOutputParser","Promise","CustomListOutputParser","length","separator","NumberedListOutputParser","MarkdownListOutputParser"],"sources":["../../src/output_parsers/list.d.ts"],"sourcesContent":["import { BaseMessage } from \"../messages/index.js\";\nimport { BaseTransformOutputParser } from \"./transform.js\";\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nexport declare abstract class ListOutputParser extends BaseTransformOutputParser<string[]> {\n    re?: RegExp;\n    _transform(inputGenerator: AsyncGenerator<string | BaseMessage>): AsyncGenerator<string[]>;\n}\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nexport declare class CommaSeparatedListOutputParser extends ListOutputParser {\n    static lc_name(): string;\n    lc_namespace: string[];\n    lc_serializable: boolean;\n    /**\n     * Parses the given text into an array of strings, using a comma as the\n     * separator. If the parsing fails, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each comma.\n     */\n    parse(text: string): Promise<string[]>;\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CommaSeparatedListOutputParser.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions(): string;\n}\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nexport declare class CustomListOutputParser extends ListOutputParser {\n    lc_namespace: string[];\n    private length;\n    private separator;\n    constructor({ length, separator }: {\n        length?: number;\n        separator?: string;\n    });\n    /**\n     * Parses the given text into an array of strings, using the specified\n     * separator. If the parsing fails or the number of items in the list\n     * doesn't match the expected length, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n     */\n    parse(text: string): Promise<string[]>;\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CustomListOutputParser, including the number of items and the\n     * separator.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions(): string;\n}\nexport declare class NumberedListOutputParser extends ListOutputParser {\n    static lc_name(): string;\n    lc_namespace: string[];\n    lc_serializable: boolean;\n    getFormatInstructions(): string;\n    re: RegExp;\n    parse(text: string): Promise<string[]>;\n}\nexport declare class MarkdownListOutputParser extends ListOutputParser {\n    static lc_name(): string;\n    lc_namespace: string[];\n    lc_serializable: boolean;\n    getFormatInstructions(): string;\n    re: RegExp;\n    parse(text: string): Promise<string[]>;\n}\n"],"mappings":";;;;;;;AAMA;;AACSG,uBADqBD,gBAAAA,SAAyBD,yBAC9CE,CAAAA,MAAAA,EAAAA,CAAAA,CAAAA;EAAM,EAAA,CACwCH,EAD9CG,MAC8CH;EAAW,UAAnCI,CAAAA,cAAAA,EAAAA,cAAAA,CAAAA,MAAAA,GAAwBJ,WAAxBI,CAAAA,CAAAA,EAAuCA,cAAvCA,CAAAA,MAAAA,EAAAA,CAAAA;;;AAFiD;AAQhF;;AAUyBE,cAVJD,8BAAAA,SAAuCH,gBAAAA,CAUnCI;EAAO,OAV4BJ,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAAgB,YAAA,EAAA,MAAA,EAAA;EAsBvDK,eAAAA,EAAAA,OAAAA;EAAsB;;;;;AAAyB;EAwB/CG,KAAAA,CAAAA,IAAAA,EAAAA,MAAAA,CAAAA,EApCIJ,OAoCoB,CAAA,MAAA,EAAA,CAAA;EAAA;;;;AAAyB;EAQjDK,qBAAAA,CAAAA,CAAAA,EAAAA,MAAwB;;;;;AAAyB;cAhCjDJ,sBAAAA,SAA+BL,gBAAAA;;;;;;;;;;;;;;;;;;uBAe3BI;;;;;;;;;cASJI,wBAAAA,SAAiCR,gBAAAA;;;;;MAK9CC;uBACiBG;;cAEJK,wBAAAA,SAAiCT,gBAAAA;;;;;MAK9CC;uBACiBG"}