{"version":3,"file":"ir.js","names":["Operators: { [key: string]: Operator }","Comparators: { [key: string]: Comparator }","visitor: Visitor","comparator: Comparator","attribute: string","value: ValueTypes","operator: Operator","args?: FilterDirective[]","query: string","filter?: FilterDirective"],"sources":["../../src/structured_query/ir.ts"],"sourcesContent":["import { VectorStore } from \"../vectorstores.js\";\n\n/**\n * Represents logical AND operator.\n */\nexport type AND = \"and\";\n/**\n * Represents logical OR operator.\n */\nexport type OR = \"or\";\n/**\n * Represents logical NOT operator.\n */\nexport type NOT = \"not\";\n\n/**\n * Represents a logical operator which can be AND, OR, or NOT.\n */\nexport type Operator = AND | OR | NOT;\n\n/**\n * Represents equality comparison operator.\n */\nexport type EQ = \"eq\";\n/**\n * Represents inequality comparison operator.\n */\nexport type NE = \"ne\";\n/**\n * Represents less than comparison operator.\n */\nexport type LT = \"lt\";\n/**\n * Represents greater than comparison operator.\n */\nexport type GT = \"gt\";\n/**\n * Represents less than or equal to comparison operator.\n */\nexport type LTE = \"lte\";\n/**\n * Represents greater than or equal to comparison operator.\n */\nexport type GTE = \"gte\";\n\n/**\n * Represents a comparison operator which can be EQ, NE, LT, GT, LTE, or\n * GTE.\n */\nexport type Comparator = EQ | NE | LT | GT | LTE | GTE;\n\nexport const Operators: { [key: string]: Operator } = {\n  and: \"and\",\n  or: \"or\",\n  not: \"not\",\n};\n\nexport const Comparators: { [key: string]: Comparator } = {\n  eq: \"eq\",\n  ne: \"ne\",\n  lt: \"lt\",\n  gt: \"gt\",\n  lte: \"lte\",\n  gte: \"gte\",\n};\n\n/**\n * Represents the result of visiting an operation or comparison\n * expression.\n */\nexport type VisitorResult = VisitorOperationResult | VisitorComparisonResult;\n\n/**\n * Represents the result of visiting an operation expression.\n */\nexport type VisitorOperationResult = {\n  [operator: string]: VisitorResult[];\n};\n\n/**\n * Represents the result of visiting a comparison expression.\n */\nexport type VisitorComparisonResult = {\n  [attr: string]: {\n    [comparator: string]: string | number | boolean;\n  };\n};\n\n/**\n * Represents the result of visiting a structured query expression.\n */\nexport type VisitorStructuredQueryResult = {\n  filter?: VisitorComparisonResult | VisitorOperationResult;\n};\n\n/**\n * Abstract class for visiting expressions. Subclasses must implement\n * visitOperation, visitComparison, and visitStructuredQuery methods.\n */\nexport abstract class Visitor<T extends VectorStore = VectorStore> {\n  declare VisitOperationOutput: object;\n\n  declare VisitComparisonOutput: object;\n\n  declare VisitStructuredQueryOutput: { filter?: T[\"FilterType\"] };\n\n  abstract allowedOperators: Operator[];\n\n  abstract allowedComparators: Comparator[];\n\n  abstract visitOperation(operation: Operation): this[\"VisitOperationOutput\"];\n\n  abstract visitComparison(\n    comparison: Comparison\n  ): this[\"VisitComparisonOutput\"];\n\n  abstract visitStructuredQuery(\n    structuredQuery: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"];\n}\n\n/**\n * Abstract class representing an expression. Subclasses must implement\n * the exprName property and the accept method.\n */\nexport abstract class Expression {\n  abstract exprName: \"Operation\" | \"Comparison\" | \"StructuredQuery\";\n\n  accept(visitor: Visitor) {\n    if (this.exprName === \"Operation\") {\n      return visitor.visitOperation(this as unknown as Operation);\n    } else if (this.exprName === \"Comparison\") {\n      return visitor.visitComparison(this as unknown as Comparison);\n    } else if (this.exprName === \"StructuredQuery\") {\n      return visitor.visitStructuredQuery(this as unknown as StructuredQuery);\n    } else {\n      throw new Error(\"Unknown Expression type\");\n    }\n  }\n}\n\n/**\n * Abstract class representing a filter directive. It extends the\n * Expression class.\n */\nexport abstract class FilterDirective extends Expression {}\n\n/**\n * Class representing a comparison filter directive. It extends the\n * FilterDirective class.\n */\nexport class Comparison<ValueTypes = string | number> extends FilterDirective {\n  exprName = \"Comparison\" as const;\n\n  constructor(\n    public comparator: Comparator,\n    public attribute: string,\n    public value: ValueTypes\n  ) {\n    super();\n  }\n}\n\n/**\n * Class representing an operation filter directive. It extends the\n * FilterDirective class.\n */\nexport class Operation extends FilterDirective {\n  exprName = \"Operation\" as const;\n\n  constructor(public operator: Operator, public args?: FilterDirective[]) {\n    super();\n  }\n}\n\n/**\n * Class representing a structured query expression. It extends the\n * Expression class.\n */\nexport class StructuredQuery extends Expression {\n  exprName = \"StructuredQuery\" as const;\n\n  constructor(public query: string, public filter?: FilterDirective) {\n    super();\n  }\n}\n"],"mappings":";AAmDA,MAAaA,YAAyC;CACpD,KAAK;CACL,IAAI;CACJ,KAAK;AACN;AAED,MAAaC,cAA6C;CACxD,IAAI;CACJ,IAAI;CACJ,IAAI;CACJ,IAAI;CACJ,KAAK;CACL,KAAK;AACN;;;;;AAmCD,IAAsB,UAAtB,MAAmE,CAoBlE;;;;;AAMD,IAAsB,aAAtB,MAAiC;CAG/B,OAAOC,SAAkB;AACvB,MAAI,KAAK,aAAa,YACpB,QAAO,QAAQ,eAAe,KAA6B;WAClD,KAAK,aAAa,aAC3B,QAAO,QAAQ,gBAAgB,KAA8B;WACpD,KAAK,aAAa,kBAC3B,QAAO,QAAQ,qBAAqB,KAAmC;MAEvE,OAAM,IAAI,MAAM;CAEnB;AACF;;;;;AAMD,IAAsB,kBAAtB,cAA8C,WAAW,CAAE;;;;;AAM3D,IAAa,aAAb,cAA8D,gBAAgB;CAC5E,WAAW;CAEX,YACSC,YACAC,WACAC,OACP;EACA,OAAO;EAJA;EACA;EACA;CAGR;AACF;;;;;AAMD,IAAa,YAAb,cAA+B,gBAAgB;CAC7C,WAAW;CAEX,YAAmBC,UAA2BC,MAA0B;EACtE,OAAO;EADU;EAA2B;CAE7C;AACF;;;;;AAMD,IAAa,kBAAb,cAAqC,WAAW;CAC9C,WAAW;CAEX,YAAmBC,OAAsBC,QAA0B;EACjE,OAAO;EADU;EAAsB;CAExC;AACF"}