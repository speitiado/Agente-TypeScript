{"version":3,"file":"ir.d.cts","names":["VectorStore","AND","OR","NOT","Operator","EQ","NE","LT","GT","LTE","GTE","Comparator","Operators","Comparators","VisitorResult","VisitorOperationResult","VisitorComparisonResult","VisitorStructuredQueryResult","Visitor","T","Operation","Comparison","StructuredQuery","Expression","FilterDirective","ValueTypes"],"sources":["../../src/structured_query/ir.d.ts"],"sourcesContent":["import { VectorStore } from \"../vectorstores.js\";\n/**\n * Represents logical AND operator.\n */\nexport type AND = \"and\";\n/**\n * Represents logical OR operator.\n */\nexport type OR = \"or\";\n/**\n * Represents logical NOT operator.\n */\nexport type NOT = \"not\";\n/**\n * Represents a logical operator which can be AND, OR, or NOT.\n */\nexport type Operator = AND | OR | NOT;\n/**\n * Represents equality comparison operator.\n */\nexport type EQ = \"eq\";\n/**\n * Represents inequality comparison operator.\n */\nexport type NE = \"ne\";\n/**\n * Represents less than comparison operator.\n */\nexport type LT = \"lt\";\n/**\n * Represents greater than comparison operator.\n */\nexport type GT = \"gt\";\n/**\n * Represents less than or equal to comparison operator.\n */\nexport type LTE = \"lte\";\n/**\n * Represents greater than or equal to comparison operator.\n */\nexport type GTE = \"gte\";\n/**\n * Represents a comparison operator which can be EQ, NE, LT, GT, LTE, or\n * GTE.\n */\nexport type Comparator = EQ | NE | LT | GT | LTE | GTE;\nexport declare const Operators: {\n    [key: string]: Operator;\n};\nexport declare const Comparators: {\n    [key: string]: Comparator;\n};\n/**\n * Represents the result of visiting an operation or comparison\n * expression.\n */\nexport type VisitorResult = VisitorOperationResult | VisitorComparisonResult;\n/**\n * Represents the result of visiting an operation expression.\n */\nexport type VisitorOperationResult = {\n    [operator: string]: VisitorResult[];\n};\n/**\n * Represents the result of visiting a comparison expression.\n */\nexport type VisitorComparisonResult = {\n    [attr: string]: {\n        [comparator: string]: string | number | boolean;\n    };\n};\n/**\n * Represents the result of visiting a structured query expression.\n */\nexport type VisitorStructuredQueryResult = {\n    filter?: VisitorComparisonResult | VisitorOperationResult;\n};\n/**\n * Abstract class for visiting expressions. Subclasses must implement\n * visitOperation, visitComparison, and visitStructuredQuery methods.\n */\nexport declare abstract class Visitor<T extends VectorStore = VectorStore> {\n    VisitOperationOutput: object;\n    VisitComparisonOutput: object;\n    VisitStructuredQueryOutput: {\n        filter?: T[\"FilterType\"];\n    };\n    abstract allowedOperators: Operator[];\n    abstract allowedComparators: Comparator[];\n    abstract visitOperation(operation: Operation): this[\"VisitOperationOutput\"];\n    abstract visitComparison(comparison: Comparison): this[\"VisitComparisonOutput\"];\n    abstract visitStructuredQuery(structuredQuery: StructuredQuery): this[\"VisitStructuredQueryOutput\"];\n}\n/**\n * Abstract class representing an expression. Subclasses must implement\n * the exprName property and the accept method.\n */\nexport declare abstract class Expression {\n    abstract exprName: \"Operation\" | \"Comparison\" | \"StructuredQuery\";\n    accept(visitor: Visitor): object;\n}\n/**\n * Abstract class representing a filter directive. It extends the\n * Expression class.\n */\nexport declare abstract class FilterDirective extends Expression {\n}\n/**\n * Class representing a comparison filter directive. It extends the\n * FilterDirective class.\n */\nexport declare class Comparison<ValueTypes = string | number> extends FilterDirective {\n    comparator: Comparator;\n    attribute: string;\n    value: ValueTypes;\n    exprName: \"Comparison\";\n    constructor(comparator: Comparator, attribute: string, value: ValueTypes);\n}\n/**\n * Class representing an operation filter directive. It extends the\n * FilterDirective class.\n */\nexport declare class Operation extends FilterDirective {\n    operator: Operator;\n    args?: FilterDirective[] | undefined;\n    exprName: \"Operation\";\n    constructor(operator: Operator, args?: FilterDirective[] | undefined);\n}\n/**\n * Class representing a structured query expression. It extends the\n * Expression class.\n */\nexport declare class StructuredQuery extends Expression {\n    query: string;\n    filter?: FilterDirective | undefined;\n    exprName: \"StructuredQuery\";\n    constructor(query: string, filter?: FilterDirective | undefined);\n}\n"],"mappings":";;;;;;AAIA;AAIYE,KAJAD,GAAAA,GAIE,KAAA;AAId;AAIA;;AAAuBA,KARXC,EAAAA,GAQWD,IAAAA;;;AAAc;AAIzBI,KARAF,GAAAA,GAQE,KAAA;AAId;AAIA;AAIA;AAIYM,KApBAL,QAAAA,GAAWH,GAoBR,GApBcC,EAoBd,GApBmBC,GAoBnB;AAIf;AAKA;;AAAyBE,KAzBbA,EAAAA,GAyBaA,IAAAA;;;;AAAoBI,KArBjCH,EAAAA,GAqBiCG,IAAAA;;AAAS;AACtD;AAGqBI,KArBTN,EAAAA,GAqBSM,IAEpB;AAKD;;;AAAqDG,KAxBzCR,EAAAA,GAwByCQ,IAAAA;AAAuB;AAI5E;AAMA;AAQYC,KAtCAR,GAAAA,GAsCAQ,KAAAA;;;;AACiD,KAnCjDP,GAAAA,GAmCiD,KAAA;AAM7D;;;;AAIiBS,KAxCLR,UAAAA,GAAaN,EAwCRc,GAxCab,EAwCba,GAxCkBZ,EAwClBY,GAxCuBX,EAwCvBW,GAxC4BV,GAwC5BU,GAxCkCT,GAwClCS;AAEcf,cAzCVQ,SAyCUR,EAAAA;EAAQ,CAAA,GACNO,EAAAA,MAAAA,CAAAA,EAzCdP,QAyCcO;CAAU;AAEFU,cAzCpBR,WAyCoBQ,EAAAA;EAAU,CAAA,GACAC,EAAAA,MAAAA,CAAAA,EAzChCX,UAyCgCW;AAAe,CAAA;AAMlE;AAQA;AAMA;;AACgBX,KAxDJG,aAAAA,GAAgBC,sBAwDZJ,GAxDqCK,uBAwDrCL;;;;AADsDa,KAnD1DT,sBAAAA,GAmD0DS;EAAe,CAAA,QAAA,EAAA,MAAA,CAAA,EAlD7DV,aAkD6D,EAAA;AAWrF,CAAA;;;;AAI0BV,KA5DdY,uBAAAA,GA4DcZ;EAAQ,CAAA,IAASoB,EAAAA,MAAAA,CAAAA,EAAAA;IAJJA,CAAAA,UAAAA,EAAAA,MAAAA,CAAAA,EAAAA,MAAAA,GAAAA,MAAAA,GAAAA,OAAAA;EAAe,CAAA;AAUtD,CAAA;;;;AAA6CD,KA1DjCN,4BAAAA,GA0DiCM;EAAU,MAAA,CAAA,EAzD1CP,uBAyD0C,GAzDhBD,sBAyDgB;;;;;;uBAnDzBG,kBAAkBlB,cAAcA;;;;aAI7CmB;;6BAEcf;+BACEO;qCACMS;uCACEC;iDACUC;;;;;;uBAMrBC,UAAAA;;kBAEVL;;;;;;uBAMUM,eAAAA,SAAwBD,UAAU;;;;;cAM3CF,iDAAiDG,eAAAA;cACtDb;;SAELc;;0BAEiBd,sCAAsCc;;;;;;cAM7CL,SAAAA,SAAkBI,eAAAA;YACzBpB;SACHoB;;wBAEepB,iBAAiBoB;;;;;;cAMtBF,eAAAA,SAAwBC,UAAAA;;WAEhCC;;sCAE2BA"}