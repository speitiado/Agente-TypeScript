{"version":3,"file":"base.cjs","names":["Visitor","opts?: TranslatorOpts","Operators","Comparators","func: Operator | Comparator","operation: Operation","comparison: Comparison","castValue","query: StructuredQuery","defaultFilter: VisitorStructuredQueryResult[\"filter\"] | undefined","generatedFilter: VisitorStructuredQueryResult[\"filter\"] | undefined","isFilterEmpty"],"sources":["../../src/structured_query/base.ts"],"sourcesContent":["import { VectorStore } from \"../vectorstores.js\";\nimport {\n  Comparator,\n  Comparators,\n  Comparison,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n  Visitor,\n  VisitorComparisonResult,\n  VisitorOperationResult,\n  VisitorResult,\n  VisitorStructuredQueryResult,\n} from \"./ir.js\";\nimport { isFilterEmpty, castValue } from \"./utils.js\";\n\n/**\n * Options object for the BasicTranslator class. Specifies the allowed\n * operators and comparators.\n */\nexport type TranslatorOpts = {\n  allowedOperators: Operator[];\n  allowedComparators: Comparator[];\n};\n\n/**\n * Abstract class that provides a blueprint for creating specific\n * translator classes. Defines two abstract methods: formatFunction and\n * mergeFilters.\n */\nexport abstract class BaseTranslator<\n  T extends VectorStore = VectorStore\n> extends Visitor<T> {\n  /**\n   * Formats a given function (either an operator or a comparator) into a\n   * string.\n   * @param func The function to format.\n   * @returns Formatted string representation of the function.\n   */\n  abstract formatFunction(func: Operator | Comparator): string;\n\n  /**\n   * Merges two filters into one, using a specified merge type.\n   * @param defaultFilter The default filter.\n   * @param generatedFilter The generated filter.\n   * @param mergeType The type of merge to perform. Can be 'and', 'or', or 'replace'.\n   * @param forceDefaultFilter If true, the default filter will be used even if the generated filter is not empty.\n   * @returns The merged filter, or undefined if both filters are empty.\n   */\n  abstract mergeFilters(\n    defaultFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    generatedFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    mergeType?: \"and\" | \"or\" | \"replace\",\n    forceDefaultFilter?: boolean\n  ): this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined;\n}\n\n/**\n * Class that extends the BaseTranslator class and provides concrete\n * implementations for the abstract methods. Also declares three types:\n * VisitOperationOutput, VisitComparisonOutput, and\n * VisitStructuredQueryOutput, which are used as the return types for the\n * visitOperation, visitComparison, and visitStructuredQuery methods\n * respectively.\n */\nexport class BasicTranslator<\n  T extends VectorStore = VectorStore\n> extends BaseTranslator<T> {\n  declare VisitOperationOutput: VisitorOperationResult;\n\n  declare VisitComparisonOutput: VisitorComparisonResult;\n\n  declare VisitStructuredQueryOutput: VisitorStructuredQueryResult;\n\n  allowedOperators: Operator[];\n\n  allowedComparators: Comparator[];\n\n  constructor(opts?: TranslatorOpts) {\n    super();\n    this.allowedOperators = opts?.allowedOperators ?? [\n      Operators.and,\n      Operators.or,\n    ];\n    this.allowedComparators = opts?.allowedComparators ?? [\n      Comparators.eq,\n      Comparators.ne,\n      Comparators.gt,\n      Comparators.gte,\n      Comparators.lt,\n      Comparators.lte,\n    ];\n  }\n\n  formatFunction(func: Operator | Comparator): string {\n    if (func in Comparators) {\n      if (\n        this.allowedComparators.length > 0 &&\n        this.allowedComparators.indexOf(func as Comparator) === -1\n      ) {\n        throw new Error(\n          `Comparator ${func} not allowed. Allowed comparators: ${this.allowedComparators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else if (func in Operators) {\n      if (\n        this.allowedOperators.length > 0 &&\n        this.allowedOperators.indexOf(func as Operator) === -1\n      ) {\n        throw new Error(\n          `Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else {\n      throw new Error(\"Unknown comparator or operator\");\n    }\n    return `$${func}`;\n  }\n\n  /**\n   * Visits an operation and returns a result.\n   * @param operation The operation to visit.\n   * @returns The result of visiting the operation.\n   */\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const args = operation.args?.map((arg) =>\n      arg.accept(this)\n    ) as VisitorResult[];\n    return {\n      [this.formatFunction(operation.operator)]: args,\n    };\n  }\n\n  /**\n   * Visits a comparison and returns a result.\n   * @param comparison The comparison to visit.\n   * @returns The result of visiting the comparison.\n   */\n  visitComparison(comparison: Comparison): this[\"VisitComparisonOutput\"] {\n    return {\n      [comparison.attribute]: {\n        [this.formatFunction(comparison.comparator)]: castValue(\n          comparison.value\n        ),\n      },\n    };\n  }\n\n  /**\n   * Visits a structured query and returns a result.\n   * @param query The structured query to visit.\n   * @returns The result of visiting the structured query.\n   */\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    let nextArg = {};\n    if (query.filter) {\n      nextArg = {\n        filter: query.filter.accept(this),\n      };\n    }\n    return nextArg;\n  }\n\n  mergeFilters(\n    defaultFilter: VisitorStructuredQueryResult[\"filter\"] | undefined,\n    generatedFilter: VisitorStructuredQueryResult[\"filter\"] | undefined,\n    mergeType = \"and\",\n    forceDefaultFilter = false\n  ): VisitorStructuredQueryResult[\"filter\"] | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (forceDefaultFilter) {\n        return defaultFilter;\n      }\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n    if (mergeType === \"and\") {\n      return {\n        $and: [defaultFilter, generatedFilter],\n      };\n    } else if (mergeType === \"or\") {\n      return {\n        $or: [defaultFilter, generatedFilter],\n      };\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n"],"mappings":";;;;;;;;;AA+BA,IAAsB,iBAAtB,cAEUA,mBAAW,CAuBpB;;;;;;;;;AAUD,IAAa,kBAAb,cAEU,eAAkB;CAO1B;CAEA;CAEA,YAAYC,MAAuB;EACjC,OAAO;EACP,KAAK,mBAAmB,MAAM,oBAAoB,CAChDC,qBAAU,KACVA,qBAAU,EACX;EACD,KAAK,qBAAqB,MAAM,sBAAsB;GACpDC,uBAAY;GACZA,uBAAY;GACZA,uBAAY;GACZA,uBAAY;GACZA,uBAAY;GACZA,uBAAY;EACb;CACF;CAED,eAAeC,MAAqC;AAClD,MAAI,QAAQD,wBACV;OACE,KAAK,mBAAmB,SAAS,KACjC,KAAK,mBAAmB,QAAQ,KAAmB,KAAK,GAExD,OAAM,IAAI,MACR,CAAC,WAAW,EAAE,KAAK,mCAAmC,EAAE,KAAK,mBAAmB,KAC9E,KACD,EAAE;EAEN,WACQ,QAAQD,sBACjB;OACE,KAAK,iBAAiB,SAAS,KAC/B,KAAK,iBAAiB,QAAQ,KAAiB,KAAK,GAEpD,OAAM,IAAI,MACR,CAAC,SAAS,EAAE,KAAK,iCAAiC,EAAE,KAAK,iBAAiB,KACxE,KACD,EAAE;EAEN,MAED,OAAM,IAAI,MAAM;AAElB,SAAO,CAAC,CAAC,EAAE,MAAM;CAClB;;;;;;CAOD,eAAeG,WAAoD;EACjE,MAAM,OAAO,UAAU,MAAM,IAAI,CAAC,QAChC,IAAI,OAAO,KAAK,CACjB;AACD,SAAO,GACJ,KAAK,eAAe,UAAU,SAAS,GAAG,KAC5C;CACF;;;;;;CAOD,gBAAgBC,YAAuD;AACrE,SAAO,GACJ,WAAW,YAAY,GACrB,KAAK,eAAe,WAAW,WAAW,GAAGC,wBAC5C,WAAW,MACZ,CACF,EACF;CACF;;;;;;CAOD,qBACEC,OACoC;EACpC,IAAI,UAAU,CAAE;AAChB,MAAI,MAAM,QACR,UAAU,EACR,QAAQ,MAAM,OAAO,OAAO,KAAK,CAClC;AAEH,SAAO;CACR;CAED,aACEC,eACAC,iBACA,YAAY,OACZ,qBAAqB,OAC+B;AACpD,MAAIC,4BAAc,cAAc,IAAIA,4BAAc,gBAAgB,CAChE,QAAO;AAET,MAAIA,4BAAc,cAAc,IAAI,cAAc,WAAW;AAC3D,OAAIA,4BAAc,gBAAgB,CAChC,QAAO;AAET,UAAO;EACR;AACD,MAAIA,4BAAc,gBAAgB,EAAE;AAClC,OAAI,mBACF,QAAO;AAET,OAAI,cAAc,MAChB,QAAO;AAET,UAAO;EACR;AACD,MAAI,cAAc,MAChB,QAAO,EACL,MAAM,CAAC,eAAe,eAAgB,EACvC;WACQ,cAAc,KACvB,QAAO,EACL,KAAK,CAAC,eAAe,eAAgB,EACtC;MAED,OAAM,IAAI,MAAM;CAEnB;AACF"}