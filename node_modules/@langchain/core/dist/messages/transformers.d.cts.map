{"version":3,"file":"transformers.d.cts","names":["BaseDocumentTransformer","BaseLanguageModel","Runnable","AIMessage","AIMessageChunk","BaseMessage","ChatMessage","ChatMessageChunk","FunctionMessage","FunctionMessageChunk","HumanMessage","HumanMessageChunk","MessageType","RemoveMessage","SystemMessage","SystemMessageChunk","ToolMessage","ToolMessageChunk","MessageUnion","MessageChunkUnion","MessageTypeOrClass","FilterMessagesFields","filterMessages","mergeMessageRuns","_TextSplitterInterface","Promise","TrimMessagesFields","trimMessages","defaultTextSplitter"],"sources":["../../src/messages/transformers.d.ts"],"sourcesContent":["import { BaseDocumentTransformer } from \"../documents/transformers.js\";\nimport { BaseLanguageModel } from \"../language_models/base.js\";\nimport { Runnable } from \"../runnables/base.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { BaseMessage } from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { MessageType } from \"./message.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, ToolMessageChunk } from \"./tool.js\";\nexport type MessageUnion = typeof HumanMessage | typeof AIMessage | typeof SystemMessage | typeof ChatMessage | typeof FunctionMessage | typeof ToolMessage | typeof RemoveMessage;\nexport type MessageChunkUnion = typeof HumanMessageChunk | typeof AIMessageChunk | typeof SystemMessageChunk | typeof FunctionMessageChunk | typeof ToolMessageChunk | typeof ChatMessageChunk | typeof RemoveMessage; // RemoveMessage does not have a chunk class.\nexport type MessageTypeOrClass = MessageType | MessageUnion | MessageChunkUnion;\nexport interface FilterMessagesFields {\n    /**\n     * @param {string[] | undefined} includeNames Message names to include.\n     */\n    includeNames?: string[];\n    /**\n     * @param {string[] | undefined} excludeNames Messages names to exclude.\n     */\n    excludeNames?: string[];\n    /**\n     * @param {(MessageType | BaseMessage)[] | undefined} includeTypes Message types to include. Can be specified as string names (e.g.\n     *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n     *     SystemMessage, HumanMessage, AIMessage, ...).\n     */\n    includeTypes?: MessageTypeOrClass[];\n    /**\n     * @param {(MessageType | BaseMessage)[] | undefined} excludeTypes Message types to exclude. Can be specified as string names (e.g.\n     *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n     *     SystemMessage, HumanMessage, AIMessage, ...).\n     */\n    excludeTypes?: MessageTypeOrClass[];\n    /**\n     * @param {string[] | undefined} includeIds Message IDs to include.\n     */\n    includeIds?: string[];\n    /**\n     * @param {string[] | undefined} excludeIds Message IDs to exclude.\n     */\n    excludeIds?: string[];\n}\n/**\n * Filter messages based on name, type or id.\n *\n * @param {BaseMessage[] | FilterMessagesFields} messagesOrOptions - Either an array of BaseMessage objects to filter or the filtering options. If an array is provided, the `options` parameter should also be supplied. If filtering options are provided, a RunnableLambda is returned.\n * @param {FilterMessagesFields} [options] - Optional filtering options. Should only be provided if `messagesOrOptions` is an array of BaseMessage objects.\n * @returns A list of Messages that meets at least one of the include conditions and none\n *     of the exclude conditions, or a RunnableLambda which does the same. If no include conditions are specified then\n *     anything that is not explicitly excluded will be included.\n * @throws {Error} If two incompatible arguments are provided.\n *\n * @example\n * ```typescript\n * import { filterMessages, AIMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n *   new AIMessage({ content: \"steve-o\", id: \"bar\", name: \"example_assistant\" }),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"baz\" }),\n *   new AIMessage({ content: \"silicon blue\" , id: \"blah\" }),\n * ];\n *\n * filterMessages(messages, {\n *   includeNames: [\"example_user\", \"example_assistant\"],\n *   includeTypes: [\"system\"],\n *   excludeIds: [\"bar\"],\n * });\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n * ]\n * ```\n */\nexport declare function filterMessages(options?: FilterMessagesFields): Runnable<BaseMessage[], BaseMessage[]>;\nexport declare function filterMessages(messages: BaseMessage[], options?: FilterMessagesFields): BaseMessage[];\n/**\n * Merge consecutive Messages of the same type.\n *\n * **NOTE**: ToolMessages are not merged, as each has a distinct tool call id that\n * can't be merged.\n *\n * @param {BaseMessage[] | undefined} messages Sequence of Message-like objects to merge. Optional. If not provided, a RunnableLambda is returned.\n * @returns List of BaseMessages with consecutive runs of message types merged into single\n *     messages, or a RunnableLambda which returns a list of BaseMessages If two messages being merged both have string contents, the merged\n *     content is a concatenation of the two strings with a new-line separator. If at\n *     least one of the messages has a list of content blocks, the merged content is a\n *     list of content blocks.\n *\n * @example\n * ```typescript\n * import { mergeMessageRuns, AIMessage, HumanMessage, SystemMessage, ToolCall } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"foo\" }),\n *   new HumanMessage({ content: \"wait your favorite food\", id: \"bar\" }),\n *   new AIMessage({\n *     content: \"my favorite colo\",\n *     tool_calls: [{ name: \"blah_tool\", args: { x: 2 }, id: \"123\" }],\n *     id: \"baz\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"my favorite dish is lasagna\" }],\n *     tool_calls: [{ name: \"blah_tool\", args: { x: -10 }, id: \"456\" }],\n *     id: \"blur\",\n *   }),\n * ];\n *\n * mergeMessageRuns(messages);\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({\n *     content: \"what's your favorite colorwait your favorite food\",\n *     id: \"foo\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"my favorite colo\" },\n *       { type: \"text\", text: \"my favorite dish is lasagna\" },\n *     ],\n *     tool_calls: [\n *       { name: \"blah_tool\", args: { x: 2 }, id: \"123\" },\n *       { name: \"blah_tool\", args: { x: -10 }, id: \"456\" },\n *     ],\n *     id: \"baz\",\n *   }),\n * ]\n * ```\n */\nexport declare function mergeMessageRuns(): Runnable<BaseMessage[], BaseMessage[]>;\nexport declare function mergeMessageRuns(messages: BaseMessage[]): BaseMessage[];\n// Since we can not import from `@langchain/textsplitters` we need\n// to reconstruct the interface here.\ninterface _TextSplitterInterface extends BaseDocumentTransformer {\n    splitText(text: string): Promise<string[]>;\n}\nexport interface TrimMessagesFields {\n    /**\n     * @param {number} maxTokens Max token count of trimmed messages.\n     */\n    maxTokens: number;\n    /**\n     * @param {((messages: BaseMessage[]) => number) | ((messages: BaseMessage[]) => Promise<number>) | BaseLanguageModel} tokenCounter\n     * Function or LLM for counting tokens in an array of `BaseMessage`s.\n     * If a `BaseLanguageModel` is passed in then `BaseLanguageModel.getNumTokens()` will be used.\n     */\n    tokenCounter: ((messages: BaseMessage[]) => number) | ((messages: BaseMessage[]) => Promise<number>) | BaseLanguageModel;\n    /**\n     * @param {\"first\" | \"last\"} [strategy=\"last\"] Strategy for trimming.\n     * - \"first\": Keep the first <= n_count tokens of the messages.\n     * - \"last\": Keep the last <= n_count tokens of the messages.\n     * @default \"last\"\n     */\n    strategy?: \"first\" | \"last\";\n    /**\n     * @param {boolean} [allowPartial=false] Whether to split a message if only part of the message can be included.\n     * If `strategy: \"last\"` then the last partial contents of a message are included.\n     * If `strategy: \"first\"` then the first partial contents of a message are included.\n     * @default false\n     */\n    allowPartial?: boolean;\n    /**\n     * @param {MessageTypeOrClass | MessageTypeOrClass[]} [endOn] The message type to end on.\n     * If specified then every message after the last occurrence of this type is ignored.\n     * If `strategy === \"last\"` then this is done before we attempt to get the last `maxTokens`.\n     * If `strategy === \"first\"` then this is done after we get the first `maxTokens`.\n     * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n     * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n     */\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    /**\n     * @param {MessageTypeOrClass | MessageTypeOrClass[]} [startOn] The message type to start on.\n     * Should only be specified if `strategy: \"last\"`. If specified then every message before the first occurrence\n     * of this type is ignored. This is done after we trim the initial messages to the last `maxTokens`.\n     * Does not apply to a `SystemMessage` at index 0 if `includeSystem: true`.\n     * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n     * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n     */\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    /**\n     * @param {boolean} [includeSystem=false] Whether to keep the `SystemMessage` if there is one at index 0.\n     * Should only be specified if `strategy: \"last\"`.\n     * @default false\n     */\n    includeSystem?: boolean;\n    /**\n     * @param {((text: string) => string[]) | BaseDocumentTransformer} [textSplitter] Function or `BaseDocumentTransformer` for\n     * splitting the string contents of a message. Only used if `allowPartial: true`.\n     * If `strategy: \"last\"` then the last split tokens from a partial message will be included.\n     * If `strategy: \"first\"` then the first split tokens from a partial message will be included.\n     * Token splitter assumes that separators are kept, so that split contents can be directly concatenated\n     * to recreate the original text. Defaults to splitting on newlines.\n     */\n    textSplitter?: ((text: string) => string[]) | ((text: string) => Promise<string[]>) | _TextSplitterInterface;\n}\n/**\n * Trim messages to be below a token count.\n *\n * @param {BaseMessage[]} messages Array of `BaseMessage` instances to trim.\n * @param {TrimMessagesFields} options Trimming options.\n * @returns An array of trimmed `BaseMessage`s or a `Runnable` that takes a sequence of `BaseMessage`-like objects and returns\n *     an array of trimmed `BaseMessage`s.\n * @throws {Error} If two incompatible arguments are specified or an unrecognized `strategy` is specified.\n *\n * @example\n * ```typescript\n * import { trimMessages, AIMessage, BaseMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"This is a 4 token text. The full message is 10 tokens.\"),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"This is the FIRST 4 token block.\" },\n *       { type: \"text\", text: \"This is the SECOND 4 token block.\" },\n *     ],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ];\n *\n * function dummyTokenCounter(messages: BaseMessage[]): number {\n *   // treat each message like it adds 3 default tokens at the beginning\n *   // of the message and at the end of the message. 3 + 4 + 3 = 10 tokens\n *   // per message.\n *\n *   const defaultContentLen = 4;\n *   const defaultMsgPrefixLen = 3;\n *   const defaultMsgSuffixLen = 3;\n *\n *   let count = 0;\n *   for (const msg of messages) {\n *     if (typeof msg.content === \"string\") {\n *       count += defaultMsgPrefixLen + defaultContentLen + defaultMsgSuffixLen;\n *     }\n *     if (Array.isArray(msg.content)) {\n *       count +=\n *         defaultMsgPrefixLen +\n *         msg.content.length * defaultContentLen +\n *         defaultMsgSuffixLen;\n *     }\n *   }\n *   return count;\n * }\n * ```\n *\n * First 30 tokens, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages, have to end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n *   endOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   includeSystem: true,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   allowPartial: true,\n *   includeSystem: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, allowing partial messages, end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   endOn: \"human\",\n *   includeSystem: true,\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages, start on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   includeSystem: true,\n *   allowPartial: true,\n *   startOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n */\nexport declare function trimMessages(options: TrimMessagesFields): Runnable<BaseMessage[], BaseMessage[]>;\nexport declare function trimMessages(messages: BaseMessage[], options: TrimMessagesFields): Promise<BaseMessage[]>;\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nexport declare function defaultTextSplitter(text: string): Promise<string[]>;\nexport {};\n"],"mappings":";;;;;;;;;;;;;;KAYYkB,YAAAA,UAAsBR,sBAAsBP,mBAAmBW,uBAAuBR,qBAAqBE,yBAAyBQ,qBAAqBH;KACzJM,iBAAAA,UAA2BR,2BAA2BP,wBAAwBW,4BAA4BN,8BAA8BQ,0BAA0BV,0BAA0BM;AAD5LK,KAEAE,kBAAAA,GAAqBR,WAFT,GAEuBM,YAFvB,GAEsCC,iBAFtC;AAAA,UAGPE,oBAAAA,CAHO;EAAA;;;EAAgE,YAAUf,CAAAA,EAAAA,MAAAA,EAAAA;EAAW;;;EAAqE,YAAA,CAAA,EAAA,MAAA,EAAA;EACtKa;;;;;EAAgG,YAAUV,CAAAA,EAgBnGW,kBAhBmGX,EAAAA;EAAoB;;;AAA2E;AACrN;EAA8B,YAAA,CAAA,EAqBXW,kBArBW,EAAA;EAAA;;;EAAiD,UAAA,CAAA,EAAA,MAAA,EAAA;EAC9DC;;;EAcoB,UAMlBD,CAAAA,EAAAA,MAAAA,EAAAA;AAAkB;AA+CrC;;;;;;AAAgF;AAChF;;;;;AAA4G;AA2D5G;;;;;AAAoD;AACpD;;;;AAA8E;AAAG;;;;AAGjB;AAGhE;;;;;;;;AA0CcA,iBA7GUE,cAAAA,CA6GVF,OAAAA,CAAAA,EA7GmCC,oBA6GnCD,CAAAA,EA7G0DlB,QA6G1DkB,CA7GmEf,WA6GnEe,EAAAA,EA7GkFf,WA6GlFe,EAAAA,CAAAA;AAAqBA,iBA5GXE,cAAAA,CA4GWF,QAAAA,EA5Gcf,WA4Gde,EAAAA,EAAAA,OAAAA,CAAAA,EA5GuCC,oBA4GvCD,CAAAA,EA5G8Df,WA4G9De,EAAAA;;;AAe6E;AA6PhH;;;;;;AAA2E;AAC3E;;;;;;AAAmG;AAOnG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBArUwBG,gBAAAA,CAAAA,GAAoBrB,SAASG,eAAeA;iBAC5CkB,gBAAAA,WAA2BlB,gBAAgBA;;;UAGzDmB,sBAAAA,SAA+BxB;2BACZyB;;UAEZC,kBAAAA;;;;;;;;;;4BAUarB,wCAAwCA,kBAAkBoB,mBAAmBxB;;;;;;;;;;;;;;;;;;;;;;;UAuB/FmB,qBAAqBA;;;;;;;;;YASnBA,qBAAqBA;;;;;;;;;;;;;;;mEAekCK,qBAAqBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBA6PlEG,YAAAA,UAAsBD,qBAAqBxB,SAASG,eAAeA;iBACnEsB,YAAAA,WAAuBtB,wBAAwBqB,qBAAqBD,QAAQpB;;;;;;;iBAO5EuB,mBAAAA,gBAAmCH"}