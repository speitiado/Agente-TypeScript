{"version":3,"file":"ai.js","names":["fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>","initParams: AIMessageFields<TStructure>","toolCalls","obj: unknown","x: BaseMessage","x: BaseMessageChunk","fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>","initParams: AIMessageChunkFields<TStructure>","toolCalls: ToolCall[]","invalidToolCalls: InvalidToolCall[]","parsedArgs: Record<string, unknown> | null","chunk: AIMessageChunk<TStructure>","combinedFields: AIMessageChunkFields"],"sources":["../../src/messages/ai.ts"],"sourcesContent":["import { parsePartialJson } from \"../utils/json.js\";\nimport {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  _mergeLists,\n  BaseMessageFields,\n} from \"./base.js\";\nimport { getTranslator } from \"./block_translators/index.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport {\n  $InferMessageContent,\n  $InferMessageProperty,\n  MessageStructure,\n} from \"./message.js\";\nimport { mergeResponseMetadata, mergeUsageMetadata } from \"./metadata.js\";\nimport {\n  InvalidToolCall,\n  ToolCall,\n  ToolCallChunk,\n  defaultToolCallParser,\n} from \"./tool.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface AIMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"ai\"> {\n  tool_calls?: ToolCall[];\n  invalid_tool_calls?: InvalidToolCall[];\n  usage_metadata?: $InferMessageProperty<TStructure, \"ai\", \"usage_metadata\">;\n}\n\nexport class AIMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"ai\">\n  implements AIMessageFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  usage_metadata?: AIMessageFields<TStructure>[\"usage_metadata\"];\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n    };\n  }\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>\n  ) {\n    let initParams: AIMessageFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        additional_kwargs: {},\n      };\n    } else {\n      initParams = fields;\n      const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n      const toolCalls = initParams.tool_calls;\n      if (\n        !(rawToolCalls == null) &&\n        rawToolCalls.length > 0 &&\n        (toolCalls === undefined || toolCalls.length === 0)\n      ) {\n        console.warn(\n          [\n            \"New LangChain packages are available that more efficiently handle\",\n            \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n            \"message tool calls. e.g., `pnpm install @langchain/anthropic`,\",\n            \"pnpm install @langchain/openai`, etc.\",\n          ].join(\" \")\n        );\n      }\n      try {\n        if (!(rawToolCalls == null) && toolCalls === undefined) {\n          const [toolCalls, invalidToolCalls] =\n            defaultToolCallParser(rawToolCalls);\n          initParams.tool_calls = toolCalls ?? [];\n          initParams.invalid_tool_calls = invalidToolCalls ?? [];\n        } else {\n          initParams.tool_calls = initParams.tool_calls ?? [];\n          initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n        }\n      } catch {\n        // Do nothing if parsing fails\n        initParams.tool_calls = [];\n        initParams.invalid_tool_calls = [];\n      }\n\n      // Convert content to content blocks if output version is v1\n      if (\n        initParams.response_metadata !== undefined &&\n        \"output_version\" in initParams.response_metadata &&\n        initParams.response_metadata.output_version === \"v1\"\n      ) {\n        initParams.contentBlocks =\n          initParams.content as Array<ContentBlock.Standard>;\n        initParams.content = undefined;\n      }\n\n      if (initParams.contentBlocks !== undefined) {\n        // Add constructor tool calls as content blocks\n        initParams.contentBlocks.push(\n          ...initParams.tool_calls.map((toolCall) => ({\n            type: \"tool_call\" as const,\n            id: toolCall.id,\n            name: toolCall.name,\n            args: toolCall.args,\n          }))\n        );\n        // Add content block tool calls that aren't in the constructor tool calls\n        const missingToolCalls = initParams.contentBlocks\n          .filter<ContentBlock.Tools.ToolCall>(\n            (block): block is ContentBlock.Tools.ToolCall =>\n              block.type === \"tool_call\"\n          )\n          .filter(\n            (block) =>\n              !initParams.tool_calls?.some(\n                (toolCall) =>\n                  toolCall.id === block.id && toolCall.name === block.name\n              )\n          );\n        if (missingToolCalls.length > 0) {\n          initParams.tool_calls = missingToolCalls.map((block) => ({\n            type: \"tool_call\" as const,\n            id: block.id!,\n            name: block.name,\n            args: block.args as Record<string, unknown>,\n          }));\n        }\n      }\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    if (typeof initParams !== \"string\") {\n      this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n      this.invalid_tool_calls =\n        initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    }\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  static lc_name() {\n    return \"AIMessage\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      const missingToolCalls = this.tool_calls.filter(\n        (block) =>\n          !blocks.some((b) => b.id === block.id && b.name === block.name)\n      );\n      blocks.push(\n        ...missingToolCalls.map((block) => ({\n          ...block,\n          type: \"tool_call\" as const,\n          id: block.id,\n          name: block.name,\n          args: block.args,\n        }))\n      );\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is AIMessage {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n\n/**\n * @deprecated Use {@link AIMessage.isInstance} instead\n */\nexport function isAIMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is AIMessage<TStructure> {\n  return x._getType() === \"ai\";\n}\n\n/**\n * @deprecated Use {@link AIMessageChunk.isInstance} instead\n */\nexport function isAIMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is AIMessageChunk<TStructure> {\n  return x._getType() === \"ai\";\n}\n\nexport type AIMessageChunkFields<\n  TStructure extends MessageStructure = MessageStructure\n> = AIMessageFields<TStructure> & {\n  tool_call_chunks?: ToolCallChunk[];\n};\n\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk<\n    TStructure extends MessageStructure = MessageStructure\n  >\n  extends BaseMessageChunk<TStructure, \"ai\">\n  implements AIMessage<TStructure>, AIMessageChunkFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  tool_call_chunks?: ToolCallChunk[] = [];\n\n  usage_metadata?: AIMessageChunkFields<TStructure>[\"usage_metadata\"];\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>\n  ) {\n    let initParams: AIMessageChunkFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n      };\n    } else if (fields.tool_call_chunks === undefined) {\n      initParams = {\n        ...fields,\n        tool_calls: fields.tool_calls ?? [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    } else {\n      const groupedToolCallChunks = fields.tool_call_chunks.reduce(\n        (acc, chunk) => {\n          const matchedChunkIndex = acc.findIndex(([match]) => {\n            // If chunk has an id and index, match if both are present\n            if (\n              \"id\" in chunk &&\n              chunk.id &&\n              \"index\" in chunk &&\n              chunk.index !== undefined\n            ) {\n              return chunk.id === match.id && chunk.index === match.index;\n            }\n            // If chunk has an id, we match on id\n            if (\"id\" in chunk && chunk.id) {\n              return chunk.id === match.id;\n            }\n            // If chunk has an index, we match on index\n            if (\"index\" in chunk && chunk.index !== undefined) {\n              return chunk.index === match.index;\n            }\n            return false;\n          });\n          if (matchedChunkIndex !== -1) {\n            acc[matchedChunkIndex].push(chunk);\n          } else {\n            acc.push([chunk]);\n          }\n          return acc;\n        },\n        [] as ToolCallChunk[][]\n      );\n\n      const toolCalls: ToolCall[] = [];\n      const invalidToolCalls: InvalidToolCall[] = [];\n      for (const chunks of groupedToolCallChunks) {\n        let parsedArgs: Record<string, unknown> | null = null;\n        const name = chunks[0]?.name ?? \"\";\n        const joinedArgs = chunks.map((c) => c.args || \"\").join(\"\");\n        const argsStr = joinedArgs.length ? joinedArgs : \"{}\";\n        const id = chunks[0]?.id;\n        try {\n          parsedArgs = parsePartialJson(argsStr);\n          if (\n            !id ||\n            parsedArgs === null ||\n            typeof parsedArgs !== \"object\" ||\n            Array.isArray(parsedArgs)\n          ) {\n            throw new Error(\"Malformed tool call chunk args.\");\n          }\n          toolCalls.push({\n            name,\n            args: parsedArgs,\n            id,\n            type: \"tool_call\",\n          });\n        } catch {\n          invalidToolCalls.push({\n            name,\n            args: argsStr,\n            id,\n            error: \"Malformed args.\",\n            type: \"invalid_tool_call\",\n          });\n        }\n      }\n      initParams = {\n        ...fields,\n        tool_calls: toolCalls,\n        invalid_tool_calls: invalidToolCalls,\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    this.tool_call_chunks =\n      initParams.tool_call_chunks ?? this.tool_call_chunks;\n    this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n    this.invalid_tool_calls =\n      initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n      tool_call_chunks: \"tool_call_chunks\",\n    };\n  }\n\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      if (typeof this.content !== \"string\") {\n        const contentToolCalls = this.content\n          .filter((block) => block.type === \"tool_call\")\n          .map((block) => block.id);\n        for (const toolCall of this.tool_calls) {\n          if (toolCall.id && !contentToolCalls.includes(toolCall.id)) {\n            blocks.push({\n              ...toolCall,\n              type: \"tool_call\",\n              id: toolCall.id,\n              name: toolCall.name,\n              args: toolCall.args,\n            });\n          }\n        }\n      }\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      tool_call_chunks: this.tool_call_chunks,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  concat(chunk: AIMessageChunk<TStructure>) {\n    const combinedFields: AIMessageChunkFields = {\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: mergeResponseMetadata(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      tool_call_chunks: [],\n      id: this.id ?? chunk.id,\n    };\n    if (\n      this.tool_call_chunks !== undefined ||\n      chunk.tool_call_chunks !== undefined\n    ) {\n      const rawToolCalls = _mergeLists(\n        this.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[],\n        chunk.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[]\n      );\n      if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n        combinedFields.tool_call_chunks = rawToolCalls;\n      }\n    }\n    if (\n      this.usage_metadata !== undefined ||\n      chunk.usage_metadata !== undefined\n    ) {\n      combinedFields.usage_metadata = mergeUsageMetadata(\n        this.usage_metadata,\n        chunk.usage_metadata\n      );\n    }\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls(combinedFields);\n  }\n\n  static isInstance(obj: unknown): obj is AIMessageChunk {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n"],"mappings":";;;;;;;AAiCA,IAAa,YAAb,cACU,YAEV;CACE,AAAS,OAAO;CAEhB,aAA0B,CAAE;CAE5B,qBAAyC,CAAE;CAE3C;CAEA,IAAI,aAAqC;AAEvC,SAAO;GACL,GAAG,MAAM;GACT,YAAY;GACZ,oBAAoB;EACrB;CACF;CAED,YACEA,QACA;EACA,IAAIC;AACJ,MAAI,OAAO,WAAW,YAAY,MAAM,QAAQ,OAAO,EACrD,aAAa;GACX,SAAS;GACT,YAAY,CAAE;GACd,oBAAoB,CAAE;GACtB,mBAAmB,CAAE;EACtB;OACI;GACL,aAAa;GACb,MAAM,eAAe,WAAW,mBAAmB;GACnD,MAAM,YAAY,WAAW;AAC7B,OACE,EAAE,gBAAgB,SAClB,aAAa,SAAS,MACrB,cAAc,UAAa,UAAU,WAAW,IAEjD,QAAQ,KACN;IACE;IACA;IACA;IACA;GACD,EAAC,KAAK,IAAI,CACZ;AAEH,OAAI;AACF,QAAI,EAAE,gBAAgB,SAAS,cAAc,QAAW;KACtD,MAAM,CAACC,aAAW,iBAAiB,GACjC,sBAAsB,aAAa;KACrC,WAAW,aAAaA,eAAa,CAAE;KACvC,WAAW,qBAAqB,oBAAoB,CAAE;IACvD,OAAM;KACL,WAAW,aAAa,WAAW,cAAc,CAAE;KACnD,WAAW,qBAAqB,WAAW,sBAAsB,CAAE;IACpE;GACF,QAAO;IAEN,WAAW,aAAa,CAAE;IAC1B,WAAW,qBAAqB,CAAE;GACnC;AAGD,OACE,WAAW,sBAAsB,UACjC,oBAAoB,WAAW,qBAC/B,WAAW,kBAAkB,mBAAmB,MAChD;IACA,WAAW,gBACT,WAAW;IACb,WAAW,UAAU;GACtB;AAED,OAAI,WAAW,kBAAkB,QAAW;IAE1C,WAAW,cAAc,KACvB,GAAG,WAAW,WAAW,IAAI,CAAC,cAAc;KAC1C,MAAM;KACN,IAAI,SAAS;KACb,MAAM,SAAS;KACf,MAAM,SAAS;IAChB,GAAE,CACJ;IAED,MAAM,mBAAmB,WAAW,cACjC,OACC,CAAC,UACC,MAAM,SAAS,YAClB,CACA,OACC,CAAC,UACC,CAAC,WAAW,YAAY,KACtB,CAAC,aACC,SAAS,OAAO,MAAM,MAAM,SAAS,SAAS,MAAM,KACvD,CACJ;AACH,QAAI,iBAAiB,SAAS,GAC5B,WAAW,aAAa,iBAAiB,IAAI,CAAC,WAAW;KACvD,MAAM;KACN,IAAI,MAAM;KACV,MAAM,MAAM;KACZ,MAAM,MAAM;IACb,GAAE;GAEN;EACF;EAGD,MAAM,WAAW;AACjB,MAAI,OAAO,eAAe,UAAU;GAClC,KAAK,aAAa,WAAW,cAAc,KAAK;GAChD,KAAK,qBACH,WAAW,sBAAsB,KAAK;EACzC;EACD,KAAK,iBAAiB,WAAW;CAClC;CAED,OAAO,UAAU;AACf,SAAO;CACR;CAED,IAAI,gBAA8C;AAChD,MACE,KAAK,qBACL,oBAAoB,KAAK,qBACzB,KAAK,kBAAkB,mBAAmB,KAE1C,QAAO,KAAK;AAGd,MACE,KAAK,qBACL,oBAAoB,KAAK,qBACzB,OAAO,KAAK,kBAAkB,mBAAmB,UACjD;GACA,MAAM,aAAa,cAAc,KAAK,kBAAkB,eAAe;AACvE,OAAI,WACF,QAAO,WAAW,iBAAiB,KAAK;EAE3C;EAED,MAAM,SAAS,MAAM;AAErB,MAAI,KAAK,YAAY;GACnB,MAAM,mBAAmB,KAAK,WAAW,OACvC,CAAC,UACC,CAAC,OAAO,KAAK,CAAC,MAAM,EAAE,OAAO,MAAM,MAAM,EAAE,SAAS,MAAM,KAAK,CAClE;GACD,OAAO,KACL,GAAG,iBAAiB,IAAI,CAAC,WAAW;IAClC,GAAG;IACH,MAAM;IACN,IAAI,MAAM;IACV,MAAM,MAAM;IACZ,MAAM,MAAM;GACb,GAAE,CACJ;EACF;AAED,SAAO;CACR;CAED,IAAa,mBAA4C;AACvD,SAAO;GACL,GAAG,MAAM;GACT,YAAY,KAAK;GACjB,oBAAoB,KAAK;GACzB,gBAAgB,KAAK;EACtB;CACF;CAED,OAAO,WAAWC,KAAgC;AAChD,SAAO,MAAM,WAAW,IAAI,IAAI,IAAI,SAAS;CAC9C;AACF;;;;AAKD,SAAgB,YACdC,GAC4B;AAC5B,QAAO,EAAE,UAAU,KAAK;AACzB;;;;AAKD,SAAgB,iBACdC,GACiC;AACjC,QAAO,EAAE,UAAU,KAAK;AACzB;;;;;AAYD,IAAa,iBAAb,cAGU,iBAEV;CACE,AAAS,OAAO;CAEhB,aAA0B,CAAE;CAE5B,qBAAyC,CAAE;CAE3C,mBAAqC,CAAE;CAEvC;CAEA,YACEC,QAGA;EACA,IAAIC;AACJ,MAAI,OAAO,WAAW,YAAY,MAAM,QAAQ,OAAO,EACrD,aAAa;GACX,SAAS;GACT,YAAY,CAAE;GACd,oBAAoB,CAAE;GACtB,kBAAkB,CAAE;EACrB;WACQ,OAAO,qBAAqB,QACrC,aAAa;GACX,GAAG;GACH,YAAY,OAAO,cAAc,CAAE;GACnC,oBAAoB,CAAE;GACtB,kBAAkB,CAAE;GACpB,gBACE,OAAO,mBAAmB,SACtB,OAAO,iBACP;EACP;OACI;GACL,MAAM,wBAAwB,OAAO,iBAAiB,OACpD,CAAC,KAAK,UAAU;IACd,MAAM,oBAAoB,IAAI,UAAU,CAAC,CAAC,MAAM,KAAK;AAEnD,SACE,QAAQ,SACR,MAAM,MACN,WAAW,SACX,MAAM,UAAU,OAEhB,QAAO,MAAM,OAAO,MAAM,MAAM,MAAM,UAAU,MAAM;AAGxD,SAAI,QAAQ,SAAS,MAAM,GACzB,QAAO,MAAM,OAAO,MAAM;AAG5B,SAAI,WAAW,SAAS,MAAM,UAAU,OACtC,QAAO,MAAM,UAAU,MAAM;AAE/B,YAAO;IACR,EAAC;AACF,QAAI,sBAAsB,IACxB,IAAI,mBAAmB,KAAK,MAAM;SAElC,IAAI,KAAK,CAAC,KAAM,EAAC;AAEnB,WAAO;GACR,GACD,CAAE,EACH;GAED,MAAMC,YAAwB,CAAE;GAChC,MAAMC,mBAAsC,CAAE;AAC9C,QAAK,MAAM,UAAU,uBAAuB;IAC1C,IAAIC,aAA6C;IACjD,MAAM,OAAO,OAAO,IAAI,QAAQ;IAChC,MAAM,aAAa,OAAO,IAAI,CAAC,MAAM,EAAE,QAAQ,GAAG,CAAC,KAAK,GAAG;IAC3D,MAAM,UAAU,WAAW,SAAS,aAAa;IACjD,MAAM,KAAK,OAAO,IAAI;AACtB,QAAI;KACF,aAAa,iBAAiB,QAAQ;AACtC,SACE,CAAC,MACD,eAAe,QACf,OAAO,eAAe,YACtB,MAAM,QAAQ,WAAW,CAEzB,OAAM,IAAI,MAAM;KAElB,UAAU,KAAK;MACb;MACA,MAAM;MACN;MACA,MAAM;KACP,EAAC;IACH,QAAO;KACN,iBAAiB,KAAK;MACpB;MACA,MAAM;MACN;MACA,OAAO;MACP,MAAM;KACP,EAAC;IACH;GACF;GACD,aAAa;IACX,GAAG;IACH,YAAY;IACZ,oBAAoB;IACpB,gBACE,OAAO,mBAAmB,SACtB,OAAO,iBACP;GACP;EACF;EAGD,MAAM,WAAW;EACjB,KAAK,mBACH,WAAW,oBAAoB,KAAK;EACtC,KAAK,aAAa,WAAW,cAAc,KAAK;EAChD,KAAK,qBACH,WAAW,sBAAsB,KAAK;EACxC,KAAK,iBAAiB,WAAW;CAClC;CAED,IAAI,aAAqC;AAEvC,SAAO;GACL,GAAG,MAAM;GACT,YAAY;GACZ,oBAAoB;GACpB,kBAAkB;EACnB;CACF;CAED,OAAO,UAAU;AACf,SAAO;CACR;CAED,IAAI,gBAA8C;AAChD,MACE,KAAK,qBACL,oBAAoB,KAAK,qBACzB,KAAK,kBAAkB,mBAAmB,KAE1C,QAAO,KAAK;AAGd,MACE,KAAK,qBACL,oBAAoB,KAAK,qBACzB,OAAO,KAAK,kBAAkB,mBAAmB,UACjD;GACA,MAAM,aAAa,cAAc,KAAK,kBAAkB,eAAe;AACvE,OAAI,WACF,QAAO,WAAW,iBAAiB,KAAK;EAE3C;EAED,MAAM,SAAS,MAAM;AAErB,MAAI,KAAK,YACP;OAAI,OAAO,KAAK,YAAY,UAAU;IACpC,MAAM,mBAAmB,KAAK,QAC3B,OAAO,CAAC,UAAU,MAAM,SAAS,YAAY,CAC7C,IAAI,CAAC,UAAU,MAAM,GAAG;AAC3B,SAAK,MAAM,YAAY,KAAK,WAC1B,KAAI,SAAS,MAAM,CAAC,iBAAiB,SAAS,SAAS,GAAG,EACxD,OAAO,KAAK;KACV,GAAG;KACH,MAAM;KACN,IAAI,SAAS;KACb,MAAM,SAAS;KACf,MAAM,SAAS;IAChB,EAAC;GAGP;;AAGH,SAAO;CACR;CAED,IAAa,mBAA4C;AACvD,SAAO;GACL,GAAG,MAAM;GACT,YAAY,KAAK;GACjB,kBAAkB,KAAK;GACvB,oBAAoB,KAAK;GACzB,gBAAgB,KAAK;EACtB;CACF;CAED,OAAOC,OAAmC;EACxC,MAAMC,iBAAuC;GAC3C,SAAS,aAAa,KAAK,SAAS,MAAM,QAAQ;GAClD,mBAAmB,YACjB,KAAK,mBACL,MAAM,kBACP;GACD,mBAAmB,sBACjB,KAAK,mBACL,MAAM,kBACP;GACD,kBAAkB,CAAE;GACpB,IAAI,KAAK,MAAM,MAAM;EACtB;AACD,MACE,KAAK,qBAAqB,UAC1B,MAAM,qBAAqB,QAC3B;GACA,MAAM,eAAe,YACnB,KAAK,kBACL,MAAM,iBACP;AACD,OAAI,iBAAiB,UAAa,aAAa,SAAS,GACtD,eAAe,mBAAmB;EAErC;AACD,MACE,KAAK,mBAAmB,UACxB,MAAM,mBAAmB,QAEzB,eAAe,iBAAiB,mBAC9B,KAAK,gBACL,MAAM,eACP;EAEH,MAAM,MAAM,KAAK;AACjB,SAAO,IAAI,IAAI;CAChB;CAED,OAAO,WAAWT,KAAqC;AACrD,SAAO,MAAM,WAAW,IAAI,IAAI,IAAI,SAAS;CAC9C;AACF"}