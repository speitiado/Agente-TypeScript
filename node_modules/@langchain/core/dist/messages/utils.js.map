{"version":3,"file":"utils.js","names":["fn: () => T","toolCall: ToolCall | Record<string, unknown>","x: unknown","params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor","type: string","rest: BaseMessageFields & Record<string, unknown>","messageLike: BaseMessageLike","messages: BaseMessage[]","string_messages: string[]","role: string","message: StoredMessage | StoredMessageV1","message: StoredMessage","messages: StoredMessage[]","message: BaseMessage","aiChunkFields: AIMessageChunkFields"],"sources":["../../src/messages/utils.ts"],"sourcesContent":["import { addLangChainErrorFields } from \"../errors/index.js\";\nimport { SerializedConstructor } from \"../load/serializable.js\";\nimport { _isToolCall } from \"../tools/utils.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessageLike,\n  BaseMessage,\n  isBaseMessage,\n  StoredMessage,\n  StoredMessageV1,\n  BaseMessageFields,\n  _isMessageFieldWithRole,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageFields, ChatMessageChunk } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolCall, ToolMessage, ToolMessageFields } from \"./tool.js\";\n\nexport type $Expand<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\n/**\n * Extracts the explicitly declared keys from a type T.\n *\n * @template T - The type to extract keys from\n * @returns A union of keys that are not string, number, or symbol\n */\ntype $KnownKeys<T> = {\n  [K in keyof T]: string extends K\n    ? never\n    : number extends K\n    ? never\n    : symbol extends K\n    ? never\n    : K;\n}[keyof T];\n\n/**\n * Detects if T has an index signature.\n *\n * @template T - The type to check for index signatures\n * @returns True if T has an index signature, false otherwise\n */\ntype $HasIndexSignature<T> = string extends keyof T\n  ? true\n  : number extends keyof T\n  ? true\n  : symbol extends keyof T\n  ? true\n  : false;\n\n/**\n * Detects if T has an index signature and no known keys.\n *\n * @template T - The type to check for index signatures and no known keys\n * @returns True if T has an index signature and no known keys, false otherwise\n */\ntype $OnlyIndexSignatures<T> = $HasIndexSignature<T> extends true\n  ? [$KnownKeys<T>] extends [never]\n    ? true\n    : false\n  : false;\n\n/**\n * Recursively merges two object types T and U, with U taking precedence over T.\n *\n * This utility type performs a deep merge of two object types:\n * - For keys that exist in both T and U:\n *   - If both values are objects (Record<string, unknown>), recursively merge them\n *   - Otherwise, U's value takes precedence\n * - For keys that exist only in T, use T's value\n * - For keys that exist only in U, use U's value\n *\n * @template T - The first object type to merge\n * @template U - The second object type to merge (takes precedence over T)\n *\n * @example\n * ```ts\n * type ObjectA = {\n *   shared: { a: string; b: number };\n *   onlyInA: boolean;\n * };\n *\n * type ObjectB = {\n *   shared: { b: string; c: Date };\n *   onlyInB: symbol;\n * };\n *\n * type Merged = $MergeObjects<ObjectA, ObjectB>;\n * // Result: {\n * //   shared: { a: string; b: string; c: Date };\n * //   onlyInA: boolean;\n * //   onlyInB: symbol;\n * // }\n * ```\n */\nexport type $MergeObjects<T, U> =\n  // If U is purely index-signature based, prefer U as a whole\n  $OnlyIndexSignatures<U> extends true\n    ? U\n    : // If T is purely index-signature based, prefer U as a whole (prevents leaking broad index signatures)\n    $OnlyIndexSignatures<T> extends true\n    ? U\n    : {\n        [K in keyof T | keyof U]: K extends keyof T\n          ? K extends keyof U\n            ? T[K] extends Record<string, unknown>\n              ? U[K] extends Record<string, unknown>\n                ? $MergeObjects<T[K], U[K]>\n                : U[K]\n              : U[K]\n            : T[K]\n          : K extends keyof U\n          ? U[K]\n          : never;\n      };\n\n/**\n * Merges two discriminated unions A and B based on a discriminator key (defaults to \"type\").\n * For each possible value of the discriminator across both unions:\n * - If B has a member with that discriminator value, use B's member\n * - Otherwise use A's member with that discriminator value\n * This effectively merges the unions while giving B's members precedence over A's members.\n *\n * @template A - First discriminated union type that extends Record<Key, PropertyKey>\n * @template B - Second discriminated union type that extends Record<Key, PropertyKey>\n * @template Key - The discriminator key property, defaults to \"type\"\n */\nexport type $MergeDiscriminatedUnion<\n  A extends Record<Key, PropertyKey>,\n  B extends Record<Key, PropertyKey>,\n  Key extends PropertyKey = \"type\"\n> = {\n  // Create a mapped type over all possible discriminator values from both A and B\n  [T in A[Key] | B[Key]]: [Extract<B, Record<Key, T>>] extends [never] // Check if B has a member with this discriminator value\n    ? // If B doesn't have this discriminator value, use A's member\n      Extract<A, Record<Key, T>>\n    : // If B does have this discriminator value, merge A's and B's members (B takes precedence)\n    [Extract<A, Record<Key, T>>] extends [never]\n    ? Extract<B, Record<Key, T>>\n    : $MergeObjects<Extract<A, Record<Key, T>>, Extract<B, Record<Key, T>>>;\n  // Index into the mapped type with all possible discriminator values\n  // This converts the mapped type back into a union\n}[A[Key] | B[Key]];\n\nexport type Constructor<T> = new (...args: unknown[]) => T;\n\n/**\n * Immediately-invoked function expression.\n *\n * @param fn - The function to execute\n * @returns The result of the function\n */\nexport const iife = <T>(fn: () => T) => fn();\n\nfunction _coerceToolCall(\n  toolCall: ToolCall | Record<string, unknown>\n): ToolCall {\n  if (_isToolCall(toolCall)) {\n    return toolCall;\n  } else if (\n    typeof toolCall.id === \"string\" &&\n    toolCall.type === \"function\" &&\n    typeof toolCall.function === \"object\" &&\n    toolCall.function !== null &&\n    \"arguments\" in toolCall.function &&\n    typeof toolCall.function.arguments === \"string\" &&\n    \"name\" in toolCall.function &&\n    typeof toolCall.function.name === \"string\"\n  ) {\n    // Handle OpenAI tool call format\n    return {\n      id: toolCall.id,\n      args: JSON.parse(toolCall.function.arguments),\n      name: toolCall.function.name,\n      type: \"tool_call\",\n    };\n  } else {\n    // TODO: Throw an error?\n    return toolCall as unknown as ToolCall;\n  }\n}\n\nfunction isSerializedConstructor(x: unknown): x is SerializedConstructor {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    (x as SerializedConstructor).lc === 1 &&\n    Array.isArray((x as SerializedConstructor).id) &&\n    (x as SerializedConstructor).kwargs != null &&\n    typeof (x as SerializedConstructor).kwargs === \"object\"\n  );\n}\n\nfunction _constructMessageFromParams(\n  params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor\n) {\n  let type: string;\n  let rest: BaseMessageFields & Record<string, unknown>;\n  // Support serialized messages\n  if (isSerializedConstructor(params)) {\n    const className = params.id.at(-1);\n    if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n      type = \"user\";\n    } else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n      type = \"assistant\";\n    } else if (\n      className === \"SystemMessage\" ||\n      className === \"SystemMessageChunk\"\n    ) {\n      type = \"system\";\n    } else if (\n      className === \"FunctionMessage\" ||\n      className === \"FunctionMessageChunk\"\n    ) {\n      type = \"function\";\n    } else if (\n      className === \"ToolMessage\" ||\n      className === \"ToolMessageChunk\"\n    ) {\n      type = \"tool\";\n    } else {\n      type = \"unknown\";\n    }\n    rest = params.kwargs as BaseMessageFields;\n  } else {\n    const { type: extractedType, ...otherParams } = params;\n    type = extractedType;\n    rest = otherParams;\n  }\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage(rest);\n  } else if (type === \"ai\" || type === \"assistant\") {\n    const { tool_calls: rawToolCalls, ...other } = rest;\n    if (!Array.isArray(rawToolCalls)) {\n      return new AIMessage(rest);\n    }\n    const tool_calls = rawToolCalls.map(_coerceToolCall);\n    return new AIMessage({ ...other, tool_calls });\n  } else if (type === \"system\") {\n    return new SystemMessage(rest);\n  } else if (type === \"developer\") {\n    return new SystemMessage({\n      ...rest,\n      additional_kwargs: {\n        ...rest.additional_kwargs,\n        __openai_role__: \"developer\",\n      },\n    });\n  } else if (type === \"tool\" && \"tool_call_id\" in rest) {\n    return new ToolMessage({\n      ...rest,\n      content: rest.content,\n      tool_call_id: rest.tool_call_id as string,\n      name: rest.name,\n    });\n  } else if (type === \"remove\" && \"id\" in rest && typeof rest.id === \"string\") {\n    return new RemoveMessage({ ...rest, id: rest.id });\n  } else {\n    const error = addLangChainErrorFields(\n      new Error(\n        `Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(\n          params,\n          null,\n          2\n        )}`\n      ),\n      \"MESSAGE_COERCION_FAILURE\"\n    );\n    throw error;\n  }\n}\n\nexport function coerceMessageLikeToMessage(\n  messageLike: BaseMessageLike\n): BaseMessage {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  if (Array.isArray(messageLike)) {\n    const [type, content] = messageLike;\n    return _constructMessageFromParams({ type, content });\n  } else if (_isMessageFieldWithRole(messageLike)) {\n    const { role: type, ...rest } = messageLike;\n    return _constructMessageFromParams({ ...rest, type });\n  } else {\n    return _constructMessageFromParams(messageLike);\n  }\n}\n\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(\n  messages: BaseMessage[],\n  humanPrefix = \"Human\",\n  aiPrefix = \"AI\"\n): string {\n  const string_messages: string[] = [];\n  for (const m of messages) {\n    let role: string;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = (m as ChatMessage).role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m._getType()}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    const readableContent =\n      typeof m.content === \"string\"\n        ? m.content\n        : JSON.stringify(m.content, null, 2);\n    string_messages.push(`${role}: ${nameStr}${readableContent}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(\n  message: StoredMessage | StoredMessageV1\n): StoredMessage {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if ((message as StoredMessage).data !== undefined) {\n    return message as StoredMessage;\n  } else {\n    const v1Message = message as StoredMessageV1;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined,\n      },\n    };\n  }\n}\n\nexport function mapStoredMessageToChatMessage(message: StoredMessage) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data as FunctionMessageFields);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data as ToolMessageFields);\n    case \"generic\": {\n      if (storedMessage.data.role === undefined) {\n        throw new Error(\"Role must be defined for chat messages\");\n      }\n      return new ChatMessage(storedMessage.data as ChatMessageFields);\n    }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(\n  messages: StoredMessage[]\n): BaseMessage[] {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(\n  messages: BaseMessage[]\n): StoredMessage[] {\n  return messages.map((message) => message.toDict());\n}\n\nexport function convertToChunk(message: BaseMessage) {\n  const type = message._getType();\n  if (type === \"human\") {\n    return new HumanMessageChunk({ ...message });\n  } else if (type === \"ai\") {\n    let aiChunkFields: AIMessageChunkFields = {\n      ...message,\n    };\n    if (\"tool_calls\" in aiChunkFields) {\n      aiChunkFields = {\n        ...aiChunkFields,\n        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n          ...tc,\n          type: \"tool_call_chunk\",\n          index: undefined,\n          args: JSON.stringify(tc.args),\n        })),\n      };\n    }\n    return new AIMessageChunk({ ...aiChunkFields });\n  } else if (type === \"system\") {\n    return new SystemMessageChunk({ ...message });\n  } else if (type === \"function\") {\n    return new FunctionMessageChunk({ ...message });\n  } else if (ChatMessage.isInstance(message)) {\n    return new ChatMessageChunk({ ...message });\n  } else {\n    throw new Error(\"Unknown message type.\");\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AA8JA,MAAa,OAAO,CAAIA,OAAgB,IAAI;AAE5C,SAAS,gBACPC,UACU;AACV,KAAI,YAAY,SAAS,CACvB,QAAO;UAEP,OAAO,SAAS,OAAO,YACvB,SAAS,SAAS,cAClB,OAAO,SAAS,aAAa,YAC7B,SAAS,aAAa,QACtB,eAAe,SAAS,YACxB,OAAO,SAAS,SAAS,cAAc,YACvC,UAAU,SAAS,YACnB,OAAO,SAAS,SAAS,SAAS,SAGlC,QAAO;EACL,IAAI,SAAS;EACb,MAAM,KAAK,MAAM,SAAS,SAAS,UAAU;EAC7C,MAAM,SAAS,SAAS;EACxB,MAAM;CACP;KAGD,QAAO;AAEV;AAED,SAAS,wBAAwBC,GAAwC;AACvE,QACE,OAAO,MAAM,YACb,KAAK,QACJ,EAA4B,OAAO,KACpC,MAAM,QAAS,EAA4B,GAAG,IAC7C,EAA4B,UAAU,QACvC,OAAQ,EAA4B,WAAW;AAElD;AAED,SAAS,4BACPC,QAGA;CACA,IAAIC;CACJ,IAAIC;AAEJ,KAAI,wBAAwB,OAAO,EAAE;EACnC,MAAM,YAAY,OAAO,GAAG,GAAG,GAAG;AAClC,MAAI,cAAc,kBAAkB,cAAc,qBAChD,OAAO;WACE,cAAc,eAAe,cAAc,kBACpD,OAAO;WAEP,cAAc,mBACd,cAAc,sBAEd,OAAO;WAEP,cAAc,qBACd,cAAc,wBAEd,OAAO;WAEP,cAAc,iBACd,cAAc,oBAEd,OAAO;OAEP,OAAO;EAET,OAAO,OAAO;CACf,OAAM;EACL,MAAM,EAAE,MAAM,cAAe,GAAG,aAAa,GAAG;EAChD,OAAO;EACP,OAAO;CACR;AACD,KAAI,SAAS,WAAW,SAAS,OAC/B,QAAO,IAAI,aAAa;UACf,SAAS,QAAQ,SAAS,aAAa;EAChD,MAAM,EAAE,YAAY,aAAc,GAAG,OAAO,GAAG;AAC/C,MAAI,CAAC,MAAM,QAAQ,aAAa,CAC9B,QAAO,IAAI,UAAU;EAEvB,MAAM,aAAa,aAAa,IAAI,gBAAgB;AACpD,SAAO,IAAI,UAAU;GAAE,GAAG;GAAO;EAAY;CAC9C,WAAU,SAAS,SAClB,QAAO,IAAI,cAAc;UAChB,SAAS,YAClB,QAAO,IAAI,cAAc;EACvB,GAAG;EACH,mBAAmB;GACjB,GAAG,KAAK;GACR,iBAAiB;EAClB;CACF;UACQ,SAAS,UAAU,kBAAkB,KAC9C,QAAO,IAAI,YAAY;EACrB,GAAG;EACH,SAAS,KAAK;EACd,cAAc,KAAK;EACnB,MAAM,KAAK;CACZ;UACQ,SAAS,YAAY,QAAQ,QAAQ,OAAO,KAAK,OAAO,SACjE,QAAO,IAAI,cAAc;EAAE,GAAG;EAAM,IAAI,KAAK;CAAI;MAC5C;EACL,MAAM,QAAQ,wCACZ,IAAI,MACF,CAAC,sIAAsI,EAAE,KAAK,UAC5I,QACA,MACA,EACD,EAAE,GAEL,2BACD;AACD,QAAM;CACP;AACF;AAED,SAAgB,2BACdC,aACa;AACb,KAAI,OAAO,gBAAgB,SACzB,QAAO,IAAI,aAAa;UACf,cAAc,YAAY,CACnC,QAAO;AAET,KAAI,MAAM,QAAQ,YAAY,EAAE;EAC9B,MAAM,CAAC,MAAM,QAAQ,GAAG;AACxB,SAAO,4BAA4B;GAAE;GAAM;EAAS,EAAC;CACtD,WAAU,wBAAwB,YAAY,EAAE;EAC/C,MAAM,EAAE,MAAM,KAAM,GAAG,MAAM,GAAG;AAChC,SAAO,4BAA4B;GAAE,GAAG;GAAM;EAAM,EAAC;CACtD,MACC,QAAO,4BAA4B,YAAY;AAElD;;;;;AAMD,SAAgB,gBACdC,UACA,cAAc,SACd,WAAW,MACH;CACR,MAAMC,kBAA4B,CAAE;AACpC,MAAK,MAAM,KAAK,UAAU;EACxB,IAAIC;AACJ,MAAI,EAAE,UAAU,KAAK,SACnB,OAAO;WACE,EAAE,UAAU,KAAK,MAC1B,OAAO;WACE,EAAE,UAAU,KAAK,UAC1B,OAAO;WACE,EAAE,UAAU,KAAK,QAC1B,OAAO;WACE,EAAE,UAAU,KAAK,WAC1B,OAAQ,EAAkB;MAE1B,OAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,EAAE,UAAU,EAAE;EAEjE,MAAM,UAAU,EAAE,OAAO,GAAG,EAAE,KAAK,EAAE,CAAC,GAAG;EACzC,MAAM,kBACJ,OAAO,EAAE,YAAY,WACjB,EAAE,UACF,KAAK,UAAU,EAAE,SAAS,MAAM,EAAE;EACxC,gBAAgB,KAAK,GAAG,KAAK,EAAE,EAAE,UAAU,iBAAiB,CAAC;CAC9D;AACD,QAAO,gBAAgB,KAAK,KAAK;AAClC;;;;;;;;AASD,SAAS,4BACPC,SACe;AAEf,KAAK,QAA0B,SAAS,OACtC,QAAO;MACF;EACL,MAAM,YAAY;AAClB,SAAO;GACL,MAAM,UAAU;GAChB,MAAM;IACJ,SAAS,UAAU;IACnB,MAAM,UAAU;IAChB,MAAM;IACN,cAAc;GACf;EACF;CACF;AACF;AAED,SAAgB,8BAA8BC,SAAwB;CACpE,MAAM,gBAAgB,4BAA4B,QAAQ;AAC1D,SAAQ,cAAc,MAAtB;EACE,KAAK,QACH,QAAO,IAAI,aAAa,cAAc;EACxC,KAAK,KACH,QAAO,IAAI,UAAU,cAAc;EACrC,KAAK,SACH,QAAO,IAAI,cAAc,cAAc;EACzC,KAAK;AACH,OAAI,cAAc,KAAK,SAAS,OAC9B,OAAM,IAAI,MAAM;AAElB,UAAO,IAAI,gBAAgB,cAAc;EAC3C,KAAK;AACH,OAAI,cAAc,KAAK,iBAAiB,OACtC,OAAM,IAAI,MAAM;AAElB,UAAO,IAAI,YAAY,cAAc;EACvC,KAAK;AACH,OAAI,cAAc,KAAK,SAAS,OAC9B,OAAM,IAAI,MAAM;AAElB,UAAO,IAAI,YAAY,cAAc;EAEvC,QACE,OAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,cAAc,MAAM;CAC/D;AACF;;;;;;;;;AAUD,SAAgB,gCACdC,UACe;AACf,QAAO,SAAS,IAAI,8BAA8B;AACnD;;;;;;;AAQD,SAAgB,gCACdL,UACiB;AACjB,QAAO,SAAS,IAAI,CAAC,YAAY,QAAQ,QAAQ,CAAC;AACnD;AAED,SAAgB,eAAeM,SAAsB;CACnD,MAAM,OAAO,QAAQ,UAAU;AAC/B,KAAI,SAAS,QACX,QAAO,IAAI,kBAAkB,EAAE,GAAG,QAAS;UAClC,SAAS,MAAM;EACxB,IAAIC,gBAAsC,EACxC,GAAG,QACJ;AACD,MAAI,gBAAgB,eAClB,gBAAgB;GACd,GAAG;GACH,kBAAkB,cAAc,YAAY,IAAI,CAAC,QAAQ;IACvD,GAAG;IACH,MAAM;IACN,OAAO;IACP,MAAM,KAAK,UAAU,GAAG,KAAK;GAC9B,GAAE;EACJ;AAEH,SAAO,IAAI,eAAe,EAAE,GAAG,cAAe;CAC/C,WAAU,SAAS,SAClB,QAAO,IAAI,mBAAmB,EAAE,GAAG,QAAS;UACnC,SAAS,WAClB,QAAO,IAAI,qBAAqB,EAAE,GAAG,QAAS;UACrC,YAAY,WAAW,QAAQ,CACxC,QAAO,IAAI,iBAAiB,EAAE,GAAG,QAAS;KAE1C,OAAM,IAAI,MAAM;AAEnB"}