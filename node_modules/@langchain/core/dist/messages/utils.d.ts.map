{"version":3,"file":"utils.d.ts","names":["AIMessage","AIMessageChunk","BaseMessageLike","BaseMessage","StoredMessage","ChatMessage","ChatMessageChunk","FunctionMessage","FunctionMessageChunk","HumanMessage","HumanMessageChunk","SystemMessage","SystemMessageChunk","ToolMessage","$Expand","T","U","K","$KnownKeys","$HasIndexSignature","$OnlyIndexSignatures","$MergeObjects","Record","$MergeDiscriminatedUnion","Key","PropertyKey","A","B","Extract","Constructor","iife","coerceMessageLikeToMessage","getBufferString","mapStoredMessageToChatMessage","__message_js0","MessageStructure","mapStoredMessagesToChatMessages","mapChatMessagesToStoredMessages","convertToChunk"],"sources":["../../src/messages/utils.d.ts"],"sourcesContent":["import { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { BaseMessageLike, BaseMessage, StoredMessage } from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage } from \"./tool.js\";\nexport type $Expand<T> = T extends infer U ? {\n    [K in keyof U]: U[K];\n} : never;\n/**\n * Extracts the explicitly declared keys from a type T.\n *\n * @template T - The type to extract keys from\n * @returns A union of keys that are not string, number, or symbol\n */\ntype $KnownKeys<T> = {\n    [K in keyof T]: string extends K ? never : number extends K ? never : symbol extends K ? never : K;\n}[keyof T];\n/**\n * Detects if T has an index signature.\n *\n * @template T - The type to check for index signatures\n * @returns True if T has an index signature, false otherwise\n */\ntype $HasIndexSignature<T> = string extends keyof T ? true : number extends keyof T ? true : symbol extends keyof T ? true : false;\n/**\n * Detects if T has an index signature and no known keys.\n *\n * @template T - The type to check for index signatures and no known keys\n * @returns True if T has an index signature and no known keys, false otherwise\n */\ntype $OnlyIndexSignatures<T> = $HasIndexSignature<T> extends true ? [$KnownKeys<T>] extends [never] ? true : false : false;\n/**\n * Recursively merges two object types T and U, with U taking precedence over T.\n *\n * This utility type performs a deep merge of two object types:\n * - For keys that exist in both T and U:\n *   - If both values are objects (Record<string, unknown>), recursively merge them\n *   - Otherwise, U's value takes precedence\n * - For keys that exist only in T, use T's value\n * - For keys that exist only in U, use U's value\n *\n * @template T - The first object type to merge\n * @template U - The second object type to merge (takes precedence over T)\n *\n * @example\n * ```ts\n * type ObjectA = {\n *   shared: { a: string; b: number };\n *   onlyInA: boolean;\n * };\n *\n * type ObjectB = {\n *   shared: { b: string; c: Date };\n *   onlyInB: symbol;\n * };\n *\n * type Merged = $MergeObjects<ObjectA, ObjectB>;\n * // Result: {\n * //   shared: { a: string; b: string; c: Date };\n * //   onlyInA: boolean;\n * //   onlyInB: symbol;\n * // }\n * ```\n */\nexport type $MergeObjects<T, U> = \n// If U is purely index-signature based, prefer U as a whole\n$OnlyIndexSignatures<U> extends true ? U : $OnlyIndexSignatures<T> extends true ? U : {\n    [K in keyof T | keyof U]: K extends keyof T ? K extends keyof U ? T[K] extends Record<string, unknown> ? U[K] extends Record<string, unknown> ? $MergeObjects<T[K], U[K]> : U[K] : U[K] : T[K] : K extends keyof U ? U[K] : never;\n};\n/**\n * Merges two discriminated unions A and B based on a discriminator key (defaults to \"type\").\n * For each possible value of the discriminator across both unions:\n * - If B has a member with that discriminator value, use B's member\n * - Otherwise use A's member with that discriminator value\n * This effectively merges the unions while giving B's members precedence over A's members.\n *\n * @template A - First discriminated union type that extends Record<Key, PropertyKey>\n * @template B - Second discriminated union type that extends Record<Key, PropertyKey>\n * @template Key - The discriminator key property, defaults to \"type\"\n */\nexport type $MergeDiscriminatedUnion<A extends Record<Key, PropertyKey>, B extends Record<Key, PropertyKey>, Key extends PropertyKey = \"type\"> = {\n    [T in A[Key] | B[Key]]: [Extract<B, Record<Key, T>>] extends [never] // Check if B has a member with this discriminator value\n     ? Extract<A, Record<Key, T>> : [\n        Extract<A, Record<Key, T>>\n    ] extends [never] ? Extract<B, Record<Key, T>> : $MergeObjects<Extract<A, Record<Key, T>>, Extract<B, Record<Key, T>>>;\n}[A[Key] | B[Key]];\nexport type Constructor<T> = new (...args: unknown[]) => T;\n/**\n * Immediately-invoked function expression.\n *\n * @param fn - The function to execute\n * @returns The result of the function\n */\nexport declare const iife: <T>(fn: () => T) => T;\nexport declare function coerceMessageLikeToMessage(messageLike: BaseMessageLike): BaseMessage;\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport declare function getBufferString(messages: BaseMessage[], humanPrefix?: string, aiPrefix?: string): string;\nexport declare function mapStoredMessageToChatMessage(message: StoredMessage): AIMessage<import(\"./message.js\").MessageStructure> | ChatMessage<import(\"./message.js\").MessageStructure> | FunctionMessage<import(\"./message.js\").MessageStructure> | HumanMessage<import(\"./message.js\").MessageStructure> | SystemMessage<import(\"./message.js\").MessageStructure> | ToolMessage<import(\"./message.js\").MessageStructure>;\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport declare function mapStoredMessagesToChatMessages(messages: StoredMessage[]): BaseMessage[];\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport declare function mapChatMessagesToStoredMessages(messages: BaseMessage[]): StoredMessage[];\nexport declare function convertToChunk(message: BaseMessage): AIMessageChunk<import(\"./message.js\").MessageStructure> | ChatMessageChunk<import(\"./message.js\").MessageStructure> | FunctionMessageChunk<import(\"./message.js\").MessageStructure> | HumanMessageChunk<import(\"./message.js\").MessageStructure> | SystemMessageChunk<import(\"./message.js\").MessageStructure>;\nexport {};\n"],"mappings":"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"}