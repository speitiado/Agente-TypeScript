{"version":3,"file":"config.cjs","names":["config?: RunnableConfig","CallbackManager","copy: Partial<CallOptions>","baseKeys: string[]","ensureHandler","config?: CallOptions","AsyncLocalStorageProviderSingleton","empty: RunnableConfig","currentConfig: Record<string, any>","config: Partial<CallOptions>"],"sources":["../../src/runnables/config.ts"],"sourcesContent":["import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { RunnableConfig } from \"./types.js\";\n\nexport const DEFAULT_RECURSION_LIMIT = 25;\n\nexport { type RunnableConfig };\n\nexport async function getCallbackManagerForConfig(config?: RunnableConfig) {\n  return CallbackManager._configureSync(\n    config?.callbacks,\n    undefined,\n    config?.tags,\n    undefined,\n    config?.metadata\n  );\n}\n\nexport function mergeConfigs<CallOptions extends RunnableConfig>(\n  ...configs: (CallOptions | RunnableConfig | undefined | null)[]\n): Partial<CallOptions> {\n  // We do not want to call ensureConfig on the empty state here as this may cause\n  // double loading of callbacks if async local storage is being used.\n  const copy: Partial<CallOptions> = {};\n  for (const options of configs.filter((c): c is CallOptions => !!c)) {\n    for (const key of Object.keys(options)) {\n      if (key === \"metadata\") {\n        copy[key] = { ...copy[key], ...options[key] };\n      } else if (key === \"tags\") {\n        const baseKeys: string[] = copy[key] ?? [];\n        copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n      } else if (key === \"configurable\") {\n        copy[key] = { ...copy[key], ...options[key] };\n      } else if (key === \"timeout\") {\n        if (copy.timeout === undefined) {\n          copy.timeout = options.timeout;\n        } else if (options.timeout !== undefined) {\n          copy.timeout = Math.min(copy.timeout, options.timeout);\n        }\n      } else if (key === \"signal\") {\n        if (copy.signal === undefined) {\n          copy.signal = options.signal;\n        } else if (options.signal !== undefined) {\n          if (\"any\" in AbortSignal) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            copy.signal = (AbortSignal as any).any([\n              copy.signal,\n              options.signal,\n            ]);\n          } else {\n            copy.signal = options.signal;\n          }\n        }\n      } else if (key === \"callbacks\") {\n        const baseCallbacks = copy.callbacks;\n        const providedCallbacks = options.callbacks;\n        // callbacks can be either undefined, Array<handler> or manager\n        // so merging two callbacks values has 6 cases\n        if (Array.isArray(providedCallbacks)) {\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            copy.callbacks = baseCallbacks.concat(providedCallbacks);\n          } else {\n            // baseCallbacks is a manager\n            const manager = baseCallbacks.copy();\n            for (const callback of providedCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          }\n        } else if (providedCallbacks) {\n          // providedCallbacks is a manager\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            const manager = providedCallbacks.copy();\n            for (const callback of baseCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          } else {\n            // baseCallbacks is also a manager\n            copy.callbacks = new CallbackManager(\n              providedCallbacks._parentRunId,\n              {\n                handlers: baseCallbacks.handlers.concat(\n                  providedCallbacks.handlers\n                ),\n                inheritableHandlers: baseCallbacks.inheritableHandlers.concat(\n                  providedCallbacks.inheritableHandlers\n                ),\n                tags: Array.from(\n                  new Set(baseCallbacks.tags.concat(providedCallbacks.tags))\n                ),\n                inheritableTags: Array.from(\n                  new Set(\n                    baseCallbacks.inheritableTags.concat(\n                      providedCallbacks.inheritableTags\n                    )\n                  )\n                ),\n                metadata: {\n                  ...baseCallbacks.metadata,\n                  ...providedCallbacks.metadata,\n                },\n              }\n            );\n          }\n        }\n      } else {\n        const typedKey = key as keyof CallOptions;\n        copy[typedKey] = options[typedKey] ?? copy[typedKey];\n      }\n    }\n  }\n  return copy as Partial<CallOptions>;\n}\n\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig<CallOptions extends RunnableConfig>(\n  config?: CallOptions\n): CallOptions {\n  const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  let empty: RunnableConfig = {\n    tags: [],\n    metadata: {},\n    recursionLimit: 25,\n    runId: undefined,\n  };\n  if (implicitConfig) {\n    // Don't allow runId and runName to be loaded implicitly, as this can cause\n    // child runs to improperly inherit their parents' run ids.\n    const { runId, runName, ...rest } = implicitConfig;\n    empty = Object.entries(rest).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (currentConfig: Record<string, any>, [key, value]) => {\n        if (value !== undefined) {\n          currentConfig[key] = value;\n        }\n        return currentConfig;\n      },\n      empty\n    );\n  }\n  if (config) {\n    empty = Object.entries(config).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (currentConfig: Record<string, any>, [key, value]) => {\n        if (value !== undefined) {\n          currentConfig[key] = value;\n        }\n        return currentConfig;\n      },\n      empty\n    );\n  }\n  if (empty?.configurable) {\n    for (const key of Object.keys(empty.configurable)) {\n      if (\n        PRIMITIVES.has(typeof empty.configurable[key]) &&\n        !empty.metadata?.[key]\n      ) {\n        if (!empty.metadata) {\n          empty.metadata = {};\n        }\n        empty.metadata[key] = empty.configurable[key];\n      }\n    }\n  }\n  if (empty.timeout !== undefined) {\n    if (empty.timeout <= 0) {\n      throw new Error(\"Timeout must be a positive number\");\n    }\n    const timeoutSignal = AbortSignal.timeout(empty.timeout);\n    if (empty.signal !== undefined) {\n      if (\"any\" in AbortSignal) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        empty.signal = (AbortSignal as any).any([empty.signal, timeoutSignal]);\n      }\n    } else {\n      empty.signal = timeoutSignal;\n    }\n    delete empty.timeout;\n  }\n  return empty as CallOptions;\n}\n\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig<CallOptions extends RunnableConfig>(\n  config: Partial<CallOptions> = {},\n  {\n    callbacks,\n    maxConcurrency,\n    recursionLimit,\n    runName,\n    configurable,\n    runId,\n  }: RunnableConfig = {}\n): Partial<CallOptions> {\n  const newConfig = ensureConfig(config);\n  if (callbacks !== undefined) {\n    /**\n     * If we're replacing callbacks we need to unset runName\n     * since that should apply only to the same run as the original callbacks\n     */\n    delete newConfig.runName;\n    newConfig.callbacks = callbacks;\n  }\n  if (recursionLimit !== undefined) {\n    newConfig.recursionLimit = recursionLimit;\n  }\n  if (maxConcurrency !== undefined) {\n    newConfig.maxConcurrency = maxConcurrency;\n  }\n  if (runName !== undefined) {\n    newConfig.runName = runName;\n  }\n  if (configurable !== undefined) {\n    newConfig.configurable = { ...newConfig.configurable, ...configurable };\n  }\n  if (runId !== undefined) {\n    delete newConfig.runId;\n  }\n  return newConfig;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function pickRunnableConfigKeys<CallOptions extends Record<string, any>>(\n  config?: CallOptions\n): Partial<RunnableConfig> | undefined {\n  return config\n    ? {\n        configurable: config.configurable,\n        recursionLimit: config.recursionLimit,\n        callbacks: config.callbacks,\n        tags: config.tags,\n        metadata: config.metadata,\n        maxConcurrency: config.maxConcurrency,\n        timeout: config.timeout,\n        signal: config.signal,\n      }\n    : undefined;\n}\n"],"mappings":"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"}