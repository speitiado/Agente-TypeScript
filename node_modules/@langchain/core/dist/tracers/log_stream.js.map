{"version":3,"file":"log_stream.js","names":["fields: { ops?: JSONPatchOperation[] }","other: RunLogPatch","fields: { ops?: JSONPatchOperation[]; state: RunState }","patch: RunLogPatch","handler: BaseCallbackHandler","run: Run","schemaFormat: SchemaFormat","x?: ChatGenerationChunk | GenerationChunk","fields?: LogStreamCallbackHandlerInput","_run: Run","runId: string","output: AsyncGenerator<T>","logEntry: LogEntry","ops: JSONPatchOperation[]","token: string","kwargs?: HandleLLMNewTokenCallbackFields"],"sources":["../../src/tracers/log_stream.ts"],"sourcesContent":["import {\n  applyPatch,\n  type Operation as JSONPatchOperation,\n} from \"../utils/fast-json-patch/index.js\";\nimport { BaseTracer, type Run } from \"./base.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  CallbackHandlerPrefersStreaming,\n  HandleLLMNewTokenCallbackFields,\n} from \"../callbacks/base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ChatGenerationChunk, GenerationChunk } from \"../outputs.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport type { StreamEvent, StreamEventData } from \"./event_stream.js\";\n\nexport type { StreamEvent, StreamEventData };\n\n/**\n * Interface that represents the structure of a log entry in the\n * `LogStreamCallbackHandler`.\n */\nexport type LogEntry = {\n  /** ID of the sub-run. */\n  id: string;\n  /** Name of the object being run. */\n  name: string;\n  /** Type of the object being run, eg. prompt, chain, llm, etc. */\n  type: string;\n  /** List of tags for the run. */\n  tags: string[];\n  /** Key-value pairs of metadata for the run. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  /** ISO-8601 timestamp of when the run started. */\n  start_time: string;\n  /** List of general output chunks streamed by this run. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  streamed_output: any[];\n  /** List of LLM tokens streamed by this run, if applicable. */\n  streamed_output_str: string[];\n  /** Inputs to this run. Not available currently via streamLog. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  inputs?: any;\n  /** Final output of this run. Only available after the run has finished successfully. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  final_output?: any;\n  /** ISO-8601 timestamp of when the run ended. Only available after the run has finished. */\n  end_time?: string;\n};\n\nexport type RunState = {\n  /** ID of the sub-run. */\n  id: string;\n  /** List of output chunks streamed by Runnable.stream() */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  streamed_output: any[];\n  /** Final output of the run, usually the result of aggregating streamed_output. Only available after the run has finished successfully. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  final_output?: any;\n  /**\n   * List of sub-runs contained in this run, if any, in the order they were started.\n   * If filters were supplied, this list will contain only the runs that matched the filters.\n   */\n  logs: Record<string, LogEntry>;\n  /** Name of the object being run. */\n  name: string;\n  /** Type of the object being run, eg. prompt, chain, llm, etc. */\n  type: string;\n};\n\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nexport class RunLogPatch {\n  ops: JSONPatchOperation[];\n\n  constructor(fields: { ops?: JSONPatchOperation[] }) {\n    this.ops = fields.ops ?? [];\n  }\n\n  concat(other: RunLogPatch) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch({}, ops);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunLog({\n      ops,\n      state: states[states.length - 1].newDocument as RunState,\n    });\n  }\n}\n\nexport class RunLog extends RunLogPatch {\n  state: RunState;\n\n  constructor(fields: { ops?: JSONPatchOperation[]; state: RunState }) {\n    super(fields);\n    this.state = fields.state;\n  }\n\n  concat(other: RunLogPatch) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch(this.state, other.ops);\n    return new RunLog({ ops, state: states[states.length - 1].newDocument });\n  }\n\n  static fromRunLogPatch(patch: RunLogPatch) {\n    const states = applyPatch({}, patch.ops);\n    return new RunLog({\n      ops: patch.ops,\n      state: states[states.length - 1].newDocument as RunState,\n    });\n  }\n}\n\nexport type SchemaFormat = \"original\" | \"streaming_events\";\n\nexport interface LogStreamCallbackHandlerInput\n  extends BaseCallbackHandlerInput {\n  autoClose?: boolean;\n  includeNames?: string[];\n  includeTypes?: string[];\n  includeTags?: string[];\n  excludeNames?: string[];\n  excludeTypes?: string[];\n  excludeTags?: string[];\n  _schemaFormat?: SchemaFormat;\n}\n\nexport const isLogStreamHandler = (\n  handler: BaseCallbackHandler\n): handler is LogStreamCallbackHandler => handler.name === \"log_stream_tracer\";\n\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run: Run, schemaFormat: SchemaFormat) {\n  if (schemaFormat === \"original\") {\n    throw new Error(\n      \"Do not assign inputs with original schema drop the key for now. \" +\n        \"When inputs are added to streamLog they should be added with \" +\n        \"standardized schema for streaming events.\"\n    );\n  }\n\n  const { inputs } = run;\n\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return inputs;\n  }\n\n  if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n    return undefined;\n  }\n\n  // new style chains\n  // These nest an additional 'input' key inside the 'inputs' to make sure\n  // the input is always a dict. We need to unpack and user the inner value.\n  // We should try to fix this in Runnables and callbacks/tracers\n  // Runnables should be using a null type here not a placeholder\n  // dict.\n  return inputs.input;\n}\n\nasync function _getStandardizedOutputs(run: Run, schemaFormat: SchemaFormat) {\n  const { outputs } = run;\n  if (schemaFormat === \"original\") {\n    // Return the old schema, without standardizing anything\n    return outputs;\n  }\n\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return outputs;\n  }\n\n  // TODO: Remove this hacky check\n  if (\n    outputs !== undefined &&\n    Object.keys(outputs).length === 1 &&\n    outputs?.output !== undefined\n  ) {\n    return outputs.output;\n  }\n\n  return outputs;\n}\n\nfunction isChatGenerationChunk(\n  x?: ChatGenerationChunk | GenerationChunk\n): x is ChatGenerationChunk {\n  return x !== undefined && (x as ChatGenerationChunk).message !== undefined;\n}\n\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class LogStreamCallbackHandler\n  extends BaseTracer\n  implements CallbackHandlerPrefersStreaming\n{\n  protected autoClose = true;\n\n  protected includeNames?: string[];\n\n  protected includeTypes?: string[];\n\n  protected includeTags?: string[];\n\n  protected excludeNames?: string[];\n\n  protected excludeTypes?: string[];\n\n  protected excludeTags?: string[];\n\n  protected _schemaFormat: SchemaFormat = \"original\";\n\n  protected rootId?: string;\n\n  private keyMapByRunId: Record<string, string> = {};\n\n  private counterMapByRunName: Record<string, number> = {};\n\n  protected transformStream: TransformStream;\n\n  public writer: WritableStreamDefaultWriter;\n\n  public receiveStream: IterableReadableStream<RunLogPatch>;\n\n  name = \"log_stream_tracer\";\n\n  lc_prefer_streaming = true;\n\n  constructor(fields?: LogStreamCallbackHandlerInput) {\n    super({ _awaitHandler: true, ...fields });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(\n      this.transformStream.readable\n    );\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n\n  _includeRun(run: Run): boolean {\n    if (run.id === this.rootId) {\n      return false;\n    }\n    const runTags = run.tags ?? [];\n    let include =\n      this.includeNames === undefined &&\n      this.includeTags === undefined &&\n      this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.run_type);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include ||\n        runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.run_type);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n\n  async *tapOutputIterable<T>(\n    runId: string,\n    output: AsyncGenerator<T>\n  ): AsyncGenerator<T> {\n    // Tap an output async iterator to stream its values to the log.\n    for await (const chunk of output) {\n      // root run is handled in .streamLog()\n      if (runId !== this.rootId) {\n        // if we can't find the run silently ignore\n        // eg. because this run wasn't included in the log\n        const key = this.keyMapByRunId[runId];\n        if (key) {\n          await this.writer.write(\n            new RunLogPatch({\n              ops: [\n                {\n                  op: \"add\",\n                  path: `/logs/${key}/streamed_output/-`,\n                  value: chunk,\n                },\n              ],\n            })\n          );\n        }\n      }\n      yield chunk;\n    }\n  }\n\n  async onRunCreate(run: Run): Promise<void> {\n    if (this.rootId === undefined) {\n      this.rootId = run.id;\n      await this.writer.write(\n        new RunLogPatch({\n          ops: [\n            {\n              op: \"replace\",\n              path: \"\",\n              value: {\n                id: run.id,\n                name: run.name,\n                type: run.run_type,\n                streamed_output: [],\n                final_output: undefined,\n                logs: {},\n              },\n            },\n          ],\n        })\n      );\n    }\n\n    if (!this._includeRun(run)) {\n      return;\n    }\n\n    if (this.counterMapByRunName[run.name] === undefined) {\n      this.counterMapByRunName[run.name] = 0;\n    }\n    this.counterMapByRunName[run.name] += 1;\n    const count = this.counterMapByRunName[run.name];\n    this.keyMapByRunId[run.id] =\n      count === 1 ? run.name : `${run.name}:${count}`;\n\n    const logEntry: LogEntry = {\n      id: run.id,\n      name: run.name,\n      type: run.run_type,\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      start_time: new Date(run.start_time).toISOString(),\n      streamed_output: [],\n      streamed_output_str: [],\n      final_output: undefined,\n      end_time: undefined,\n    };\n\n    if (this._schemaFormat === \"streaming_events\") {\n      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n    }\n\n    await this.writer.write(\n      new RunLogPatch({\n        ops: [\n          {\n            op: \"add\",\n            path: `/logs/${this.keyMapByRunId[run.id]}`,\n            value: logEntry,\n          },\n        ],\n      })\n    );\n  }\n\n  async onRunUpdate(run: Run): Promise<void> {\n    try {\n      const runName = this.keyMapByRunId[run.id];\n      if (runName === undefined) {\n        return;\n      }\n      const ops: JSONPatchOperation[] = [];\n      if (this._schemaFormat === \"streaming_events\") {\n        ops.push({\n          op: \"replace\",\n          path: `/logs/${runName}/inputs`,\n          value: await _getStandardizedInputs(run, this._schemaFormat),\n        });\n      }\n      ops.push({\n        op: \"add\",\n        path: `/logs/${runName}/final_output`,\n        value: await _getStandardizedOutputs(run, this._schemaFormat),\n      });\n      if (run.end_time !== undefined) {\n        ops.push({\n          op: \"add\",\n          path: `/logs/${runName}/end_time`,\n          value: new Date(run.end_time).toISOString(),\n        });\n      }\n      const patch = new RunLogPatch({ ops });\n      await this.writer.write(patch);\n    } finally {\n      if (run.id === this.rootId) {\n        const patch = new RunLogPatch({\n          ops: [\n            {\n              op: \"replace\",\n              path: \"/final_output\",\n              value: await _getStandardizedOutputs(run, this._schemaFormat),\n            },\n          ],\n        });\n        await this.writer.write(patch);\n        if (this.autoClose) {\n          await this.writer.close();\n        }\n      }\n    }\n  }\n\n  async onLLMNewToken(\n    run: Run,\n    token: string,\n    kwargs?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    const runName = this.keyMapByRunId[run.id];\n    if (runName === undefined) {\n      return;\n    }\n    // TODO: Remove hack\n    const isChatModel = run.inputs.messages !== undefined;\n    let streamedOutputValue;\n    if (isChatModel) {\n      if (isChatGenerationChunk(kwargs?.chunk)) {\n        streamedOutputValue = kwargs?.chunk;\n      } else {\n        streamedOutputValue = new AIMessageChunk({\n          id: `run-${run.id}`,\n          content: token,\n        });\n      }\n    } else {\n      streamedOutputValue = token;\n    }\n    const patch = new RunLogPatch({\n      ops: [\n        {\n          op: \"add\",\n          path: `/logs/${runName}/streamed_output_str/-`,\n          value: token,\n        },\n        {\n          op: \"add\",\n          path: `/logs/${runName}/streamed_output/-`,\n          value: streamedOutputValue,\n        },\n      ],\n    });\n    await this.writer.write(patch);\n  }\n}\n"],"mappings":"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"}