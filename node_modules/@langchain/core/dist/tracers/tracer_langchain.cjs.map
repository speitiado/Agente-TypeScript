{"version":3,"file":"tracer_langchain.cjs","names":["BaseTracer","fields: LangChainTracerFields","getDefaultLangChainClientSingleton","_run: Run","run: Run","id: string","runTree: RunTree","rootRun: RunTree","RunTree"],"sources":["../../src/tracers/tracer_langchain.ts"],"sourcesContent":["import {\n  type Client,\n  type LangSmithTracingClientInterface,\n  getDefaultProjectName,\n} from \"langsmith\";\nimport { RunTree, type RunTreeConfig } from \"langsmith/run_trees\";\nimport { getCurrentRunTree } from \"langsmith/singletons/traceable\";\n\nimport {\n  BaseRun,\n  RunCreate,\n  RunUpdate as BaseRunUpdate,\n  KVMap,\n} from \"langsmith/schemas\";\nimport { BaseTracer } from \"./base.js\";\nimport { BaseCallbackHandlerInput } from \"../callbacks/base.js\";\nimport { getDefaultLangChainClientSingleton } from \"../singletons/tracer.js\";\n\nexport interface Run extends BaseRun {\n  id: string;\n  child_runs: this[];\n  child_execution_order: number;\n  dotted_order?: string;\n  trace_id?: string;\n}\n\nexport interface RunCreate2 extends RunCreate {\n  trace_id?: string;\n  dotted_order?: string;\n}\n\nexport interface RunUpdate extends BaseRunUpdate {\n  events: BaseRun[\"events\"];\n  inputs: KVMap;\n  trace_id?: string;\n  dotted_order?: string;\n}\n\nexport interface LangChainTracerFields extends BaseCallbackHandlerInput {\n  exampleId?: string;\n  projectName?: string;\n  client?: LangSmithTracingClientInterface;\n  replicas?: RunTreeConfig[\"replicas\"];\n}\n\nexport class LangChainTracer\n  extends BaseTracer\n  implements LangChainTracerFields\n{\n  name = \"langchain_tracer\";\n\n  projectName?: string;\n\n  exampleId?: string;\n\n  client: LangSmithTracingClientInterface;\n\n  replicas?: RunTreeConfig[\"replicas\"];\n\n  usesRunTreeMap = true;\n\n  constructor(fields: LangChainTracerFields = {}) {\n    super(fields);\n    const { exampleId, projectName, client, replicas } = fields;\n\n    this.projectName = projectName ?? getDefaultProjectName();\n    this.replicas = replicas;\n    this.exampleId = exampleId;\n    this.client = client ?? getDefaultLangChainClientSingleton();\n\n    const traceableTree = LangChainTracer.getTraceableRunTree();\n    if (traceableTree) {\n      this.updateFromRunTree(traceableTree);\n    }\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // empty\n  }\n\n  async onRunCreate(run: Run): Promise<void> {\n    const runTree = this.getRunTreeWithTracingConfig(run.id);\n    await runTree?.postRun();\n  }\n\n  async onRunUpdate(run: Run): Promise<void> {\n    const runTree = this.getRunTreeWithTracingConfig(run.id);\n    await runTree?.patchRun();\n  }\n\n  getRun(id: string): Run | undefined {\n    return this.runTreeMap.get(id);\n  }\n\n  updateFromRunTree(runTree: RunTree) {\n    this.runTreeMap.set(runTree.id, runTree);\n    let rootRun: RunTree = runTree;\n    const visited = new Set<string>();\n    while (rootRun.parent_run) {\n      if (visited.has(rootRun.id)) break;\n      visited.add(rootRun.id);\n\n      if (!rootRun.parent_run) break;\n      rootRun = rootRun.parent_run as RunTree;\n    }\n    visited.clear();\n\n    const queue = [rootRun];\n    while (queue.length > 0) {\n      const current = queue.shift();\n      if (!current || visited.has(current.id)) continue;\n      visited.add(current.id);\n\n      this.runTreeMap.set(current.id, current);\n      if (current.child_runs) {\n        queue.push(...current.child_runs);\n      }\n    }\n\n    this.client = runTree.client ?? this.client;\n    this.replicas = runTree.replicas ?? this.replicas;\n    this.projectName = runTree.project_name ?? this.projectName;\n    this.exampleId = runTree.reference_example_id ?? this.exampleId;\n  }\n\n  getRunTreeWithTracingConfig(id: string): RunTree | undefined {\n    const runTree = this.runTreeMap.get(id);\n    if (!runTree) return undefined;\n\n    return new RunTree({\n      ...runTree,\n      client: this.client as Client,\n      project_name: this.projectName,\n      replicas: this.replicas,\n      reference_example_id: this.exampleId,\n      tracingEnabled: true,\n    });\n  }\n\n  static getTraceableRunTree(): RunTree | undefined {\n    try {\n      return (\n        // The type cast here provides forward compatibility. Old versions of LangSmith will just\n        // ignore the permitAbsentRunTree arg.\n        (\n          getCurrentRunTree as (\n            permitAbsentRunTree: boolean\n          ) => ReturnType<typeof getCurrentRunTree> | undefined\n        )(true)\n      );\n    } catch {\n      return undefined;\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;AA6CA,IAAa,kBAAb,MAAa,wBACHA,gCAEV;CACE,OAAO;CAEP;CAEA;CAEA;CAEA;CAEA,iBAAiB;CAEjB,YAAYC,SAAgC,CAAE,GAAE;EAC9C,MAAM,OAAO;EACb,MAAM,EAAE,WAAW,aAAa,QAAQ,UAAU,GAAG;EAErD,KAAK,cAAc,qDAAsC;EACzD,KAAK,WAAW;EAChB,KAAK,YAAY;EACjB,KAAK,SAAS,UAAUC,mDAAoC;EAE5D,MAAM,gBAAgB,gBAAgB,qBAAqB;AAC3D,MAAI,eACF,KAAK,kBAAkB,cAAc;CAExC;CAED,MAAgB,WAAWC,MAA0B,CAEpD;CAED,MAAM,YAAYC,KAAyB;EACzC,MAAM,UAAU,KAAK,4BAA4B,IAAI,GAAG;EACxD,MAAM,SAAS,SAAS;CACzB;CAED,MAAM,YAAYA,KAAyB;EACzC,MAAM,UAAU,KAAK,4BAA4B,IAAI,GAAG;EACxD,MAAM,SAAS,UAAU;CAC1B;CAED,OAAOC,IAA6B;AAClC,SAAO,KAAK,WAAW,IAAI,GAAG;CAC/B;CAED,kBAAkBC,SAAkB;EAClC,KAAK,WAAW,IAAI,QAAQ,IAAI,QAAQ;EACxC,IAAIC,UAAmB;EACvB,MAAM,0BAAU,IAAI;AACpB,SAAO,QAAQ,YAAY;AACzB,OAAI,QAAQ,IAAI,QAAQ,GAAG,CAAE;GAC7B,QAAQ,IAAI,QAAQ,GAAG;AAEvB,OAAI,CAAC,QAAQ,WAAY;GACzB,UAAU,QAAQ;EACnB;EACD,QAAQ,OAAO;EAEf,MAAM,QAAQ,CAAC,OAAQ;AACvB,SAAO,MAAM,SAAS,GAAG;GACvB,MAAM,UAAU,MAAM,OAAO;AAC7B,OAAI,CAAC,WAAW,QAAQ,IAAI,QAAQ,GAAG,CAAE;GACzC,QAAQ,IAAI,QAAQ,GAAG;GAEvB,KAAK,WAAW,IAAI,QAAQ,IAAI,QAAQ;AACxC,OAAI,QAAQ,YACV,MAAM,KAAK,GAAG,QAAQ,WAAW;EAEpC;EAED,KAAK,SAAS,QAAQ,UAAU,KAAK;EACrC,KAAK,WAAW,QAAQ,YAAY,KAAK;EACzC,KAAK,cAAc,QAAQ,gBAAgB,KAAK;EAChD,KAAK,YAAY,QAAQ,wBAAwB,KAAK;CACvD;CAED,4BAA4BF,IAAiC;EAC3D,MAAM,UAAU,KAAK,WAAW,IAAI,GAAG;AACvC,MAAI,CAAC,QAAS,QAAO;AAErB,SAAO,IAAIG,4BAAQ;GACjB,GAAG;GACH,QAAQ,KAAK;GACb,cAAc,KAAK;GACnB,UAAU,KAAK;GACf,sBAAsB,KAAK;GAC3B,gBAAgB;EACjB;CACF;CAED,OAAO,sBAA2C;AAChD,MAAI;AACF,gEAOI,KAAK;EAEV,QAAO;AACN,UAAO;EACR;CACF;AACF"}