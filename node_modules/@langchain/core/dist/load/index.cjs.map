{"version":3,"file":"index.cjs","names":["constructor: typeof Serializable","aliases: { [key: string]: string }","value: unknown","getEnvironmentVariable","coreImportMap","module:\n      | (typeof importMaps)[\"langchain_core\"][keyof (typeof importMaps)[\"langchain_core\"]]\n      | (typeof importMaps)[\"langchain\"][keyof (typeof importMaps)[\"langchain\"]]\n      | OptionalImportMap[keyof OptionalImportMap]\n      | null","defaultOptionalImportEntrypoints","optionalImportEntrypoints","module","finalImportMap:\n        | (typeof importMaps)[\"langchain\"]\n        | (typeof importMaps)[\"langchain_core\"]","importMapKey: string","get_lc_unique_name","mapKeys","keyFromJson","value","text: string","mappings?: {\n    secretsMap?: SecretMap;\n    optionalImportsMap?: OptionalImportMap;\n    optionalImportEntrypoints?: string[];\n    importMap?: Record<string, unknown>;\n  }"],"sources":["../../src/load/index.ts"],"sourcesContent":["import {\n  Serializable,\n  SerializedConstructor,\n  SerializedNotImplemented,\n  SerializedSecret,\n  get_lc_unique_name,\n} from \"./serializable.js\";\nimport { optionalImportEntrypoints as defaultOptionalImportEntrypoints } from \"./import_constants.js\";\nimport * as coreImportMap from \"./import_map.js\";\nimport type { OptionalImportMap, SecretMap } from \"./import_type.js\";\nimport { type SerializedFields, keyFromJson, mapKeys } from \"./map_keys.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\nfunction combineAliasesAndInvert(constructor: typeof Serializable) {\n  const aliases: { [key: string]: string } = {};\n  for (\n    let current = constructor;\n    current && current.prototype;\n    current = Object.getPrototypeOf(current)\n  ) {\n    Object.assign(aliases, Reflect.get(current.prototype, \"lc_aliases\"));\n  }\n  return Object.entries(aliases).reduce((acc, [key, value]) => {\n    acc[value] = key;\n    return acc;\n  }, {} as Record<string, string>);\n}\n\nasync function reviver(\n  this: {\n    optionalImportsMap?: OptionalImportMap;\n    optionalImportEntrypoints?: string[];\n    secretsMap?: SecretMap;\n    importMap?: Record<string, unknown>;\n    path?: string[];\n  },\n  value: unknown\n): Promise<unknown> {\n  const {\n    optionalImportsMap = {},\n    optionalImportEntrypoints = [],\n    importMap = {},\n    secretsMap = {},\n    path = [\"$\"],\n  } = this;\n  const pathStr = path.join(\".\");\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    \"lc\" in value &&\n    \"type\" in value &&\n    \"id\" in value &&\n    value.lc === 1 &&\n    value.type === \"secret\"\n  ) {\n    const serialized = value as SerializedSecret;\n    const [key] = serialized.id;\n    if (key in secretsMap) {\n      return secretsMap[key as keyof SecretMap];\n    } else {\n      const secretValueInEnv = getEnvironmentVariable(key);\n      if (secretValueInEnv) {\n        return secretValueInEnv;\n      } else {\n        throw new Error(\n          `Missing key \"${key}\" for ${pathStr} in load(secretsMap={})`\n        );\n      }\n    }\n  } else if (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    \"lc\" in value &&\n    \"type\" in value &&\n    \"id\" in value &&\n    value.lc === 1 &&\n    value.type === \"not_implemented\"\n  ) {\n    const serialized = value as SerializedNotImplemented;\n    const str = JSON.stringify(serialized);\n    throw new Error(\n      `Trying to load an object that doesn't implement serialization: ${pathStr} -> ${str}`\n    );\n  } else if (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    \"lc\" in value &&\n    \"type\" in value &&\n    \"id\" in value &&\n    \"kwargs\" in value &&\n    value.lc === 1\n  ) {\n    const serialized = value as SerializedConstructor;\n    const str = JSON.stringify(serialized);\n    const [name, ...namespaceReverse] = serialized.id.slice().reverse();\n    const namespace = namespaceReverse.reverse();\n    const importMaps = { langchain_core: coreImportMap, langchain: importMap };\n\n    let module:\n      | (typeof importMaps)[\"langchain_core\"][keyof (typeof importMaps)[\"langchain_core\"]]\n      | (typeof importMaps)[\"langchain\"][keyof (typeof importMaps)[\"langchain\"]]\n      | OptionalImportMap[keyof OptionalImportMap]\n      | null = null;\n\n    const optionalImportNamespaceAliases = [namespace.join(\"/\")];\n    if (namespace[0] === \"langchain_community\") {\n      optionalImportNamespaceAliases.push(\n        [\"langchain\", ...namespace.slice(1)].join(\"/\")\n      );\n    }\n    const matchingNamespaceAlias = optionalImportNamespaceAliases.find(\n      (alias) => alias in optionalImportsMap\n    );\n    if (\n      defaultOptionalImportEntrypoints\n        .concat(optionalImportEntrypoints)\n        .includes(namespace.join(\"/\")) ||\n      matchingNamespaceAlias\n    ) {\n      if (matchingNamespaceAlias !== undefined) {\n        module = await optionalImportsMap[\n          matchingNamespaceAlias as keyof typeof optionalImportsMap\n        ];\n      } else {\n        throw new Error(\n          `Missing key \"${namespace.join(\n            \"/\"\n          )}\" for ${pathStr} in load(optionalImportsMap={})`\n        );\n      }\n    } else {\n      let finalImportMap:\n        | (typeof importMaps)[\"langchain\"]\n        | (typeof importMaps)[\"langchain_core\"];\n      // Currently, we only support langchain and langchain_core imports.\n      if (namespace[0] === \"langchain\" || namespace[0] === \"langchain_core\") {\n        finalImportMap = importMaps[namespace[0]];\n        namespace.shift();\n      } else {\n        throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n      }\n\n      // The root namespace \"langchain\" is not a valid import.\n      if (namespace.length === 0) {\n        throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n      }\n\n      // Find the longest matching namespace.\n      let importMapKey: string;\n      do {\n        importMapKey = namespace.join(\"__\");\n        if (importMapKey in finalImportMap) {\n          break;\n        } else {\n          namespace.pop();\n        }\n      } while (namespace.length > 0);\n\n      // If no matching namespace is found, throw an error.\n      if (importMapKey in finalImportMap) {\n        module = finalImportMap[importMapKey as keyof typeof finalImportMap];\n      }\n    }\n\n    if (typeof module !== \"object\" || module === null) {\n      throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n    }\n\n    // Extract the builder from the import map.\n    const builder =\n      // look for a named export with the same name as the class\n      module[name as keyof typeof module] ??\n      // look for an export with a lc_name property matching the class name\n      // this is necessary for classes that are minified\n      Object.values(module).find(\n        (v) =>\n          typeof v === \"function\" &&\n          get_lc_unique_name(v as typeof Serializable) === name\n      );\n    if (typeof builder !== \"function\") {\n      throw new Error(`Invalid identifer: ${pathStr} -> ${str}`);\n    }\n\n    // Recurse on the arguments, which may be serialized objects themselves\n    const kwargs = await reviver.call(\n      { ...this, path: [...path, \"kwargs\"] },\n      serialized.kwargs\n    );\n\n    // Construct the object\n    if (serialized.type === \"constructor\") {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const instance = new (builder as any)(\n        mapKeys(\n          kwargs as SerializedFields,\n          keyFromJson,\n          combineAliasesAndInvert(builder)\n        )\n      );\n\n      // Minification in severless/edge runtimes will mange the\n      // name of classes presented in traces. As the names in import map\n      // are present as-is even with minification, use these names instead\n      Object.defineProperty(instance.constructor, \"name\", { value: name });\n\n      return instance;\n    } else {\n      throw new Error(`Invalid type: ${pathStr} -> ${str}`);\n    }\n  } else if (typeof value === \"object\" && value !== null) {\n    if (Array.isArray(value)) {\n      return Promise.all(\n        value.map((v, i) =>\n          reviver.call({ ...this, path: [...path, `${i}`] }, v)\n        )\n      );\n    } else {\n      return Object.fromEntries(\n        await Promise.all(\n          Object.entries(value).map(async ([key, value]) => [\n            key,\n            await reviver.call({ ...this, path: [...path, key] }, value),\n          ])\n        )\n      );\n    }\n  }\n  return value;\n}\n\nexport async function load<T>(\n  text: string,\n  mappings?: {\n    secretsMap?: SecretMap;\n    optionalImportsMap?: OptionalImportMap;\n    optionalImportEntrypoints?: string[];\n    importMap?: Record<string, unknown>;\n  }\n): Promise<T> {\n  const json = JSON.parse(text);\n  return reviver.call({ ...mappings }, json) as Promise<T>;\n}\n"],"mappings":"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"}