{"version":3,"file":"event_source_parse.d.cts","names":["IterableReadableStream","EventStreamContentType","EventSourceMessage","getBytes","Uint8Array","ReadableStream","AsyncIterable","Promise","getLines","ArrayBufferLike","getMessages","convertEventStreamToIterableReadableDataStream"],"sources":["../../src/utils/event_source_parse.d.ts"],"sourcesContent":["/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nimport { IterableReadableStream } from \"./stream.js\";\nexport declare const EventStreamContentType = \"text/event-stream\";\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n    /** The event ID to set the EventSource object's last event ID value. */\n    id: string;\n    /** A string identifying the type of event described. */\n    event: string;\n    /** The event data */\n    data: string;\n    /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n    retry?: number;\n}\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport declare function getBytes(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nstream: ReadableStream<Uint8Array> | AsyncIterable<any>, onChunk: (arr: Uint8Array, flush?: boolean) => void): Promise<void>;\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport declare function getLines(onLine: (line: Uint8Array, fieldLength: number, flush?: boolean) => void): (arr: Uint8Array<ArrayBufferLike>, flush?: boolean | undefined) => void;\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport declare function getMessages(onMessage?: (msg: EventSourceMessage) => void, onId?: (id: string) => void, onRetry?: (retry: number) => void): (line: Uint8Array<ArrayBufferLike>, fieldLength: number, flush?: boolean | undefined) => void;\nexport declare function convertEventStreamToIterableReadableDataStream(stream: ReadableStream, onMetadataEvent?: (e: unknown) => unknown): IterableReadableStream<any>;\n"],"mappings":";;;;AA2BgC,cArBXC,sBAAAA,GAqBW,mBAAA;;;;;AAE+EM,UAlB9FL,kBAAAA,CAkB8FK;EAAO;EAO9FC,EAAAA,EAAAA,MAAAA;EAAQ;EAAA,KAAgBJ,EAAAA,MAAAA;EAAU;EAAkF,IAA1BA,EAAAA,MAAAA;EAAU;EAQpGM,KAAAA,CAAAA,EAAAA,MAAW;;;;;AAAkI;AACrK;;AAA+EL,iBAlBvDF,QAAAA;;AAkByI,MAAA,EAhBzJE,cAgByJ,CAhB1ID,UAgB0I,CAAA,GAhB5HE,aAgB4H,CAAA,GAAA,CAAA,EAAA,OAAA,EAAA,CAAA,GAAA,EAhBzFF,UAgByF,EAAA,KAAA,CAAA,EAAA,OAAA,EAAA,GAAA,IAAA,CAAA,EAhBlDG,OAgBkD,CAAA,IAAA,CAAA;;;;;;;iBATzIC,QAAAA,gBAAwBJ,kEAAkEA,WAAWK;;;;;;;;iBAQrGC,WAAAA,mBAA8BR,qGAAqGE,WAAWK;iBAC9IE,8CAAAA,SAAuDN,4DAA4DL"}