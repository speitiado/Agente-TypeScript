{"version":3,"file":"math.d.cts","names":["VectorFunction","matrixFunc","normalize","cosineSimilarity","innerProduct","euclideanDistance","maximalMarginalRelevance"],"sources":["../../src/utils/math.d.ts"],"sourcesContent":["type VectorFunction = (xVector: number[], yVector: number[]) => number;\n/**\n * Apply a row-wise function between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n * @param {VectorFunction} func - The function to apply.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the result of applying the function between the corresponding rows of X and Y.\n */\nexport declare function matrixFunc(X: number[][], Y: number[][], func: VectorFunction): number[][];\nexport declare function normalize(M: number[][], similarity?: boolean): number[][];\n/**\n * This function calculates the row-wise cosine similarity between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the cosine similarity values between the corresponding rows of X and Y.\n */\nexport declare function cosineSimilarity(X: number[][], Y: number[][]): number[][];\nexport declare function innerProduct(X: number[][], Y: number[][]): number[][];\nexport declare function euclideanDistance(X: number[][], Y: number[][]): number[][];\n/**\n * This function implements the Maximal Marginal Relevance algorithm\n * to select a set of embeddings that maximizes the diversity and relevance to a query embedding.\n *\n * @param {number[]|number[][]} queryEmbedding - The query embedding.\n * @param {number[][]} embeddingList - The list of embeddings to select from.\n * @param {number} [lambda=0.5] - The trade-off parameter between relevance and diversity.\n * @param {number} [k=4] - The maximum number of embeddings to select.\n *\n * @returns {number[]} The indexes of the selected embeddings in the embeddingList.\n */\nexport declare function maximalMarginalRelevance(queryEmbedding: number[] | number[][], embeddingList: number[][], lambda?: number, k?: number): number[];\nexport {};\n"],"mappings":";KAAKA,cAAAA;;AAYL;AACA;AAWA;AACA;AACA;AAYA;;;;;iBA1BwBC,UAAAA,qCAA+CD;iBAC/CE,SAAAA;;;;;;;;;;;iBAWAC,gBAAAA;iBACAC,YAAAA;iBACAC,iBAAAA;;;;;;;;;;;;iBAYAC,wBAAAA"}