{"version":3,"file":"json_schema.cjs","names":["schema: InteropZodType | JSONSchema","isZodSchemaV4","interopZodTransformInputSchema","isZodObjectV4","interopZodObjectStrict","isZodSchemaV3","zodToJsonSchema","schema: unknown"],"sources":["../../src/utils/json_schema.ts"],"sourcesContent":["import { toJSONSchema } from \"zod/v4/core\";\nimport { dereference, type Schema } from \"@cfworker/json-schema\";\nimport {\n  isZodSchemaV3,\n  isZodSchemaV4,\n  InteropZodType,\n  interopZodObjectStrict,\n  isZodObjectV4,\n  ZodObjectV4,\n  interopZodTransformInputSchema,\n} from \"./types/zod.js\";\nimport {\n  type JsonSchema7Type as JSONSchema,\n  zodToJsonSchema,\n} from \"./zod-to-json-schema/index.js\";\n\nexport { deepCompareStrict, Validator } from \"@cfworker/json-schema\";\n\n/**\n * Converts a Zod schema or JSON schema to a JSON schema.\n * @param schema - The schema to convert.\n * @returns The converted schema.\n */\nexport function toJsonSchema(schema: InteropZodType | JSONSchema): JSONSchema {\n  if (isZodSchemaV4(schema)) {\n    const inputSchema = interopZodTransformInputSchema(schema, true);\n    if (isZodObjectV4(inputSchema)) {\n      const strictSchema = interopZodObjectStrict(\n        inputSchema,\n        true\n      ) as ZodObjectV4;\n      return toJSONSchema(strictSchema);\n    } else {\n      return toJSONSchema(schema);\n    }\n  }\n  if (isZodSchemaV3(schema)) {\n    return zodToJsonSchema(schema);\n  }\n  return schema as JSONSchema;\n}\n\n/**\n * Validates if a JSON schema validates only strings. May return false negatives in some edge cases\n * (like recursive or unresolvable refs).\n *\n * @param schema - The schema to validate.\n * @returns `true` if the schema validates only strings, `false` otherwise.\n */\nexport function validatesOnlyStrings(schema: unknown): boolean {\n  // Null, undefined, or empty schema\n  if (\n    !schema ||\n    typeof schema !== \"object\" ||\n    Object.keys(schema).length === 0 ||\n    Array.isArray(schema)\n  ) {\n    return false; // Validates anything, not just strings\n  }\n\n  // Explicit type constraint\n  if (\"type\" in schema) {\n    if (typeof schema.type === \"string\") {\n      return schema.type === \"string\";\n    }\n\n    if (Array.isArray(schema.type)) {\n      // not sure why someone would do `\"type\": [\"string\"]` or especially `\"type\": [\"string\",\n      // \"string\", \"string\", ...]` but we're not here to judge\n      return schema.type.every((t) => t === \"string\");\n    }\n    return false; // Invalid or non-string type\n  }\n\n  // Enum with only string values\n  if (\"enum\" in schema) {\n    return (\n      Array.isArray(schema.enum) &&\n      schema.enum.length > 0 &&\n      schema.enum.every((val) => typeof val === \"string\")\n    );\n  }\n\n  // String constant\n  if (\"const\" in schema) {\n    return typeof schema.const === \"string\";\n  }\n\n  // Schema combinations\n  if (\"allOf\" in schema && Array.isArray(schema.allOf)) {\n    // If any subschema validates only strings, then the overall schema validates only strings\n    return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));\n  }\n\n  if (\n    (\"anyOf\" in schema && Array.isArray(schema.anyOf)) ||\n    (\"oneOf\" in schema && Array.isArray(schema.oneOf))\n  ) {\n    const subschemas = (\n      \"anyOf\" in schema ? schema.anyOf : schema.oneOf\n    ) as unknown[];\n\n    // All subschemas must validate only strings\n    return (\n      subschemas.length > 0 &&\n      subschemas.every((subschema) => validatesOnlyStrings(subschema))\n    );\n  }\n\n  // We're not going to try on this one, it's too complex - we just assume if it has a \"not\" key and hasn't matched one of the above checks, it's not a string schema.\n  if (\"not\" in schema) {\n    return false; // The not case can validate non-strings\n  }\n\n  if (\"$ref\" in schema && typeof schema.$ref === \"string\") {\n    const ref = schema.$ref as string;\n    const resolved = dereference(schema as Schema);\n    if (resolved[ref]) {\n      return validatesOnlyStrings(resolved[ref]);\n    }\n    return false;\n  }\n\n  // ignore recursive refs and other cases where type is omitted for now\n  // ignore other cases for now where type is omitted\n\n  return false;\n}\n\n// Re-export of the types used throughout langchain for json schema serialization.\n// The plan is to eventually nix zod-to-json-schema altogether in place for\n// zod v4 / a more standardized way of serializing validated inputs, so its re-exported\n// here to remove the dependency on zod-to-json-schema in downstream packages until\n// a determination is made.\n\nexport {\n  type JsonSchema7Type,\n  type JsonSchema7Type as JSONSchema,\n  type JsonSchema7ArrayType,\n  type JsonSchema7ObjectType,\n  type JsonSchema7StringType,\n  type JsonSchema7NumberType,\n  type JsonSchema7NullableType,\n} from \"./zod-to-json-schema/index.js\";\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAuBA,SAAgB,aAAaA,QAAiD;AAC5E,KAAIC,0BAAc,OAAO,EAAE;EACzB,MAAM,cAAcC,2CAA+B,QAAQ,KAAK;AAChE,MAAIC,0BAAc,YAAY,EAAE;GAC9B,MAAM,eAAeC,mCACnB,aACA,KACD;AACD,wCAAoB,aAAa;EAClC,MACC,sCAAoB,OAAO;CAE9B;AACD,KAAIC,0BAAc,OAAO,CACvB,QAAOC,wCAAgB,OAAO;AAEhC,QAAO;AACR;;;;;;;;AASD,SAAgB,qBAAqBC,QAA0B;AAE7D,KACE,CAAC,UACD,OAAO,WAAW,YAClB,OAAO,KAAK,OAAO,CAAC,WAAW,KAC/B,MAAM,QAAQ,OAAO,CAErB,QAAO;AAIT,KAAI,UAAU,QAAQ;AACpB,MAAI,OAAO,OAAO,SAAS,SACzB,QAAO,OAAO,SAAS;AAGzB,MAAI,MAAM,QAAQ,OAAO,KAAK,CAG5B,QAAO,OAAO,KAAK,MAAM,CAAC,MAAM,MAAM,SAAS;AAEjD,SAAO;CACR;AAGD,KAAI,UAAU,OACZ,QACE,MAAM,QAAQ,OAAO,KAAK,IAC1B,OAAO,KAAK,SAAS,KACrB,OAAO,KAAK,MAAM,CAAC,QAAQ,OAAO,QAAQ,SAAS;AAKvD,KAAI,WAAW,OACb,QAAO,OAAO,OAAO,UAAU;AAIjC,KAAI,WAAW,UAAU,MAAM,QAAQ,OAAO,MAAM,CAElD,QAAO,OAAO,MAAM,KAAK,CAAC,cAAc,qBAAqB,UAAU,CAAC;AAG1E,KACG,WAAW,UAAU,MAAM,QAAQ,OAAO,MAAM,IAChD,WAAW,UAAU,MAAM,QAAQ,OAAO,MAAM,EACjD;EACA,MAAM,aACJ,WAAW,SAAS,OAAO,QAAQ,OAAO;AAI5C,SACE,WAAW,SAAS,KACpB,WAAW,MAAM,CAAC,cAAc,qBAAqB,UAAU,CAAC;CAEnE;AAGD,KAAI,SAAS,OACX,QAAO;AAGT,KAAI,UAAU,UAAU,OAAO,OAAO,SAAS,UAAU;EACvD,MAAM,MAAM,OAAO;EACnB,MAAM,mDAAuB,OAAiB;AAC9C,MAAI,SAAS,KACX,QAAO,qBAAqB,SAAS,KAAK;AAE5C,SAAO;CACR;AAKD,QAAO;AACR"}