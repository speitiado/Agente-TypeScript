{"version":3,"file":"duplex.js","names":["tree1: Object | Array<any>","tree2: Object | Array<any>"],"sources":["../../../../src/utils/fast-json-patch/src/duplex.ts"],"sourcesContent":["// @ts-nocheck\n\n// Inlined because of ESM import issues\n\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\nimport {\n  _deepClone,\n  _objectKeys,\n  escapePathComponent,\n  hasOwnProperty,\n} from \"./helpers.js\";\nimport { applyPatch, Operation } from \"./core.js\";\n\nexport interface Observer<T> {\n  object: T;\n  patches: Operation[];\n  unobserve: () => void;\n  callback: (patches: Operation[]) => void;\n}\n\nvar beforeDict = new WeakMap();\n\nclass Mirror {\n  obj: any;\n  observers: Map<Function, ObserverInfo> = new Map();\n  value: Object | Array<any>;\n\n  constructor(obj: Object) {\n    this.obj = obj;\n  }\n}\n\nclass ObserverInfo {\n  callback: Function;\n  observer: ObserverInfo;\n\n  constructor(callback: Function, observer: ObserverInfo) {\n    this.callback = callback;\n    this.observer = observer;\n  }\n}\n\nfunction getMirror(obj: Object): Mirror {\n  return beforeDict.get(obj);\n}\n\nfunction getObserverFromMirror(mirror: Mirror, callback): ObserverInfo {\n  return mirror.observers.get(callback);\n}\n\nfunction removeObserverFromMirror(mirror: Mirror, observer): void {\n  mirror.observers.delete(observer.callback);\n}\n\n/**\n * Detach an observer from an object\n */\nexport function unobserve<T>(root: T, observer: Observer<T>) {\n  observer.unobserve();\n}\n\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nexport function observe<T>(\n  obj: Object | Array<T>,\n  callback?: (patches: Operation[]) => void\n): Observer<T> {\n  var patches = [];\n  var observer;\n  var mirror = getMirror(obj);\n\n  if (!mirror) {\n    mirror = new Mirror(obj);\n    beforeDict.set(obj, mirror);\n  } else {\n    const observerInfo = getObserverFromMirror(mirror, callback);\n    observer = observerInfo && observerInfo.observer;\n  }\n\n  if (observer) {\n    return observer;\n  }\n\n  observer = {};\n\n  mirror.value = _deepClone(obj);\n\n  if (callback) {\n    observer.callback = callback;\n    observer.next = null;\n\n    var dirtyCheck = () => {\n      generate(observer);\n    };\n    var fastCheck = () => {\n      clearTimeout(observer.next);\n      observer.next = setTimeout(dirtyCheck);\n    };\n    if (typeof window !== \"undefined\") {\n      //not Node\n      window.addEventListener(\"mouseup\", fastCheck);\n      window.addEventListener(\"keyup\", fastCheck);\n      window.addEventListener(\"mousedown\", fastCheck);\n      window.addEventListener(\"keydown\", fastCheck);\n      window.addEventListener(\"change\", fastCheck);\n    }\n  }\n  observer.patches = patches;\n  observer.object = obj;\n\n  observer.unobserve = () => {\n    generate(observer);\n    clearTimeout(observer.next);\n    removeObserverFromMirror(mirror, observer);\n\n    if (typeof window !== \"undefined\") {\n      window.removeEventListener(\"mouseup\", fastCheck);\n      window.removeEventListener(\"keyup\", fastCheck);\n      window.removeEventListener(\"mousedown\", fastCheck);\n      window.removeEventListener(\"keydown\", fastCheck);\n      window.removeEventListener(\"change\", fastCheck);\n    }\n  };\n\n  mirror.observers.set(callback, new ObserverInfo(callback, observer));\n\n  return observer;\n}\n\n/**\n * Generate an array of patches from an observer\n */\nexport function generate<T>(\n  observer: Observer<Object>,\n  invertible = false\n): Operation[] {\n  var mirror = beforeDict.get(observer.object);\n\n  _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n  if (observer.patches.length) {\n    applyPatch(mirror.value, observer.patches);\n  }\n  var temp = observer.patches;\n  if (temp.length > 0) {\n    observer.patches = [];\n    if (observer.callback) {\n      observer.callback(temp);\n    }\n  }\n  return temp;\n}\n\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n  if (obj === mirror) {\n    return;\n  }\n\n  if (typeof obj.toJSON === \"function\") {\n    obj = obj.toJSON();\n  }\n\n  var newKeys = _objectKeys(obj);\n  var oldKeys = _objectKeys(mirror);\n  var changed = false;\n  var deleted = false;\n\n  //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n\n  for (var t = oldKeys.length - 1; t >= 0; t--) {\n    var key = oldKeys[t];\n    var oldVal = mirror[key];\n\n    if (\n      hasOwnProperty(obj, key) &&\n      !(\n        obj[key] === undefined &&\n        oldVal !== undefined &&\n        Array.isArray(obj) === false\n      )\n    ) {\n      var newVal = obj[key];\n\n      if (\n        typeof oldVal == \"object\" &&\n        oldVal != null &&\n        typeof newVal == \"object\" &&\n        newVal != null &&\n        Array.isArray(oldVal) === Array.isArray(newVal)\n      ) {\n        _generate(\n          oldVal,\n          newVal,\n          patches,\n          path + \"/\" + escapePathComponent(key),\n          invertible\n        );\n      } else {\n        if (oldVal !== newVal) {\n          changed = true;\n          if (invertible) {\n            patches.push({\n              op: \"test\",\n              path: path + \"/\" + escapePathComponent(key),\n              value: _deepClone(oldVal),\n            });\n          }\n          patches.push({\n            op: \"replace\",\n            path: path + \"/\" + escapePathComponent(key),\n            value: _deepClone(newVal),\n          });\n        }\n      }\n    } else if (Array.isArray(mirror) === Array.isArray(obj)) {\n      if (invertible) {\n        patches.push({\n          op: \"test\",\n          path: path + \"/\" + escapePathComponent(key),\n          value: _deepClone(oldVal),\n        });\n      }\n      patches.push({\n        op: \"remove\",\n        path: path + \"/\" + escapePathComponent(key),\n      });\n      deleted = true; // property has been deleted\n    } else {\n      if (invertible) {\n        patches.push({ op: \"test\", path, value: mirror });\n      }\n      patches.push({ op: \"replace\", path, value: obj });\n      changed = true;\n    }\n  }\n\n  if (!deleted && newKeys.length == oldKeys.length) {\n    return;\n  }\n\n  for (var t = 0; t < newKeys.length; t++) {\n    var key = newKeys[t];\n    if (!hasOwnProperty(mirror, key) && obj[key] !== undefined) {\n      patches.push({\n        op: \"add\",\n        path: path + \"/\" + escapePathComponent(key),\n        value: _deepClone(obj[key]),\n      });\n    }\n  }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nexport function compare(\n  tree1: Object | Array<any>,\n  tree2: Object | Array<any>,\n  invertible = false\n): Operation[] {\n  var patches = [];\n  _generate(tree1, tree2, patches, \"\", invertible);\n  return patches;\n}\n"],"mappings":";;;;AA8JA,SAAS,UAAU,QAAQ,KAAK,SAAS,MAAM,YAAY;AACzD,KAAI,QAAQ,OACV;AAGF,KAAI,OAAO,IAAI,WAAW,YACxB,MAAM,IAAI,QAAQ;CAGpB,IAAI,UAAU,YAAY,IAAI;CAC9B,IAAI,UAAU,YAAY,OAAO;CACjC,IAAI,UAAU;CACd,IAAI,UAAU;AAId,MAAK,IAAI,IAAI,QAAQ,SAAS,GAAG,KAAK,GAAG,KAAK;EAC5C,IAAI,MAAM,QAAQ;EAClB,IAAI,SAAS,OAAO;AAEpB,MACE,eAAe,KAAK,IAAI,IACxB,EACE,IAAI,SAAS,UACb,WAAW,UACX,MAAM,QAAQ,IAAI,KAAK,QAEzB;GACA,IAAI,SAAS,IAAI;AAEjB,OACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAO,UAAU,YACjB,UAAU,QACV,MAAM,QAAQ,OAAO,KAAK,MAAM,QAAQ,OAAO,EAE/C,UACE,QACA,QACA,SACA,OAAO,MAAM,oBAAoB,IAAI,EACrC,WACD;YAEG,WAAW,QAAQ;IACrB,UAAU;AACV,QAAI,YACF,QAAQ,KAAK;KACX,IAAI;KACJ,MAAM,OAAO,MAAM,oBAAoB,IAAI;KAC3C,OAAO,WAAW,OAAO;IAC1B,EAAC;IAEJ,QAAQ,KAAK;KACX,IAAI;KACJ,MAAM,OAAO,MAAM,oBAAoB,IAAI;KAC3C,OAAO,WAAW,OAAO;IAC1B,EAAC;GACH;EAEJ,WAAU,MAAM,QAAQ,OAAO,KAAK,MAAM,QAAQ,IAAI,EAAE;AACvD,OAAI,YACF,QAAQ,KAAK;IACX,IAAI;IACJ,MAAM,OAAO,MAAM,oBAAoB,IAAI;IAC3C,OAAO,WAAW,OAAO;GAC1B,EAAC;GAEJ,QAAQ,KAAK;IACX,IAAI;IACJ,MAAM,OAAO,MAAM,oBAAoB,IAAI;GAC5C,EAAC;GACF,UAAU;EACX,OAAM;AACL,OAAI,YACF,QAAQ,KAAK;IAAE,IAAI;IAAQ;IAAM,OAAO;GAAQ,EAAC;GAEnD,QAAQ,KAAK;IAAE,IAAI;IAAW;IAAM,OAAO;GAAK,EAAC;GACjD,UAAU;EACX;CACF;AAED,KAAI,CAAC,WAAW,QAAQ,UAAU,QAAQ,OACxC;AAGF,MAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;EACvC,IAAI,MAAM,QAAQ;AAClB,MAAI,CAAC,eAAe,QAAQ,IAAI,IAAI,IAAI,SAAS,QAC/C,QAAQ,KAAK;GACX,IAAI;GACJ,MAAM,OAAO,MAAM,oBAAoB,IAAI;GAC3C,OAAO,WAAW,IAAI,KAAK;EAC5B,EAAC;CAEL;AACF;;;;AAID,SAAgB,QACdA,OACAC,OACA,aAAa,OACA;CACb,IAAI,UAAU,CAAE;CAChB,UAAU,OAAO,OAAO,SAAS,IAAI,WAAW;AAChD,QAAO;AACR"}