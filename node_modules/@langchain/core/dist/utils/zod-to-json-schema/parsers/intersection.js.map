{"version":3,"file":"intersection.js","names":["type: JsonSchema7Type | JsonSchema7StringType","def: ZodIntersectionDef","refs: Refs","unevaluatedProperties:\n    | Pick<JsonSchema7AllOfType, \"unevaluatedProperties\">\n    | undefined","mergedAllOf: JsonSchema7Type[]","nestedSchema: JsonSchema7Type"],"sources":["../../../../src/utils/zod-to-json-schema/parsers/intersection.ts"],"sourcesContent":["import { ZodIntersectionDef } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { JsonSchema7StringType } from \"./string.js\";\n\nexport type JsonSchema7AllOfType = {\n  allOf: JsonSchema7Type[];\n  unevaluatedProperties?: boolean;\n};\n\nconst isJsonSchema7AllOfType = (\n  type: JsonSchema7Type | JsonSchema7StringType\n): type is JsonSchema7AllOfType => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\n\nexport function parseIntersectionDef(\n  def: ZodIntersectionDef,\n  refs: Refs\n): JsonSchema7AllOfType | JsonSchema7Type | undefined {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n    }),\n  ].filter((x): x is JsonSchema7Type => !!x);\n\n  let unevaluatedProperties:\n    | Pick<JsonSchema7AllOfType, \"unevaluatedProperties\">\n    | undefined =\n    refs.target === \"jsonSchema2019-09\"\n      ? { unevaluatedProperties: false }\n      : undefined;\n\n  const mergedAllOf: JsonSchema7Type[] = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === undefined) {\n        // If one of the schemas has no unevaluatedProperties set,\n        // the merged schema should also have no unevaluatedProperties set\n        unevaluatedProperties = undefined;\n      }\n    } else {\n      let nestedSchema: JsonSchema7Type = schema;\n      if (\n        \"additionalProperties\" in schema &&\n        schema.additionalProperties === false\n      ) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      } else {\n        // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n        unevaluatedProperties = undefined;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length\n    ? {\n        allOf: mergedAllOf,\n        ...unevaluatedProperties,\n      }\n    : undefined;\n}\n"],"mappings":";;;AAWA,MAAM,yBAAyB,CAC7BA,SACiC;AACjC,KAAI,UAAU,QAAQ,KAAK,SAAS,SAAU,QAAO;AACrD,QAAO,WAAW;AACnB;AAED,SAAgB,qBACdC,KACAC,MACoD;CACpD,MAAM,QAAQ,CACZ,SAAS,IAAI,KAAK,MAAM;EACtB,GAAG;EACH,aAAa;GAAC,GAAG,KAAK;GAAa;GAAS;EAAI;CACjD,EAAC,EACF,SAAS,IAAI,MAAM,MAAM;EACvB,GAAG;EACH,aAAa;GAAC,GAAG,KAAK;GAAa;GAAS;EAAI;CACjD,EAAC,AACH,EAAC,OAAO,CAAC,MAA4B,CAAC,CAAC,EAAE;CAE1C,IAAIC,wBAGF,KAAK,WAAW,sBACZ,EAAE,uBAAuB,MAAO,IAChC;CAEN,MAAMC,cAAiC,CAAE;CAEzC,MAAM,QAAQ,CAAC,WAAW;AACxB,MAAI,uBAAuB,OAAO,EAAE;GAClC,YAAY,KAAK,GAAG,OAAO,MAAM;AACjC,OAAI,OAAO,0BAA0B,QAGnC,wBAAwB;EAE3B,OAAM;GACL,IAAIC,eAAgC;AACpC,OACE,0BAA0B,UAC1B,OAAO,yBAAyB,OAChC;IACA,MAAM,EAAE,qBAAsB,GAAG,MAAM,GAAG;IAC1C,eAAe;GAChB,OAEC,wBAAwB;GAE1B,YAAY,KAAK,aAAa;EAC/B;CACF,EAAC;AACF,QAAO,YAAY,SACf;EACE,OAAO;EACP,GAAG;CACJ,IACD;AACL"}