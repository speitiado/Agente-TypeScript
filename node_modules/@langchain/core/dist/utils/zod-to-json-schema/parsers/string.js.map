{"version":3,"file":"string.js","names":["emojiRegex: RegExp | undefined","def: ZodStringDef","refs: Refs","res: JsonSchema7StringType","_: never","literal: string","source: string","schema: JsonSchema7StringType","value: Required<JsonSchema7StringType>[\"format\"]","message: string | undefined","regex: RegExp"],"sources":["../../../../src/utils/zod-to-json-schema/parsers/string.ts"],"sourcesContent":["import { ZodStringDef } from \"zod/v3\";\nimport { ErrorMessages, setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { Refs } from \"../Refs.js\";\n\nlet emojiRegex: RegExp | undefined = undefined;\n\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email:\n    /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp(\n        \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n        \"u\"\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr:\n    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr:\n    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url:\n    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n} as const;\n\nexport type JsonSchema7StringType = {\n  type: \"string\";\n  minLength?: number;\n  maxLength?: number;\n  format?:\n    | \"email\"\n    | \"idn-email\"\n    | \"uri\"\n    | \"uuid\"\n    | \"date-time\"\n    | \"ipv4\"\n    | \"ipv6\"\n    | \"date\"\n    | \"time\"\n    | \"duration\";\n  pattern?: string;\n  allOf?: {\n    pattern: string;\n    errorMessage?: ErrorMessages<{ pattern: string }>;\n  }[];\n  anyOf?: {\n    format: string;\n    errorMessage?: ErrorMessages<{ format: string }>;\n  }[];\n  errorMessage?: ErrorMessages<JsonSchema7StringType>;\n  contentEncoding?: string;\n};\n\nexport function parseStringDef(\n  def: ZodStringDef,\n  refs: Refs\n): JsonSchema7StringType {\n  const res: JsonSchema7StringType = {\n    type: \"string\",\n  };\n\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          setResponseValueAndErrors(\n            res,\n            \"minLength\",\n            typeof res.minLength === \"number\"\n              ? Math.max(res.minLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          break;\n        case \"max\":\n          setResponseValueAndErrors(\n            res,\n            \"maxLength\",\n            typeof res.maxLength === \"number\"\n              ? Math.min(res.maxLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs\n          );\n          break;\n        case \"endsWith\":\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs\n          );\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          setResponseValueAndErrors(\n            res,\n            \"minLength\",\n            typeof res.minLength === \"number\"\n              ? Math.max(res.minLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          setResponseValueAndErrors(\n            res,\n            \"maxLength\",\n            typeof res.maxLength === \"number\"\n              ? Math.min(res.maxLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          break;\n        case \"includes\": {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs\n          );\n          break;\n        }\n        case \"ip\": {\n          if (check.version !== \"v6\") {\n            addFormat(res, \"ipv4\", check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addFormat(res, \"ipv6\", check.message, refs);\n          }\n          break;\n        }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\": {\n          if (check.version !== \"v6\") {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\": {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case \"base64\": {\n          switch (refs.base64Strategy) {\n            case \"format:binary\": {\n              addFormat(res, \"binary\" as any, check.message, refs);\n              break;\n            }\n\n            case \"contentEncoding:base64\": {\n              setResponseValueAndErrors(\n                res,\n                \"contentEncoding\",\n                \"base64\",\n                check.message,\n                refs\n              );\n              break;\n            }\n\n            case \"pattern:zod\": {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case \"nanoid\": {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n          break;\n        }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* c8 ignore next */\n          ((_: never) => {})(check);\n      }\n    }\n  }\n\n  return res;\n}\n\nfunction escapeLiteralCheckValue(literal: string, refs: Refs): string {\n  return refs.patternStrategy === \"escape\"\n    ? escapeNonAlphaNumeric(literal)\n    : literal;\n}\n\nconst ALPHA_NUMERIC = new Set(\n  \"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\"\n);\n\nfunction escapeNonAlphaNumeric(source: string) {\n  let result = \"\";\n\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n\n    result += source[i];\n  }\n\n  return result;\n}\n\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(\n  schema: JsonSchema7StringType,\n  value: Required<JsonSchema7StringType>[\"format\"],\n  message: string | undefined,\n  refs: Refs\n) {\n  if (schema.format || schema.anyOf?.some((x) => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n\n    if (schema.format) {\n      schema.anyOf!.push({\n        format: schema.format,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { format: schema.errorMessage.format },\n          }),\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.anyOf!.push({\n      format: value,\n      ...(message &&\n        refs.errorMessages && { errorMessage: { format: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"format\", value, message, refs);\n  }\n}\n\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(\n  schema: JsonSchema7StringType,\n  regex: RegExp,\n  message: string | undefined,\n  refs: Refs\n) {\n  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n\n    if (schema.pattern) {\n      schema.allOf!.push({\n        pattern: schema.pattern,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { pattern: schema.errorMessage.pattern },\n          }),\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.allOf!.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...(message &&\n        refs.errorMessages && { errorMessage: { pattern: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(\n      schema,\n      \"pattern\",\n      stringifyRegExpWithFlags(regex, refs),\n      message,\n      refs\n    );\n  }\n}\n\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex: RegExp, refs: Refs): string {\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes(\"i\"), // Case-insensitive\n    m: regex.flags.includes(\"m\"), // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes(\"s\"), // `.` matches newlines\n  };\n\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n\n  try {\n    new RegExp(pattern);\n  } catch {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        \"/\"\n      )} to a flag-independent form! Falling back to the flag-ignorant source`\n    );\n    return regex.source;\n  }\n\n  return pattern;\n}\n"],"mappings":"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"}