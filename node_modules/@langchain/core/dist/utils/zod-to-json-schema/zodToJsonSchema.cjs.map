{"version":3,"file":"zodToJsonSchema.cjs","names":["schema: ZodSchema<any>","options?: Partial<Options<Target>> | string","getRefs","acc: { [key: string]: JsonSchema7Type }","name","schema","parseDef","parseAnyDef","combined: ReturnType<typeof zodToJsonSchema<Target>>"],"sources":["../../../src/utils/zod-to-json-schema/zodToJsonSchema.ts"],"sourcesContent":["import { ZodSchema } from \"zod/v3\";\nimport { Options, Targets } from \"./Options.js\";\nimport { parseDef } from \"./parseDef.js\";\nimport { JsonSchema7Type } from \"./parseTypes.js\";\nimport { getRefs } from \"./Refs.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\n\nconst zodToJsonSchema = <Target extends Targets = \"jsonSchema7\">(\n  schema: ZodSchema<any>,\n  options?: Partial<Options<Target>> | string\n): (Target extends \"jsonSchema7\" ? JsonSchema7Type : object) & {\n  $schema?: string;\n  definitions?: {\n    [key: string]: Target extends \"jsonSchema7\"\n      ? JsonSchema7Type\n      : Target extends \"jsonSchema2019-09\"\n      ? JsonSchema7Type\n      : object;\n  };\n} => {\n  const refs = getRefs(options);\n\n  let definitions =\n    typeof options === \"object\" && options.definitions\n      ? Object.entries(options.definitions).reduce(\n          (acc: { [key: string]: JsonSchema7Type }, [name, schema]) => ({\n            ...acc,\n            [name]:\n              parseDef(\n                schema._def,\n                {\n                  ...refs,\n                  currentPath: [...refs.basePath, refs.definitionPath, name],\n                },\n                true\n              ) ?? parseAnyDef(refs),\n          }),\n          {}\n        )\n      : undefined;\n\n  const name =\n    typeof options === \"string\"\n      ? options\n      : options?.nameStrategy === \"title\"\n      ? undefined\n      : options?.name;\n\n  const main =\n    parseDef(\n      schema._def,\n      name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n          },\n      false\n    ) ?? (parseAnyDef(refs) as JsonSchema7Type);\n\n  const title =\n    typeof options === \"object\" &&\n    options.name !== undefined &&\n    options.nameStrategy === \"title\"\n      ? options.name\n      : undefined;\n\n  if (title !== undefined) {\n    main.title = title;\n  }\n\n  if (refs.flags.hasReferencedOpenAiAnyType) {\n    if (!definitions) {\n      definitions = {};\n    }\n\n    if (!definitions[refs.openAiAnyTypeName]) {\n      definitions[refs.openAiAnyTypeName] = {\n        // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n        type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n        items: {\n          $ref:\n            refs.$refStrategy === \"relative\"\n              ? \"1\"\n              : [\n                  ...refs.basePath,\n                  refs.definitionPath,\n                  refs.openAiAnyTypeName,\n                ].join(\"/\"),\n        },\n      } as JsonSchema7Type;\n    }\n  }\n\n  const combined: ReturnType<typeof zodToJsonSchema<Target>> =\n    name === undefined\n      ? definitions\n        ? {\n            ...main,\n            [refs.definitionPath]: definitions,\n          }\n        : main\n      : {\n          $ref: [\n            ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n            refs.definitionPath,\n            name,\n          ].join(\"/\"),\n          [refs.definitionPath]: {\n            ...definitions,\n            [name]: main,\n          },\n        };\n\n  if (refs.target === \"jsonSchema7\") {\n    combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  } else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n    combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n  }\n\n  if (\n    refs.target === \"openAi\" &&\n    (\"anyOf\" in combined ||\n      \"oneOf\" in combined ||\n      \"allOf\" in combined ||\n      (\"type\" in combined && Array.isArray(combined.type)))\n  ) {\n    console.warn(\n      \"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\"\n    );\n  }\n\n  return combined;\n};\n\nexport { zodToJsonSchema };\n"],"mappings":";;;;;AAOA,MAAM,kBAAkB,CACtBA,QACAC,YAUG;CACH,MAAM,OAAOC,qBAAQ,QAAQ;CAE7B,IAAI,cACF,OAAO,YAAY,YAAY,QAAQ,cACnC,OAAO,QAAQ,QAAQ,YAAY,CAAC,OAClC,CAACC,KAAyC,CAACC,QAAMC,SAAO,MAAM;EAC5D,GAAG;GACFD,SACCE,0BACED,SAAO,MACP;GACE,GAAG;GACH,aAAa;IAAC,GAAG,KAAK;IAAU,KAAK;IAAgBD;GAAK;EAC3D,GACD,KACD,IAAIG,wBAAY,KAAK;CACzB,IACD,CAAE,EACH,GACD;CAEN,MAAM,OACJ,OAAO,YAAY,WACf,UACA,SAAS,iBAAiB,UAC1B,SACA,SAAS;CAEf,MAAM,OACJD,0BACE,OAAO,MACP,SAAS,SACL,OACA;EACE,GAAG;EACH,aAAa;GAAC,GAAG,KAAK;GAAU,KAAK;GAAgB;EAAK;CAC3D,GACL,MACD,IAAKC,wBAAY,KAAK;CAEzB,MAAM,QACJ,OAAO,YAAY,YACnB,QAAQ,SAAS,UACjB,QAAQ,iBAAiB,UACrB,QAAQ,OACR;AAEN,KAAI,UAAU,QACZ,KAAK,QAAQ;AAGf,KAAI,KAAK,MAAM,4BAA4B;AACzC,MAAI,CAAC,aACH,cAAc,CAAE;AAGlB,MAAI,CAAC,YAAY,KAAK,oBACpB,YAAY,KAAK,qBAAqB;GAEpC,MAAM;IAAC;IAAU;IAAU;IAAW;IAAW;IAAS;GAAO;GACjE,OAAO,EACL,MACE,KAAK,iBAAiB,aAClB,MACA;IACE,GAAG,KAAK;IACR,KAAK;IACL,KAAK;GACN,EAAC,KAAK,IAAI,CAClB;EACF;CAEJ;CAED,MAAMC,WACJ,SAAS,SACL,cACE;EACE,GAAG;GACF,KAAK,iBAAiB;CACxB,IACD,OACF;EACE,MAAM;GACJ,GAAI,KAAK,iBAAiB,aAAa,CAAE,IAAG,KAAK;GACjD,KAAK;GACL;EACD,EAAC,KAAK,IAAI;GACV,KAAK,iBAAiB;GACrB,GAAG;IACF,OAAO;EACT;CACF;AAEP,KAAI,KAAK,WAAW,eAClB,SAAS,UAAU;UACV,KAAK,WAAW,uBAAuB,KAAK,WAAW,UAChE,SAAS,UAAU;AAGrB,KACE,KAAK,WAAW,aACf,WAAW,YACV,WAAW,YACX,WAAW,YACV,UAAU,YAAY,MAAM,QAAQ,SAAS,KAAK,GAErD,QAAQ,KACN,uGACD;AAGH,QAAO;AACR"}