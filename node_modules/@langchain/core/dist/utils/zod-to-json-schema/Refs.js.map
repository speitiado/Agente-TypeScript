{"version":3,"file":"Refs.js","names":["options?: string | Partial<Options<Targets>>"],"sources":["../../../src/utils/zod-to-json-schema/Refs.ts"],"sourcesContent":["import { ZodTypeDef } from \"zod/v3\";\nimport { getDefaultOptions, Options, Targets } from \"./Options.js\";\nimport { JsonSchema7Type } from \"./parseTypes.js\";\n\nexport type Refs = {\n  seen: Map<ZodTypeDef, Seen>;\n  currentPath: string[];\n  propertyPath: string[] | undefined;\n  flags: { hasReferencedOpenAiAnyType: boolean };\n} & Options<Targets>;\n\nexport type Seen = {\n  def: ZodTypeDef;\n  path: string[];\n  jsonSchema: JsonSchema7Type | undefined;\n};\n\nexport const getRefs = (options?: string | Partial<Options<Targets>>): Refs => {\n  const _options = getDefaultOptions(options);\n  const currentPath =\n    _options.name !== undefined\n      ? [..._options.basePath, _options.definitionPath, _options.name]\n      : _options.basePath;\n  return {\n    ..._options,\n    flags: { hasReferencedOpenAiAnyType: false },\n    currentPath: currentPath,\n    propertyPath: undefined,\n    seen: new Map(\n      Object.entries(_options.definitions).map(([name, def]) => [\n        def._def,\n        {\n          def: def._def,\n          path: [..._options.basePath, _options.definitionPath, name],\n          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n          jsonSchema: undefined,\n        },\n      ])\n    ),\n  };\n};\n"],"mappings":";;;AAiBA,MAAa,UAAU,CAACA,YAAuD;CAC7E,MAAM,WAAW,kBAAkB,QAAQ;CAC3C,MAAM,cACJ,SAAS,SAAS,SACd;EAAC,GAAG,SAAS;EAAU,SAAS;EAAgB,SAAS;CAAK,IAC9D,SAAS;AACf,QAAO;EACL,GAAG;EACH,OAAO,EAAE,4BAA4B,MAAO;EAC/B;EACb,cAAc;EACd,MAAM,IAAI,IACR,OAAO,QAAQ,SAAS,YAAY,CAAC,IAAI,CAAC,CAAC,MAAM,IAAI,KAAK,CACxD,IAAI,MACJ;GACE,KAAK,IAAI;GACT,MAAM;IAAC,GAAG,SAAS;IAAU,SAAS;IAAgB;GAAK;GAE3D,YAAY;EACb,CACF,EAAC;CAEL;AACF"}