{"version":3,"file":"sax.cjs","names":["sax: any","sax","s"],"sources":["../../../src/utils/sax-js/sax.ts"],"sourcesContent":["// @ts-nocheck\n\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\n\nconst initializeSax = function () {\n  const sax: any = {};\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream;\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n\n  const buffers = [\n    \"comment\",\n    \"sgmlDecl\",\n    \"textNode\",\n    \"tagName\",\n    \"doctype\",\n    \"procInstName\",\n    \"procInstBody\",\n    \"entity\",\n    \"attribName\",\n    \"attribValue\",\n    \"cdata\",\n    \"script\",\n  ];\n\n  sax.EVENTS = [\n    \"text\",\n    \"processinginstruction\",\n    \"sgmldeclaration\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"opencdata\",\n    \"cdata\",\n    \"closecdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n    \"script\",\n    \"opennamespace\",\n    \"closenamespace\",\n  ];\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt);\n    }\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.strictEntities = parser.opt.strictEntities;\n    parser.ENTITIES = parser.strictEntities\n      ? Object.create(sax.XML_ENTITIES)\n      : Object.create(sax.ENTITIES);\n    parser.attribList = [];\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS);\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false;\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n    emit(parser, \"onready\");\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F() {}\n      F.prototype = o;\n      var newf = new F();\n      return newf;\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n\n  function flushBuffers(parser) {\n    closeText(parser);\n    if (parser.cdata !== \"\") {\n      emitNode(parser, \"oncdata\", parser.cdata);\n      parser.cdata = \"\";\n    }\n    if (parser.script !== \"\") {\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () {\n      end(this);\n    },\n    write: write,\n    resume: function () {\n      this.error = null;\n      return this;\n    },\n    close: function () {\n      return this.write(null);\n    },\n    flush: function () {\n      flushBuffers(this);\n    },\n  };\n\n  var Stream = ReadableStream;\n  if (!Stream) Stream = function () {};\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt);\n    }\n\n    Stream.apply(this);\n\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n\n    var me = this;\n\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null;\n    };\n\n    this._decoder = null;\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function () {\n          return me._parser[\"on\" + ev];\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            me._parser[\"on\" + ev] = h;\n            return h;\n          }\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false,\n      });\n    });\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream,\n    },\n  });\n\n  SAXStream.prototype.write = function (data) {\n    this._parser.write(data.toString());\n    this.emit(\"data\", data);\n    return true;\n  };\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk);\n    }\n    this._parser.end();\n    return true;\n  };\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args =\n          arguments.length === 1\n            ? [arguments[0]]\n            : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = \"[CDATA[\";\n  var DOCTYPE = \"DOCTYPE\";\n  var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n  var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n\n  var nameBody =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  var entityStart =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var entityBody =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  function isWhitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n  }\n\n  function isQuote(c) {\n    return c === '\"' || c === \"'\";\n  }\n\n  function isAttribEnd(c) {\n    return c === \">\" || isWhitespace(c);\n  }\n\n  function isMatch(regex, c) {\n    return regex.test(c);\n  }\n\n  function notMatch(regex, c) {\n    return !isMatch(regex, c);\n  }\n\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++, // <script> ... <\n  };\n\n  sax.XML_ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n  };\n\n  sax.ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n    AElig: 198,\n    Aacute: 193,\n    Acirc: 194,\n    Agrave: 192,\n    Aring: 197,\n    Atilde: 195,\n    Auml: 196,\n    Ccedil: 199,\n    ETH: 208,\n    Eacute: 201,\n    Ecirc: 202,\n    Egrave: 200,\n    Euml: 203,\n    Iacute: 205,\n    Icirc: 206,\n    Igrave: 204,\n    Iuml: 207,\n    Ntilde: 209,\n    Oacute: 211,\n    Ocirc: 212,\n    Ograve: 210,\n    Oslash: 216,\n    Otilde: 213,\n    Ouml: 214,\n    THORN: 222,\n    Uacute: 218,\n    Ucirc: 219,\n    Ugrave: 217,\n    Uuml: 220,\n    Yacute: 221,\n    aacute: 225,\n    acirc: 226,\n    aelig: 230,\n    agrave: 224,\n    aring: 229,\n    atilde: 227,\n    auml: 228,\n    ccedil: 231,\n    eacute: 233,\n    ecirc: 234,\n    egrave: 232,\n    eth: 240,\n    euml: 235,\n    iacute: 237,\n    icirc: 238,\n    igrave: 236,\n    iuml: 239,\n    ntilde: 241,\n    oacute: 243,\n    ocirc: 244,\n    ograve: 242,\n    oslash: 248,\n    otilde: 245,\n    ouml: 246,\n    szlig: 223,\n    thorn: 254,\n    uacute: 250,\n    ucirc: 251,\n    ugrave: 249,\n    uuml: 252,\n    yacute: 253,\n    yuml: 255,\n    copy: 169,\n    reg: 174,\n    nbsp: 160,\n    iexcl: 161,\n    cent: 162,\n    pound: 163,\n    curren: 164,\n    yen: 165,\n    brvbar: 166,\n    sect: 167,\n    uml: 168,\n    ordf: 170,\n    laquo: 171,\n    not: 172,\n    shy: 173,\n    macr: 175,\n    deg: 176,\n    plusmn: 177,\n    sup1: 185,\n    sup2: 178,\n    sup3: 179,\n    acute: 180,\n    micro: 181,\n    para: 182,\n    middot: 183,\n    cedil: 184,\n    ordm: 186,\n    raquo: 187,\n    frac14: 188,\n    frac12: 189,\n    frac34: 190,\n    iquest: 191,\n    times: 215,\n    divide: 247,\n    OElig: 338,\n    oelig: 339,\n    Scaron: 352,\n    scaron: 353,\n    Yuml: 376,\n    fnof: 402,\n    circ: 710,\n    tilde: 732,\n    Alpha: 913,\n    Beta: 914,\n    Gamma: 915,\n    Delta: 916,\n    Epsilon: 917,\n    Zeta: 918,\n    Eta: 919,\n    Theta: 920,\n    Iota: 921,\n    Kappa: 922,\n    Lambda: 923,\n    Mu: 924,\n    Nu: 925,\n    Xi: 926,\n    Omicron: 927,\n    Pi: 928,\n    Rho: 929,\n    Sigma: 931,\n    Tau: 932,\n    Upsilon: 933,\n    Phi: 934,\n    Chi: 935,\n    Psi: 936,\n    Omega: 937,\n    alpha: 945,\n    beta: 946,\n    gamma: 947,\n    delta: 948,\n    epsilon: 949,\n    zeta: 950,\n    eta: 951,\n    theta: 952,\n    iota: 953,\n    kappa: 954,\n    lambda: 955,\n    mu: 956,\n    nu: 957,\n    xi: 958,\n    omicron: 959,\n    pi: 960,\n    rho: 961,\n    sigmaf: 962,\n    sigma: 963,\n    tau: 964,\n    upsilon: 965,\n    phi: 966,\n    chi: 967,\n    psi: 968,\n    omega: 969,\n    thetasym: 977,\n    upsih: 978,\n    piv: 982,\n    ensp: 8194,\n    emsp: 8195,\n    thinsp: 8201,\n    zwnj: 8204,\n    zwj: 8205,\n    lrm: 8206,\n    rlm: 8207,\n    ndash: 8211,\n    mdash: 8212,\n    lsquo: 8216,\n    rsquo: 8217,\n    sbquo: 8218,\n    ldquo: 8220,\n    rdquo: 8221,\n    bdquo: 8222,\n    dagger: 8224,\n    Dagger: 8225,\n    bull: 8226,\n    hellip: 8230,\n    permil: 8240,\n    prime: 8242,\n    Prime: 8243,\n    lsaquo: 8249,\n    rsaquo: 8250,\n    oline: 8254,\n    frasl: 8260,\n    euro: 8364,\n    image: 8465,\n    weierp: 8472,\n    real: 8476,\n    trade: 8482,\n    alefsym: 8501,\n    larr: 8592,\n    uarr: 8593,\n    rarr: 8594,\n    darr: 8595,\n    harr: 8596,\n    crarr: 8629,\n    lArr: 8656,\n    uArr: 8657,\n    rArr: 8658,\n    dArr: 8659,\n    hArr: 8660,\n    forall: 8704,\n    part: 8706,\n    exist: 8707,\n    empty: 8709,\n    nabla: 8711,\n    isin: 8712,\n    notin: 8713,\n    ni: 8715,\n    prod: 8719,\n    sum: 8721,\n    minus: 8722,\n    lowast: 8727,\n    radic: 8730,\n    prop: 8733,\n    infin: 8734,\n    ang: 8736,\n    and: 8743,\n    or: 8744,\n    cap: 8745,\n    cup: 8746,\n    int: 8747,\n    there4: 8756,\n    sim: 8764,\n    cong: 8773,\n    asymp: 8776,\n    ne: 8800,\n    equiv: 8801,\n    le: 8804,\n    ge: 8805,\n    sub: 8834,\n    sup: 8835,\n    nsub: 8836,\n    sube: 8838,\n    supe: 8839,\n    oplus: 8853,\n    otimes: 8855,\n    perp: 8869,\n    sdot: 8901,\n    lceil: 8968,\n    rceil: 8969,\n    lfloor: 8970,\n    rfloor: 8971,\n    lang: 9001,\n    rang: 9002,\n    loz: 9674,\n    spades: 9824,\n    clubs: 9827,\n    hearts: 9829,\n    diams: 9830,\n  };\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key];\n    var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n    sax.ENTITIES[key] = s;\n  });\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s;\n  }\n\n  // shorthand\n  S = sax.STATE;\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n      er +=\n        \"\\nLine: \" +\n        parser.line +\n        \"\\nColumn: \" +\n        parser.column +\n        \"\\nChar: \" +\n        parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot)\n      strictFail(parser, \"Unclosed root tag\");\n    if (\n      parser.state !== S.BEGIN &&\n      parser.state !== S.BEGIN_WHITESPACE &&\n      parser.state !== S.TEXT\n    ) {\n      error(parser, \"Unexpected end\");\n    }\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n\n  function strictFail(parser, message) {\n    if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n      throw new Error(\"bad call to strictFail\");\n    }\n    if (parser.strict) {\n      error(parser, message);\n    }\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns;\n    }\n    parser.attribList.length = 0;\n    emitNode(parser, \"onopentagstart\", tag);\n  }\n\n  function qname(name, attribute) {\n    var i = name.indexOf(\":\");\n    var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n    var prefix = qualName[0];\n    var local = qualName[1];\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n\n    return { prefix: prefix, local: local };\n  }\n\n  function attrib(parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]();\n    }\n\n    if (\n      parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)\n    ) {\n      parser.attribName = parser.attribValue = \"\";\n      return;\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true);\n      var prefix = qn.prefix;\n      var local = qn.local;\n\n      if (prefix === \"xmlns\") {\n        // namespace binding attribute. push the binding into scope\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(\n            parser,\n            \"xml: prefix must be bound to \" +\n              XML_NAMESPACE +\n              \"\\n\" +\n              \"Actual: \" +\n              parser.attribValue\n          );\n        } else if (\n          local === \"xmlns\" &&\n          parser.attribValue !== XMLNS_NAMESPACE\n        ) {\n          strictFail(\n            parser,\n            \"xmlns: prefix must be bound to \" +\n              XMLNS_NAMESPACE +\n              \"\\n\" +\n              \"Actual: \" +\n              parser.attribValue\n          );\n        } else {\n          var tag = parser.tag;\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n          tag.ns[local] = parser.attribValue;\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue,\n      });\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag;\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || \"\";\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(\n          parser,\n          \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName)\n        );\n        tag.uri = qn.prefix;\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p],\n          });\n        });\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0];\n        var value = nv[1];\n        var qualName = qname(name, true);\n        var prefix = qualName.prefix;\n        var local = qualName.local;\n        var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri,\n        };\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== \"xmlns\" && !uri) {\n          strictFail(\n            parser,\n            \"Unbound namespace prefix: \" + JSON.stringify(prefix)\n          );\n          a.uri = prefix;\n        }\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n      parser.attribList.length = 0;\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing;\n\n    // process the tag\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== \"script\") {\n        parser.script += \"</\" + parser.tagName + \">\";\n        parser.tagName = \"\";\n        parser.state = S.SCRIPT;\n        return;\n      }\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]();\n    }\n    var closeTo = tagName;\n    while (t--) {\n      var close = parser.tags[t];\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, \"Unexpected close tag\");\n      } else {\n        break;\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n      var tag = (parser.tag = parser.tags.pop());\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n\n      var x = {};\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i];\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n        });\n      }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = \"\";\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity];\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC];\n    }\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n  function beginWhiteSpace(parser, c) {\n    if (c === \"<\") {\n      parser.state = S.OPEN_WAKA;\n      parser.startTagPosition = parser.position;\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, \"Non-whitespace before first tag.\");\n      parser.textNode = c;\n      parser.state = S.TEXT;\n    }\n  }\n\n  function charAt(chunk, i) {\n    var result = \"\";\n    if (i < chunk.length) {\n      result = chunk.charAt(i);\n    }\n    return result;\n  }\n\n  function write(chunk) {\n    var parser = this;\n    if (this.error) {\n      throw this.error;\n    }\n    if (parser.closed) {\n      return error(\n        parser,\n        \"Cannot write after close. Assign an onready handler.\"\n      );\n    }\n    if (chunk === null) {\n      return end(parser);\n    }\n    if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    }\n    var i = 0;\n    var c = \"\";\n    while (true) {\n      c = charAt(chunk, i++);\n      parser.c = c;\n\n      if (!c) {\n        break;\n      }\n\n      if (parser.trackPosition) {\n        parser.position++;\n        if (c === \"\\n\") {\n          parser.line++;\n          parser.column = 0;\n        } else {\n          parser.column++;\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE;\n          if (c === \"\\uFEFF\") {\n            continue;\n          }\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = charAt(chunk, i++);\n              if (c && parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else {\n                  parser.column++;\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n          if (\n            c === \"<\" &&\n            !(parser.sawRoot && parser.closedRoot && !parser.strict)\n          ) {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, \"Text data outside of root node.\");\n            }\n            if (c === \"&\") {\n              parser.state = S.TEXT_ENTITY;\n            } else {\n              parser.textNode += c;\n            }\n          }\n          continue;\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else {\n            parser.script += c;\n          }\n          continue;\n\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n          continue;\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition;\n              c = new Array(pad).join(\" \") + c;\n            }\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser, \"Inappropriately located doctype declaration\");\n            }\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else {\n            parser.sgmlDecl += c;\n          }\n          continue;\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n          parser.sgmlDecl += c;\n          continue;\n\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true; // just remember that we saw it.\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") {\n              parser.state = S.DOCTYPE_DTD;\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n          continue;\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") {\n            parser.state = S.DOCTYPE;\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n          continue;\n\n        case S.COMMENT:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDING;\n          } else {\n            parser.comment += c;\n          }\n          continue;\n\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) {\n              emitNode(parser, \"oncomment\", parser.comment);\n            }\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n          continue;\n\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\");\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else {\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.CDATA:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING;\n          } else {\n            parser.cdata += c;\n          }\n          continue;\n\n        case S.CDATA_ENDING:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING_2;\n          } else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) {\n              emitNode(parser, \"oncdata\", parser.cdata);\n            }\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.PROC_INST:\n          if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY;\n          } else {\n            parser.procInstName += c;\n          }\n          continue;\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue;\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else {\n            parser.procInstBody += c;\n          }\n          continue;\n\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody,\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n          continue;\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else {\n            newTag(parser);\n            if (c === \">\") {\n              openTag(parser);\n            } else if (c === \"/\") {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, \"Invalid character in tag name\");\n              }\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(\n              parser,\n              \"Forward-slash in opening tag not followed by >\"\n            );\n            parser.state = S.ATTRIB;\n          }\n          continue;\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_NAME:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (c === \">\") {\n            strictFail(parser, \"Attribute without value\");\n            parser.attribValue = parser.attribName;\n            attrib(parser);\n            openTag(parser);\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE;\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (isWhitespace(c)) {\n            continue;\n          } else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\",\n            });\n            parser.attribName = \"\";\n            if (c === \">\") {\n              openTag(parser);\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue;\n          } else if (isQuote(c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB_VALUE_CLOSED;\n          continue;\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, \"No whitespace between attributes\");\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          if (c === \">\") {\n            openTag(parser);\n          } else {\n            parser.state = S.ATTRIB;\n          }\n          continue;\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue;\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += \"</\" + c;\n                parser.state = S.SCRIPT;\n              } else {\n                strictFail(parser, \"Invalid tagname in closing tag.\");\n              }\n            } else {\n              parser.tagName = c;\n            }\n          } else if (c === \">\") {\n            closeTag(parser);\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else if (parser.script) {\n            parser.script += \"</\" + parser.tagName;\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, \"Invalid tagname in closing tag\");\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n          continue;\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue;\n          }\n          if (c === \">\") {\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Invalid characters in closing tag\");\n          }\n          continue;\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState;\n          var buffer;\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT;\n              buffer = \"textNode\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED;\n              buffer = \"attribValue\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED;\n              buffer = \"attribValue\";\n              break;\n          }\n\n          if (c === \";\") {\n            if (parser.opt.unparsedEntities) {\n              var parsedEntity = parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n              parser.write(parsedEntity);\n            } else {\n              parser[buffer] += parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n            }\n          } else if (\n            isMatch(parser.entity.length ? entityBody : entityStart, c)\n          ) {\n            parser.entity += c;\n          } else {\n            strictFail(parser, \"Invalid character in entity name\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n\n          continue;\n\n        default: /* istanbul ignore next */ {\n          throw new Error(parser, \"Unknown state: \" + parser.state);\n        }\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser);\n    }\n    return parser;\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode;\n      var floor = Math.floor;\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n        if (!length) {\n          return \"\";\n        }\n        var result = \"\";\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10ffff || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError(\"Invalid code point: \" + codePoint);\n          }\n          if (codePoint <= 0xffff) {\n            // BMP code point\n            codeUnits.push(codePoint);\n          } else {\n            // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xd800;\n            lowSurrogate = (codePoint % 0x400) + 0xdc00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n        return result;\n      };\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, \"fromCodePoint\", {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true,\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n  return sax;\n};\n\nconst sax = /** #__PURE__ */ initializeSax();\n\nexport { sax };\n"],"mappings":"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"}