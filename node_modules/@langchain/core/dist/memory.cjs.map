{"version":3,"file":"memory.cjs","names":["values: InputValues | OutputValues","key?: string","inputValues: InputValues","inputKey?: string","outputValues: OutputValues","outputKey?: string","inputs: Record<string, unknown>","memoryVariables: string[]"],"sources":["../src/memory.ts"],"sourcesContent":["/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the input values for a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type InputValues = Record<string, any>;\n\n/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the output values from a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type OutputValues = Record<string, any>;\n\n/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the memory variables in a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type MemoryVariables = Record<string, any>;\n\n/**\n * Abstract base class for memory in LangChain's Chains. Memory refers to\n * the state in Chains. It can be used to store information about past\n * executions of a Chain and inject that information into the inputs of\n * future executions of the Chain.\n */\nexport abstract class BaseMemory {\n  abstract get memoryKeys(): string[];\n\n  /**\n   * Abstract method that should take an object of input values and return a\n   * Promise that resolves with an object of memory variables. The\n   * implementation of this method should load the memory variables from the\n   * provided input values.\n   * @param values An object of input values.\n   * @returns Promise that resolves with an object of memory variables.\n   */\n  abstract loadMemoryVariables(values: InputValues): Promise<MemoryVariables>;\n\n  /**\n   * Abstract method that should take two objects, one of input values and\n   * one of output values, and return a Promise that resolves when the\n   * context has been saved. The implementation of this method should save\n   * the context based on the provided input and output values.\n   * @param inputValues An object of input values.\n   * @param outputValues An object of output values.\n   * @returns Promise that resolves when the context has been saved.\n   */\n  abstract saveContext(\n    inputValues: InputValues,\n    outputValues: OutputValues\n  ): Promise<void>;\n}\n\nconst getValue = (values: InputValues | OutputValues, key?: string) => {\n  if (key !== undefined) {\n    return values[key];\n  }\n  const keys = Object.keys(values);\n  if (keys.length === 1) {\n    return values[keys[0]];\n  }\n};\n\n/**\n * This function is used by memory classes to select the input value\n * to use for the memory. If there is only one input value, it is used.\n * If there are multiple input values, the inputKey must be specified.\n */\nexport const getInputValue = (inputValues: InputValues, inputKey?: string) => {\n  const value = getValue(inputValues, inputKey);\n  if (!value) {\n    const keys = Object.keys(inputValues);\n    throw new Error(\n      `input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`\n    );\n  }\n  return value;\n};\n\n/**\n * This function is used by memory classes to select the output value\n * to use for the memory. If there is only one output value, it is used.\n * If there are multiple output values, the outputKey must be specified.\n * If no outputKey is specified, an error is thrown.\n */\nexport const getOutputValue = (\n  outputValues: OutputValues,\n  outputKey?: string\n) => {\n  const value = getValue(outputValues, outputKey);\n  if (!value && value !== \"\") {\n    const keys = Object.keys(outputValues);\n    throw new Error(\n      `output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`\n    );\n  }\n  return value;\n};\n\n/**\n * Function used by memory classes to get the key of the prompt input,\n * excluding any keys that are memory variables or the \"stop\" key. If\n * there is not exactly one prompt input key, an error is thrown.\n */\nexport function getPromptInputKey(\n  inputs: Record<string, unknown>,\n  memoryVariables: string[]\n): string {\n  const promptInputKeys = Object.keys(inputs).filter(\n    (key) => !memoryVariables.includes(key) && key !== \"stop\"\n  );\n  if (promptInputKeys.length !== 1) {\n    throw new Error(\n      `One input key expected, but got ${promptInputKeys.length}`\n    );\n  }\n  return promptInputKeys[0];\n}\n"],"mappings":";;;;;;;;;;;;;;;;AA2BA,IAAsB,aAAtB,MAAiC,CA0BhC;AAED,MAAM,WAAW,CAACA,QAAoCC,QAAiB;AACrE,KAAI,QAAQ,OACV,QAAO,OAAO;CAEhB,MAAM,OAAO,OAAO,KAAK,OAAO;AAChC,KAAI,KAAK,WAAW,EAClB,QAAO,OAAO,KAAK;AAEtB;;;;;;AAOD,MAAa,gBAAgB,CAACC,aAA0BC,aAAsB;CAC5E,MAAM,QAAQ,SAAS,aAAa,SAAS;AAC7C,KAAI,CAAC,OAAO;EACV,MAAM,OAAO,OAAO,KAAK,YAAY;AACrC,QAAM,IAAI,MACR,CAAC,kBAAkB,EAAE,KAAK,OAAO,gEAAgE,CAAC;CAErG;AACD,QAAO;AACR;;;;;;;AAQD,MAAa,iBAAiB,CAC5BC,cACAC,cACG;CACH,MAAM,QAAQ,SAAS,cAAc,UAAU;AAC/C,KAAI,CAAC,SAAS,UAAU,IAAI;EAC1B,MAAM,OAAO,OAAO,KAAK,aAAa;AACtC,QAAM,IAAI,MACR,CAAC,mBAAmB,EAAE,KAAK,OAAO,kEAAkE,CAAC;CAExG;AACD,QAAO;AACR;;;;;;AAOD,SAAgB,kBACdC,QACAC,iBACQ;CACR,MAAM,kBAAkB,OAAO,KAAK,OAAO,CAAC,OAC1C,CAAC,QAAQ,CAAC,gBAAgB,SAAS,IAAI,IAAI,QAAQ,OACpD;AACD,KAAI,gBAAgB,WAAW,EAC7B,OAAM,IAAI,MACR,CAAC,gCAAgC,EAAE,gBAAgB,QAAQ;AAG/D,QAAO,gBAAgB;AACxB"}