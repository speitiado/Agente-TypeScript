{"version":3,"file":"manager.cjs","names":["arg: Callbacks | BaseCallbackConfig | undefined","handler: BaseCallbackHandler","runId: string","handlers: BaseCallbackHandler[]","inheritableHandlers: BaseCallbackHandler[]","tags: string[]","inheritableTags: string[]","metadata: Record<string, unknown>","inheritableMetadata: Record<string, unknown>","_parentRunId?: string","text: string","consumeCallback","eventName: string","data: any","_runId?: string","_tags?: string[]","_metadata?: Record<string, any>","tag?: string","documents: DocumentInterface[]","err: Error | unknown","token: string","idx?: NewTokenIndices","fields?: HandleLLMNewTokenCallbackFields","extraParams?: Record<string, unknown>","err","output: LLMResult","kwargs?: { inputs?: Record<string, unknown> }","output: ChainValues","action: AgentAction","action: AgentFinish","output: any","parentRunId?: string","options?: {\n      handlers?: BaseCallbackHandler[];\n      inheritableHandlers?: BaseCallbackHandler[];\n      tags?: string[];\n      inheritableTags?: string[];\n      metadata?: Record<string, unknown>;\n      inheritableMetadata?: Record<string, unknown>;\n    }","llm: Serialized","prompts: string[]","runId: string | undefined","_parentRunId: string | undefined","extraParams: Record<string, unknown> | undefined","_tags: string[] | undefined","_metadata: Record<string, unknown> | undefined","runName: string | undefined","isBaseTracer","messages: BaseMessage[][]","getBufferString","chain: Serialized","inputs: ChainValues","runType: string | undefined","tool: Serialized","input: string","retriever: Serialized","query: string","additionalHandlers: BaseCallbackHandler[]","handlers: CallbackHandlerMethods","BaseCallbackHandler","inheritableHandlers?: Callbacks","localHandlers?: Callbacks","inheritableTags?: string[]","localTags?: string[]","inheritableMetadata?: Record<string, unknown>","localMetadata?: Record<string, unknown>","options?: CallbackManagerOptions","callbackManager: CallbackManager | undefined","getEnvironmentVariable","LangChainTracer","isTracingEnabled","ConsoleCallbackHandler","_getConfigureHooks","handler: BaseCallbackHandler | undefined","getContextVariable","isBaseCallbackHandler","handler: BaseCallbackHandler | CallbackHandlerMethods"],"sources":["../../src/callbacks/manager.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport { LLMResult } from \"../outputs.js\";\nimport {\n  BaseCallbackHandler,\n  CallbackHandlerMethods,\n  HandleLLMNewTokenCallbackFields,\n  isBaseCallbackHandler,\n  NewTokenIndices,\n} from \"./base.js\";\nimport { ConsoleCallbackHandler } from \"../tracers/console.js\";\nimport { type BaseMessage } from \"../messages/base.js\";\nimport { getBufferString } from \"../messages/utils.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { LangChainTracer } from \"../tracers/tracer_langchain.js\";\nimport { consumeCallback } from \"./promises.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { isTracingEnabled } from \"../utils/callbacks.js\";\nimport { isBaseTracer } from \"../tracers/base.js\";\nimport {\n  getContextVariable,\n  _getConfigureHooks,\n} from \"../singletons/async_local_storage/context.js\";\n\ntype BaseCallbackManagerMethods = {\n  [K in keyof CallbackHandlerMethods]?: (\n    ...args: Parameters<Required<CallbackHandlerMethods>[K]>\n  ) => Promise<unknown>;\n};\n\nexport interface CallbackManagerOptions {\n  verbose?: boolean;\n  tracing?: boolean;\n}\n\nexport type Callbacks =\n  | CallbackManager\n  | (BaseCallbackHandler | CallbackHandlerMethods)[];\n\nexport interface BaseCallbackConfig {\n  /**\n   * Name for the tracer run for this call. Defaults to the name of the class.\n   */\n  runName?: string;\n\n  /**\n   * Tags for this call and any sub-calls (eg. a Chain calling an LLM).\n   * You can use these to filter calls.\n   */\n  tags?: string[];\n\n  /**\n   * Metadata for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Keys should be strings, values should be JSON-serializable.\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * Callbacks for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Tags are passed to all callbacks, metadata is passed to handle*Start callbacks.\n   */\n  callbacks?: Callbacks;\n\n  /**\n   * Unique identifier for the tracer run for this call. If not provided, a new UUID\n   * will be generated.\n   */\n  runId?: string;\n}\n\nexport function parseCallbackConfigArg(\n  arg: Callbacks | BaseCallbackConfig | undefined\n): BaseCallbackConfig {\n  if (!arg) {\n    return {};\n  } else if (Array.isArray(arg) || \"name\" in arg) {\n    return { callbacks: arg };\n  } else {\n    return arg;\n  }\n}\n\n/**\n * Manage callbacks from different components of LangChain.\n */\nexport abstract class BaseCallbackManager {\n  abstract addHandler(handler: BaseCallbackHandler): void;\n\n  abstract removeHandler(handler: BaseCallbackHandler): void;\n\n  abstract setHandlers(handlers: BaseCallbackHandler[]): void;\n\n  setHandler(handler: BaseCallbackHandler): void {\n    return this.setHandlers([handler]);\n  }\n}\n\n/**\n * Base class for run manager in LangChain.\n */\nexport class BaseRunManager {\n  constructor(\n    public readonly runId: string,\n    public readonly handlers: BaseCallbackHandler[],\n    protected readonly inheritableHandlers: BaseCallbackHandler[],\n    protected readonly tags: string[],\n    protected readonly inheritableTags: string[],\n    protected readonly metadata: Record<string, unknown>,\n    protected readonly inheritableMetadata: Record<string, unknown>,\n    protected readonly _parentRunId?: string\n  ) {}\n\n  get parentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleText(text: string): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleText?.(\n              text,\n              this.runId,\n              this._parentRunId,\n              this.tags\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleText: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleCustomEvent(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    _runId?: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleCustomEvent?.(\n              eventName,\n              data,\n              this.runId,\n              this.tags,\n              this.metadata\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * Manages callbacks for retriever runs.\n */\nexport class CallbackManagerForRetrieverRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleRetrieverEnd(documents: DocumentInterface[]): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverEnd?.(\n                documents,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetriever`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleRetrieverError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (error) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForLLMRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  async handleLLMNewToken(\n    token: string,\n    idx?: NewTokenIndices,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMNewToken?.(\n                token,\n                idx ?? { prompt: 0, completion: 0 },\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                fields\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForChainRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleChainError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleChainEnd(\n    output: ChainValues,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentAction(action: AgentAction): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentAction?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentEnd(action: AgentFinish): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentEnd?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForToolRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleToolError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nexport class CallbackManager\n  extends BaseCallbackManager\n  implements BaseCallbackManagerMethods\n{\n  handlers: BaseCallbackHandler[] = [];\n\n  inheritableHandlers: BaseCallbackHandler[] = [];\n\n  tags: string[] = [];\n\n  inheritableTags: string[] = [];\n\n  metadata: Record<string, unknown> = {};\n\n  inheritableMetadata: Record<string, unknown> = {};\n\n  name = \"callback_manager\";\n\n  public _parentRunId?: string;\n\n  constructor(\n    parentRunId?: string,\n    options?: {\n      handlers?: BaseCallbackHandler[];\n      inheritableHandlers?: BaseCallbackHandler[];\n      tags?: string[];\n      inheritableTags?: string[];\n      metadata?: Record<string, unknown>;\n      inheritableMetadata?: Record<string, unknown>;\n    }\n  ) {\n    super();\n    this.handlers = options?.handlers ?? this.handlers;\n    this.inheritableHandlers =\n      options?.inheritableHandlers ?? this.inheritableHandlers;\n    this.tags = options?.tags ?? this.tags;\n    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n    this.metadata = options?.metadata ?? this.metadata;\n    this.inheritableMetadata =\n      options?.inheritableMetadata ?? this.inheritableMetadata;\n    this._parentRunId = parentRunId;\n  }\n\n  /**\n   * Gets the parent run ID, if any.\n   *\n   * @returns The parent run ID.\n   */\n  getParentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      prompts.map(async (prompt, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv4();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForLLMStart(\n                llm,\n                [prompt],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                await handler.handleLLMStart?.(\n                  llm,\n                  [prompt],\n                  runId_,\n                  this._parentRunId,\n                  extraParams,\n                  this.tags,\n                  this.metadata,\n                  runName\n                );\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      messages.map(async (messageGroup, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv4();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForChatModelStart(\n                llm,\n                [messageGroup],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                if (handler.handleChatModelStart) {\n                  await handler.handleChatModelStart?.(\n                    llm,\n                    [messageGroup],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                } else if (handler.handleLLMStart) {\n                  const messageString = getBufferString(messageGroup);\n                  await handler.handleLLMStart?.(\n                    llm,\n                    [messageString],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                }\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId = uuidv4(),\n    runType: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForChainRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreChain) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForChainStart(\n            chain,\n            inputs,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runType,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleChainStart?.(\n              chain,\n              inputs,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runType,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleChainStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForChainRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId = uuidv4(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForToolRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreAgent) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForToolStart(\n            tool,\n            input,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleToolStart?.(\n              tool,\n              input,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleToolStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForToolRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string = uuidv4(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForRetrieverRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreRetriever) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForRetrieverStart(\n            retriever,\n            query,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleRetrieverStart?.(\n              retriever,\n              query,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForRetrieverRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreCustomEvent) {\n            try {\n              await handler.handleCustomEvent?.(\n                eventName,\n                data,\n                runId,\n                this.tags,\n                this.metadata\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  addHandler(handler: BaseCallbackHandler, inherit = true): void {\n    this.handlers.push(handler);\n    if (inherit) {\n      this.inheritableHandlers.push(handler);\n    }\n  }\n\n  removeHandler(handler: BaseCallbackHandler): void {\n    this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n    this.inheritableHandlers = this.inheritableHandlers.filter(\n      (_handler) => _handler !== handler\n    );\n  }\n\n  setHandlers(handlers: BaseCallbackHandler[], inherit = true): void {\n    this.handlers = [];\n    this.inheritableHandlers = [];\n    for (const handler of handlers) {\n      this.addHandler(handler, inherit);\n    }\n  }\n\n  addTags(tags: string[], inherit = true): void {\n    this.removeTags(tags); // Remove duplicates\n    this.tags.push(...tags);\n    if (inherit) {\n      this.inheritableTags.push(...tags);\n    }\n  }\n\n  removeTags(tags: string[]): void {\n    this.tags = this.tags.filter((tag) => !tags.includes(tag));\n    this.inheritableTags = this.inheritableTags.filter(\n      (tag) => !tags.includes(tag)\n    );\n  }\n\n  addMetadata(metadata: Record<string, unknown>, inherit = true): void {\n    this.metadata = { ...this.metadata, ...metadata };\n    if (inherit) {\n      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n    }\n  }\n\n  removeMetadata(metadata: Record<string, unknown>): void {\n    for (const key of Object.keys(metadata)) {\n      delete this.metadata[key];\n      delete this.inheritableMetadata[key];\n    }\n  }\n\n  copy(\n    additionalHandlers: BaseCallbackHandler[] = [],\n    inherit = true\n  ): CallbackManager {\n    const manager = new CallbackManager(this._parentRunId);\n    for (const handler of this.handlers) {\n      const inheritable = this.inheritableHandlers.includes(handler);\n      manager.addHandler(handler, inheritable);\n    }\n    for (const tag of this.tags) {\n      const inheritable = this.inheritableTags.includes(tag);\n      manager.addTags([tag], inheritable);\n    }\n    for (const key of Object.keys(this.metadata)) {\n      const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n    }\n    for (const handler of additionalHandlers) {\n      if (\n        // Prevent multiple copies of console_callback_handler\n        manager.handlers\n          .filter((h) => h.name === \"console_callback_handler\")\n          .some((h) => h.name === handler.name)\n      ) {\n        continue;\n      }\n      manager.addHandler(handler, inherit);\n    }\n    return manager;\n  }\n\n  static fromHandlers(handlers: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuidv4();\n\n      constructor() {\n        super();\n        Object.assign(this, handlers);\n      }\n    }\n\n    const manager = new this();\n    manager.addHandler(new Handler());\n    return manager;\n  }\n\n  static configure(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ): CallbackManager | undefined {\n    return this._configureSync(\n      inheritableHandlers,\n      localHandlers,\n      inheritableTags,\n      localTags,\n      inheritableMetadata,\n      localMetadata,\n      options\n    );\n  }\n\n  // TODO: Deprecate async method in favor of this one.\n  static _configureSync(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ) {\n    let callbackManager: CallbackManager | undefined;\n    if (inheritableHandlers || localHandlers) {\n      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n        callbackManager = new CallbackManager();\n        callbackManager.setHandlers(\n          inheritableHandlers?.map(ensureHandler) ?? [],\n          true\n        );\n      } else {\n        callbackManager = inheritableHandlers;\n      }\n\n      callbackManager = callbackManager.copy(\n        Array.isArray(localHandlers)\n          ? localHandlers.map(ensureHandler)\n          : localHandlers?.handlers,\n        false\n      );\n    }\n\n    const verboseEnabled =\n      getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n      options?.verbose;\n\n    const tracingV2Enabled =\n      LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n      isTracingEnabled();\n\n    const tracingEnabled =\n      tracingV2Enabled ||\n      (getEnvironmentVariable(\"LANGCHAIN_TRACING\") ?? false);\n    if (verboseEnabled || tracingEnabled) {\n      if (!callbackManager) {\n        callbackManager = new CallbackManager();\n      }\n      if (\n        verboseEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === ConsoleCallbackHandler.prototype.name\n        )\n      ) {\n        const consoleHandler = new ConsoleCallbackHandler();\n        callbackManager.addHandler(consoleHandler, true);\n      }\n      if (\n        tracingEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === \"langchain_tracer\"\n        )\n      ) {\n        if (tracingV2Enabled) {\n          const tracerV2 = new LangChainTracer();\n          callbackManager.addHandler(tracerV2, true);\n        }\n      }\n      if (tracingV2Enabled) {\n        // handoff between langchain and langsmith/traceable\n        // override the parent run ID\n        const implicitRunTree = LangChainTracer.getTraceableRunTree();\n        if (implicitRunTree && callbackManager._parentRunId === undefined) {\n          callbackManager._parentRunId = implicitRunTree.id;\n          const tracerV2 = callbackManager.handlers.find(\n            (handler) => handler.name === \"langchain_tracer\"\n          ) as LangChainTracer | undefined;\n          tracerV2?.updateFromRunTree(implicitRunTree);\n        }\n      }\n    }\n\n    for (const {\n      contextVar,\n      inheritable = true,\n      handlerClass,\n      envVar,\n    } of _getConfigureHooks()) {\n      const createIfNotInContext =\n        envVar && getEnvironmentVariable(envVar) === \"true\" && handlerClass;\n      let handler: BaseCallbackHandler | undefined;\n      const contextVarValue =\n        contextVar !== undefined ? getContextVariable(contextVar) : undefined;\n      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {\n        handler = contextVarValue;\n      } else if (createIfNotInContext) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        handler = new (handlerClass as any)({});\n      }\n      if (handler !== undefined) {\n        if (!callbackManager) {\n          callbackManager = new CallbackManager();\n        }\n\n        if (!callbackManager.handlers.some((h) => h.name === handler!.name)) {\n          callbackManager.addHandler(handler, inheritable);\n        }\n      }\n    }\n\n    if (inheritableTags || localTags) {\n      if (callbackManager) {\n        callbackManager.addTags(inheritableTags ?? []);\n        callbackManager.addTags(localTags ?? [], false);\n      }\n    }\n    if (inheritableMetadata || localMetadata) {\n      if (callbackManager) {\n        callbackManager.addMetadata(inheritableMetadata ?? {});\n        callbackManager.addMetadata(localMetadata ?? {}, false);\n      }\n    }\n\n    return callbackManager;\n  }\n}\n\nexport function ensureHandler(\n  handler: BaseCallbackHandler | CallbackHandlerMethods\n): BaseCallbackHandler {\n  if (\"name\" in handler) {\n    return handler;\n  }\n\n  return BaseCallbackHandler.fromMethods(handler);\n}\n"],"mappings":"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"}