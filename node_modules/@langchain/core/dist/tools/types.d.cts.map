{"version":3,"file":"types.d.cts","names":["z","z3","CallbackManagerForToolRun","BaseLangChainParams","ToolDefinition","RunnableConfig","RunnableToolLike","RunnableInterface","DirectToolOutput","ToolCall","ToolMessage","MessageContent","InferInteropZodInput","InferInteropZodOutput","InteropZodType","JSONSchema","ResponseFormat","ToolOutputType","ContentAndArtifact","ToolReturnType","TOutput","TConfig","TInput","ToolInputSchemaBase","ZodTypeAny","ToolParams","ToolRunnableConfig","Record","ConfigurableFieldType","ContextSchema","StructuredToolParams","StructuredToolInterface","Pick","ToolInputSchemaOutputType","T","ToolInputSchemaInputType","StructuredToolCallInput","SchemaT","SchemaInputT","StringInputToolSchema","ZodTypeDef","ZodType","ToolCallInput","ToolOutputT","TArg","Promise","ToolInterface","NonNullable","BaseDynamicToolInput","DynamicToolInput","DynamicStructuredToolInput","SchemaOutputT","isStructuredTool","isRunnableToolLike","isStructuredToolParams","isLangChainTool"],"sources":["../../src/tools/types.d.ts"],"sourcesContent":["import type { z as z3 } from \"zod/v3\";\nimport { CallbackManagerForToolRun } from \"../callbacks/manager.js\";\nimport type { BaseLangChainParams, ToolDefinition } from \"../language_models/base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport { RunnableToolLike, type RunnableInterface } from \"../runnables/base.js\";\nimport { type DirectToolOutput, type ToolCall, type ToolMessage } from \"../messages/tool.js\";\nimport type { MessageContent } from \"../messages/base.js\";\nimport { type InferInteropZodInput, type InferInteropZodOutput, type InteropZodType } from \"../utils/types/zod.js\";\nimport { JSONSchema } from \"../utils/json_schema.js\";\nexport type ResponseFormat = \"content\" | \"content_and_artifact\" | string;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolOutputType = any;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ContentAndArtifact = [MessageContent, any];\n/**\n * Conditional type that determines the return type of the {@link StructuredTool.invoke} method.\n * - If the input is a ToolCall, it returns a ToolMessage\n * - If the config is a runnable config and contains a toolCall property, it returns a ToolMessage\n * - Otherwise, it returns the original output type\n */\nexport type ToolReturnType<TInput, TConfig, TOutput> = TOutput extends DirectToolOutput ? TOutput : TConfig extends {\n    toolCall: {\n        id: string;\n    };\n} ? ToolMessage : TConfig extends {\n    toolCall: {\n        id: undefined;\n    };\n} ? TOutput : TConfig extends {\n    toolCall: {\n        id?: string;\n    };\n} ? TOutput | ToolMessage : TInput extends ToolCall ? ToolMessage : TOutput;\n/**\n * Base type that establishes the types of input schemas that can be used for LangChain tool\n * definitions.\n */\nexport type ToolInputSchemaBase = z3.ZodTypeAny | JSONSchema;\n/**\n * Parameters for the Tool classes.\n */\nexport interface ToolParams extends BaseLangChainParams {\n    /**\n     * The tool response format.\n     *\n     * If \"content\" then the output of the tool is interpreted as the contents of a\n     * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n     * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n     *\n     * @default \"content\"\n     */\n    responseFormat?: ResponseFormat;\n    /**\n     * Default config object for the tool runnable.\n     */\n    defaultConfig?: ToolRunnableConfig;\n    /**\n     * Whether to show full details in the thrown parsing errors.\n     *\n     * @default false\n     */\n    verboseParsingErrors?: boolean;\n    /**\n     * Metadata for the tool.\n     */\n    metadata?: Record<string, unknown>;\n}\nexport type ToolRunnableConfig<\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nConfigurableFieldType extends Record<string, any> = Record<string, any>, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nContextSchema = any> = RunnableConfig<ConfigurableFieldType> & {\n    toolCall?: ToolCall;\n    context?: ContextSchema;\n};\n/**\n * Schema for defining tools.\n *\n * @version 0.2.19\n */\nexport interface StructuredToolParams extends Pick<StructuredToolInterface, \"name\" | \"schema\"> {\n    /**\n     * An optional description of the tool to pass to the model.\n     */\n    description?: string;\n}\n/**\n * Utility type that resolves the output type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaOutputType<T> = T extends InteropZodType ? InferInteropZodOutput<T> : T extends JSONSchema ? unknown : never;\n/**\n * Utility type that resolves the input type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaInputType<T> = T extends InteropZodType ? InferInteropZodInput<T> : T extends JSONSchema ? unknown : never;\n/**\n * Defines the type that will be passed into a tool handler function as a result of a tool call.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport type StructuredToolCallInput<SchemaT = ToolInputSchemaBase, SchemaInputT = ToolInputSchemaInputType<SchemaT>> = (ToolInputSchemaOutputType<SchemaT> extends string ? string : never) | SchemaInputT | ToolCall;\n/**\n * An input schema type for tools that accept a single string input.\n *\n * This schema defines a tool that takes an optional string parameter named \"input\".\n * It uses Zod's effects to transform the input and strip any extra properties.\n *\n * This is primarily used for creating simple string-based tools where the LLM\n * only needs to provide a single text value as input to the tool.\n */\nexport type StringInputToolSchema = z3.ZodType<string | undefined, z3.ZodTypeDef, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nany>;\n/**\n * Defines the type for input to a tool's call method.\n *\n * This type is a convenience alias for StructuredToolCallInput with the input type\n * derived from the schema. It represents the possible inputs that can be passed to a tool,\n * which can be either:\n * - A string (if the tool accepts string input)\n * - A structured input matching the tool's schema\n * - A ToolCall object (typically from an LLM)\n *\n * @param SchemaT - The schema type for the tool input, defaults to StringInputToolSchema\n */\nexport type ToolCallInput<SchemaT = StringInputToolSchema> = StructuredToolCallInput<SchemaT, ToolInputSchemaInputType<SchemaT>>;\n/**\n * Interface that defines the shape of a LangChain structured tool.\n *\n * A structured tool is a tool that uses a schema to define the structure of the arguments that the\n * LLM generates as part of its {@link ToolCall}.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface StructuredToolInterface<SchemaT = ToolInputSchemaBase, SchemaInputT = ToolInputSchemaInputType<SchemaT>, ToolOutputT = ToolOutputType> extends RunnableInterface<StructuredToolCallInput<SchemaT, SchemaInputT>, ToolOutputT | ToolMessage> {\n    lc_namespace: string[];\n    /**\n     * A Zod schema representing the parameters of the tool.\n     */\n    schema: SchemaT;\n    /**\n     * Invokes the tool with the provided argument and configuration.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration for the tool call.\n     * @returns A Promise that resolves with the tool's output.\n     */\n    invoke<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(arg: TArg, configArg?: TConfig): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    call<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(arg: TArg, configArg?: TConfig, \n    /** @deprecated */\n    tags?: string[]): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n    /**\n     * The name of the tool.\n     */\n    name: string;\n    /**\n     * A description of the tool.\n     */\n    description: string;\n    /**\n     * Whether to return the tool's output directly.\n     *\n     * Setting this to true means that after the tool is called,\n     * an agent should stop looping.\n     */\n    returnDirect: boolean;\n}\n/**\n * A special interface for tools that accept a string input, usually defined with the {@link Tool} class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface ToolInterface<SchemaT = StringInputToolSchema, SchemaInputT = ToolInputSchemaInputType<SchemaT>, ToolOutputT = ToolOutputType> extends StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT> {\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    call<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(\n    // TODO: shouldn't this be narrowed based on SchemaT?\n    arg: TArg, callbacks?: TConfig): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>>;\n}\n/**\n * Base interface for the input parameters of the {@link DynamicTool} and\n * {@link DynamicStructuredTool} classes.\n */\nexport interface BaseDynamicToolInput extends ToolParams {\n    name: string;\n    description: string;\n    /**\n     * Whether to return the tool's output directly.\n     *\n     * Setting this to true means that after the tool is called,\n     * an agent should stop looping.\n     */\n    returnDirect?: boolean;\n}\n/**\n * Interface for the input parameters of the DynamicTool class.\n */\nexport interface DynamicToolInput<ToolOutputT = ToolOutputType> extends BaseDynamicToolInput {\n    func: (input: string, runManager?: CallbackManagerForToolRun, config?: ToolRunnableConfig) => Promise<ToolOutputT>;\n}\n/**\n * Interface for the input parameters of the DynamicStructuredTool class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaOutputT - The TypeScript type representing the result of applying the schema to the tool arguments. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface DynamicStructuredToolInput<SchemaT = ToolInputSchemaBase, SchemaOutputT = ToolInputSchemaOutputType<SchemaT>, ToolOutputT = ToolOutputType> extends BaseDynamicToolInput {\n    /**\n     * Tool handler function - the function that will be called when the tool is invoked.\n     *\n     * @param input - The input to the tool.\n     * @param runManager - The run manager for the tool.\n     * @param config - The configuration for the tool.\n     * @returns The result of the tool.\n     */\n    func: (input: SchemaOutputT, runManager?: CallbackManagerForToolRun, config?: RunnableConfig) => Promise<ToolOutputT>;\n    schema: SchemaT;\n}\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nexport declare function isStructuredTool(tool?: StructuredToolInterface | ToolDefinition | JSONSchema): tool is StructuredToolInterface;\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nexport declare function isRunnableToolLike(tool?: unknown): tool is RunnableToolLike;\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nexport declare function isStructuredToolParams(tool?: unknown): tool is StructuredToolParams;\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nexport declare function isLangChainTool(tool?: unknown): tool is StructuredToolParams;\n"],"mappings":"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"}