{"version":3,"file":"tool_executor.js","names":[],"sources":["../../src/prebuilt/tool_executor.ts"],"sourcesContent":["import {\n  RunnableBinding,\n  RunnableConfig,\n  RunnableLambda,\n  RunnableToolLike,\n} from \"@langchain/core/runnables\";\nimport { StructuredToolInterface } from \"@langchain/core/tools\";\n\nconst INVALID_TOOL_MSG_TEMPLATE = `{requestedToolName} is not a valid tool, try one of {availableToolNamesString}.`;\n\n/** @deprecated Use {@link ToolNode} instead. */\nexport interface ToolExecutorArgs {\n  tools: Array<StructuredToolInterface | RunnableToolLike>;\n  /**\n   * @default {INVALID_TOOL_MSG_TEMPLATE}\n   */\n  invalidToolMsgTemplate?: string;\n}\n\n/**\n * Interface for invoking a tool\n */\nexport interface ToolInvocationInterface {\n  tool: string;\n  toolInput: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ToolExecutorInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ToolExecutorOutputType = any;\n\n/** @deprecated Use {@link ToolNode} instead. */\nexport class ToolExecutor extends RunnableBinding<\n  ToolExecutorInputType,\n  ToolExecutorOutputType\n> {\n  lc_graph_name = \"ToolExecutor\";\n\n  tools: Array<StructuredToolInterface | RunnableToolLike>;\n\n  toolMap: Record<string, StructuredToolInterface | RunnableToolLike>;\n\n  invalidToolMsgTemplate: string;\n\n  constructor(fields: ToolExecutorArgs) {\n    const fieldsWithDefaults = {\n      invalidToolMsgTemplate: INVALID_TOOL_MSG_TEMPLATE,\n      ...fields,\n    };\n    const bound = RunnableLambda.from(\n      async (input: ToolInvocationInterface, config?: RunnableConfig) =>\n        this._execute(input, config)\n    );\n    super({\n      bound,\n      config: {},\n    });\n    this.tools = fieldsWithDefaults.tools;\n    this.invalidToolMsgTemplate = fieldsWithDefaults.invalidToolMsgTemplate;\n    this.toolMap = this.tools.reduce((acc, tool) => {\n      acc[tool.name] = tool;\n      return acc;\n    }, {} as Record<string, StructuredToolInterface | RunnableToolLike>);\n  }\n\n  /**\n   * Execute a tool invocation\n   *\n   * @param {ToolInvocationInterface} toolInvocation The tool to invoke and the input to pass to it.\n   * @param {RunnableConfig | undefined} config Optional configuration to pass to the tool when invoked.\n   * @returns Either the result of the tool invocation (`string` or `ToolMessage`, set by the `ToolOutput` generic) or a string error message.\n   */\n  async _execute(\n    toolInvocation: ToolInvocationInterface,\n    config?: RunnableConfig\n  ): Promise<ToolExecutorOutputType> {\n    if (!(toolInvocation.tool in this.toolMap)) {\n      return this.invalidToolMsgTemplate\n        .replace(\"{requestedToolName}\", toolInvocation.tool)\n        .replace(\n          \"{availableToolNamesString}\",\n          Object.keys(this.toolMap).join(\", \")\n        );\n    } else {\n      const tool = this.toolMap[toolInvocation.tool];\n      const output = await tool.invoke(toolInvocation.toolInput, config);\n      return output;\n    }\n  }\n}\n"],"mappings":";;;AAQA,MAAM,4BAA4B;;AA0BlC,IAAa,eAAb,cAAkC,gBAGhC;CACA,gBAAgB;CAEhB;CAEA;CAEA;CAEA,YAAY,QAA0B;EACpC,MAAM,qBAAqB;GACzB,wBAAwB;GACxB,GAAG;;EAEL,MAAM,QAAQ,eAAe,KAC3B,OAAO,OAAgC,WACrC,KAAK,SAAS,OAAO;AAEzB,QAAM;GACJ;GACA,QAAQ;;AAEV,OAAK,QAAQ,mBAAmB;AAChC,OAAK,yBAAyB,mBAAmB;AACjD,OAAK,UAAU,KAAK,MAAM,QAAQ,KAAK,SAAS;AAC9C,OAAI,KAAK,QAAQ;AACjB,UAAO;KACN;;;;;;;;;CAUL,MAAM,SACJ,gBACA,QACiC;AACjC,MAAI,EAAE,eAAe,QAAQ,KAAK,SAChC,QAAO,KAAK,uBACT,QAAQ,uBAAuB,eAAe,MAC9C,QACC,8BACA,OAAO,KAAK,KAAK,SAAS,KAAK;OAE9B;GACL,MAAM,OAAO,KAAK,QAAQ,eAAe;GACzC,MAAM,SAAS,MAAM,KAAK,OAAO,eAAe,WAAW;AAC3D,UAAO"}