{"version":3,"file":"state.js","names":["args","nodeSpec: StateGraphNodeSpec<S, U>","previousNode: N | undefined","name","channels: Record<string, BaseChannel>","outputKeys: string[]","updates: [string, unknown][]","stateWriteEntries: (ChannelWriteTupleEntry | ChannelWriteEntry)[]","writes: (ChannelWriteEntry | Send)[]","input","schema","destinations: (string | Send)[]"],"sources":["../../src/graph/state.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { _coerceToRunnable, Runnable } from \"@langchain/core/runnables\";\nimport {\n  All,\n  type BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  type InteropZodObject,\n  interopParse,\n  interopZodObjectPartial,\n  isInteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport type {\n  RunnableLike,\n  LangGraphRunnableConfig,\n  Runtime,\n} from \"../pregel/runnable_types.js\";\nimport { BaseChannel, isBaseChannel } from \"../channels/base.js\";\nimport {\n  CompiledGraph,\n  Graph,\n  Branch,\n  AddNodeOptions,\n  NodeSpec,\n} from \"./graph.js\";\nimport {\n  ChannelWrite,\n  ChannelWriteEntry,\n  ChannelWriteTupleEntry,\n  PASSTHROUGH,\n} from \"../pregel/write.js\";\nimport { ChannelRead, PregelNode } from \"../pregel/read.js\";\nimport {\n  NamedBarrierValue,\n  NamedBarrierValueAfterFinish,\n} from \"../channels/named_barrier_value.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport {\n  isCommand,\n  _isSend,\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  END,\n  SELF,\n  Send,\n  START,\n  TAG_HIDDEN,\n  CommandInstance,\n  isInterrupted,\n  Interrupt,\n  INTERRUPT,\n} from \"../constants.js\";\nimport { InvalidUpdateError, ParentCommand } from \"../errors.js\";\nimport {\n  AnnotationRoot,\n  getChannel,\n  SingleReducer,\n  StateDefinition,\n  StateType,\n  UpdateType,\n} from \"./annotation.js\";\nimport type { CachePolicy, RetryPolicy } from \"../pregel/utils/index.js\";\nimport { isPregelLike } from \"../pregel/utils/subgraph.js\";\nimport { LastValueAfterFinish } from \"../channels/last_value.js\";\nimport {\n  type SchemaMetaRegistry,\n  InteropZodToStateDefinition,\n  schemaMetaRegistry,\n} from \"./zod/meta.js\";\nimport type {\n  InferInterruptResumeType,\n  InferInterruptInputType,\n} from \"../interrupt.js\";\nimport type { InferWriterType } from \"../writer.js\";\n\nconst ROOT = \"__root__\";\n\nexport type ChannelReducers<Channels extends object> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [K in keyof Channels]: SingleReducer<Channels[K], any>;\n};\n\nexport interface StateGraphArgs<Channels extends object | unknown> {\n  channels: Channels extends object\n    ? Channels extends unknown[]\n      ? ChannelReducers<{ __root__: Channels }>\n      : ChannelReducers<Channels>\n    : ChannelReducers<{ __root__: Channels }>;\n}\n\nexport type StateGraphNodeSpec<RunInput, RunOutput> = NodeSpec<\n  RunInput,\n  RunOutput\n> & {\n  input?: StateDefinition;\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy;\n};\n\nexport type StateGraphAddNodeOptions<Nodes extends string = string> = {\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy | boolean;\n  // TODO: Fix generic typing for annotations\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: AnnotationRoot<any> | InteropZodObject;\n} & AddNodeOptions<Nodes>;\n\nexport type StateGraphArgsWithStateSchema<\n  SD extends StateDefinition,\n  I extends StateDefinition,\n  O extends StateDefinition\n> = {\n  stateSchema: AnnotationRoot<SD>;\n  input?: AnnotationRoot<I>;\n  output?: AnnotationRoot<O>;\n};\n\nexport type StateGraphArgsWithInputOutputSchemas<\n  SD extends StateDefinition,\n  O extends StateDefinition = SD\n> = {\n  input: AnnotationRoot<SD>;\n  output: AnnotationRoot<O>;\n};\n\ntype ZodStateGraphArgsWithStateSchema<\n  SD extends InteropZodObject,\n  I extends SDZod,\n  O extends SDZod\n> = { state: SD; input?: I; output?: O };\n\ntype SDZod = StateDefinition | InteropZodObject;\n\ntype ToStateDefinition<T> = T extends InteropZodObject\n  ? InteropZodToStateDefinition<T>\n  : T extends StateDefinition\n  ? T\n  : never;\n\ntype NodeAction<\n  S,\n  U,\n  C extends SDZod,\n  InterruptType,\n  WriterType\n> = RunnableLike<\n  S,\n  U extends object ? U & Record<string, any> : U, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Runtime<StateType<ToStateDefinition<C>>, InterruptType, WriterType>\n>;\n\ntype StrictNodeAction<\n  S,\n  U,\n  C extends SDZod,\n  Nodes extends string,\n  InterruptType,\n  WriterType\n> = RunnableLike<\n  Prettify<S>,\n  | U\n  | Command<\n      InferInterruptResumeType<InterruptType>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      U & Record<string, any>,\n      Nodes\n    >,\n  Runtime<StateType<ToStateDefinition<C>>, InterruptType, WriterType>\n>;\n\nconst PartialStateSchema = Symbol.for(\"langgraph.state.partial\");\ntype PartialStateSchema = typeof PartialStateSchema;\n\ntype MergeReturnType<Prev, Curr> = Prev & Curr extends infer T\n  ? { [K in keyof T]: T[K] } & unknown\n  : never;\n\ntype Prettify<T> = {\n  [K in keyof T]: T[K];\n  // eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\n/**\n * A graph whose nodes communicate by reading and writing to a shared state.\n * Each node takes a defined `State` as input and returns a `Partial<State>`.\n *\n * Each state key can optionally be annotated with a reducer function that\n * will be used to aggregate the values of that key received from multiple nodes.\n * The signature of a reducer function is (left: Value, right: UpdateValue) => Value.\n *\n * See {@link Annotation} for more on defining state.\n *\n * After adding nodes and edges to your graph, you must call `.compile()` on it before\n * you can use it.\n *\n * @example\n * ```ts\n * import {\n *   type BaseMessage,\n *   AIMessage,\n *   HumanMessage,\n * } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const StateAnnotation = Annotation.Root({\n *   sentiment: Annotation<string>,\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(StateAnnotation);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof StateAnnotation.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *     sentiment: \"positive\",\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   .addEdge(\"__start__\", \"myNode\")\n *   .addEdge(\"myNode\", \"__end__\")\n *   .compile();\n *\n * await graph.invoke({ messages: [new HumanMessage(\"how are you?\")] });\n *\n * // {\n * //   messages: [HumanMessage(\"how are you?\"), AIMessage(\"Some new response\")],\n * //   sentiment: \"positive\",\n * // }\n * ```\n */\nexport class StateGraph<\n  SD extends SDZod | unknown,\n  S = SD extends SDZod ? StateType<ToStateDefinition<SD>> : SD,\n  U = SD extends SDZod ? UpdateType<ToStateDefinition<SD>> : Partial<S>,\n  N extends string = typeof START,\n  I extends SDZod = SD extends SDZod ? ToStateDefinition<SD> : StateDefinition,\n  O extends SDZod = SD extends SDZod ? ToStateDefinition<SD> : StateDefinition,\n  C extends SDZod = StateDefinition,\n  NodeReturnType = unknown,\n  InterruptType = unknown,\n  WriterType = unknown\n> extends Graph<N, S, U, StateGraphNodeSpec<S, U>, ToStateDefinition<C>> {\n  channels: Record<string, BaseChannel> = {};\n\n  // TODO: this doesn't dedupe edges as in py, so worth fixing at some point\n  waitingEdges: Set<[N[], N]> = new Set();\n\n  /** @internal */\n  _schemaDefinition: StateDefinition;\n\n  /** @internal */\n  _schemaRuntimeDefinition: InteropZodObject | undefined;\n\n  /** @internal */\n  _inputDefinition: I;\n\n  /** @internal */\n  _inputRuntimeDefinition: InteropZodObject | PartialStateSchema | undefined;\n\n  /** @internal */\n  _outputDefinition: O;\n\n  /** @internal */\n  _outputRuntimeDefinition: InteropZodObject | undefined;\n\n  /**\n   * Map schemas to managed values\n   * @internal\n   */\n  _schemaDefinitions = new Map();\n\n  /** @internal */\n  _metaRegistry: SchemaMetaRegistry = schemaMetaRegistry;\n\n  /** @internal Used only for typing. */\n  _configSchema: ToStateDefinition<C> | undefined;\n\n  /** @internal */\n  _configRuntimeSchema: InteropZodObject | undefined;\n\n  /** @internal */\n  _interrupt: InterruptType;\n\n  /** @internal */\n  _writer: WriterType;\n\n  declare Node: StrictNodeAction<S, U, C, N, InterruptType, WriterType>;\n\n  constructor(\n    state: SD extends StateDefinition ? AnnotationRoot<SD> : never,\n    options?: {\n      context?: C | AnnotationRoot<ToStateDefinition<C>>;\n      input?: I | AnnotationRoot<ToStateDefinition<I>>;\n      output?: O | AnnotationRoot<ToStateDefinition<O>>;\n\n      interrupt?: InterruptType;\n      writer?: WriterType;\n\n      nodes?: N[];\n    }\n  );\n\n  constructor(\n    state: SD extends InteropZodObject ? SD : never,\n    options?: {\n      context?: C | AnnotationRoot<ToStateDefinition<C>>;\n      input?: I | AnnotationRoot<ToStateDefinition<I>>;\n      output?: O | AnnotationRoot<ToStateDefinition<O>>;\n\n      interrupt?: InterruptType;\n      writer?: WriterType;\n\n      nodes?: N[];\n    }\n  );\n\n  constructor(\n    fields: SD extends StateDefinition\n      ? StateGraphArgsWithInputOutputSchemas<SD, ToStateDefinition<O>>\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    fields: SD extends StateDefinition\n      ?\n          | AnnotationRoot<SD>\n          | StateGraphArgsWithStateSchema<\n              SD,\n              ToStateDefinition<I>,\n              ToStateDefinition<O>\n            >\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  /** @deprecated Use `Annotation.Root` or `zod` for state definition instead. */\n  constructor(\n    fields: SD extends StateDefinition\n      ? SD | StateGraphArgs<S>\n      : StateGraphArgs<S>,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    fields: SD extends InteropZodObject\n      ? SD | ZodStateGraphArgsWithStateSchema<SD, I, O>\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    fields: SD extends InteropZodObject\n      ? SD | ZodStateGraphArgsWithStateSchema<SD, I, O>\n      : SD extends StateDefinition\n      ?\n          | SD\n          | AnnotationRoot<SD>\n          | StateGraphArgs<S>\n          | StateGraphArgsWithStateSchema<\n              SD,\n              ToStateDefinition<I>,\n              ToStateDefinition<O>\n            >\n          | StateGraphArgsWithInputOutputSchemas<SD, ToStateDefinition<O>>\n      : StateGraphArgs<S>,\n    contextSchema?:\n      | C\n      | AnnotationRoot<ToStateDefinition<C>>\n      | {\n          input?: I | AnnotationRoot<ToStateDefinition<I>>;\n          output?: O | AnnotationRoot<ToStateDefinition<O>>;\n          context?: C | AnnotationRoot<ToStateDefinition<C>>;\n          interrupt?: InterruptType;\n          writer?: WriterType;\n          nodes?: N[];\n        }\n  ) {\n    super();\n\n    if (isZodStateGraphArgsWithStateSchema(fields)) {\n      const stateDef = this._metaRegistry.getChannelsForSchema(fields.state);\n      const inputDef =\n        fields.input != null\n          ? this._metaRegistry.getChannelsForSchema(fields.input)\n          : stateDef;\n      const outputDef =\n        fields.output != null\n          ? this._metaRegistry.getChannelsForSchema(fields.output)\n          : stateDef;\n\n      this._schemaDefinition = stateDef;\n      this._schemaRuntimeDefinition = fields.state;\n\n      this._inputDefinition = inputDef as I;\n      this._inputRuntimeDefinition = fields.input ?? PartialStateSchema;\n\n      this._outputDefinition = outputDef as O;\n      this._outputRuntimeDefinition = fields.output ?? fields.state;\n    } else if (isInteropZodObject(fields)) {\n      const stateDef = this._metaRegistry.getChannelsForSchema(fields);\n\n      this._schemaDefinition = stateDef;\n      this._schemaRuntimeDefinition = fields;\n\n      this._inputDefinition = stateDef as I;\n      this._inputRuntimeDefinition = PartialStateSchema;\n\n      this._outputDefinition = stateDef as O;\n      this._outputRuntimeDefinition = fields;\n    } else if (\n      isStateGraphArgsWithInputOutputSchemas<\n        SD extends StateDefinition ? SD : never,\n        O extends StateDefinition ? O : never\n      >(fields)\n    ) {\n      this._schemaDefinition = fields.input.spec;\n      this._inputDefinition = fields.input.spec as unknown as I;\n      this._outputDefinition = fields.output.spec;\n    } else if (isStateGraphArgsWithStateSchema(fields)) {\n      this._schemaDefinition = fields.stateSchema.spec;\n      this._inputDefinition = (fields.input?.spec ??\n        this._schemaDefinition) as I;\n      this._outputDefinition = (fields.output?.spec ??\n        this._schemaDefinition) as O;\n    } else if (isStateDefinition(fields) || isAnnotationRoot(fields)) {\n      const spec = isAnnotationRoot(fields) ? fields.spec : fields;\n      this._schemaDefinition = spec;\n    } else if (isStateGraphArgs(fields)) {\n      const spec = _getChannels(fields.channels);\n      this._schemaDefinition = spec;\n    } else {\n      throw new Error(\n        \"Invalid StateGraph input. Make sure to pass a valid Annotation.Root or Zod schema.\"\n      );\n    }\n\n    this._inputDefinition ??= this._schemaDefinition as I;\n    this._outputDefinition ??= this._schemaDefinition as O;\n\n    this._addSchema(this._schemaDefinition);\n    this._addSchema(this._inputDefinition);\n    this._addSchema(this._outputDefinition);\n\n    function isOptions(options: unknown): options is {\n      context?: C | AnnotationRoot<ToStateDefinition<C>>;\n      input?: I | AnnotationRoot<ToStateDefinition<I>>;\n      output?: O | AnnotationRoot<ToStateDefinition<O>>;\n      interrupt?: InterruptType;\n      writer?: WriterType;\n      nodes?: N[];\n    } {\n      return (\n        typeof options === \"object\" &&\n        options != null &&\n        !(\"spec\" in options) &&\n        !isInteropZodObject(options)\n      );\n    }\n\n    // Handle runtime config options\n    if (isOptions(contextSchema)) {\n      if (isInteropZodObject(contextSchema.context)) {\n        this._configRuntimeSchema = contextSchema.context;\n      }\n      this._interrupt = contextSchema.interrupt as InterruptType;\n      this._writer = contextSchema.writer as WriterType;\n    } else if (isInteropZodObject(contextSchema)) {\n      this._configRuntimeSchema = contextSchema;\n    }\n  }\n\n  get allEdges(): Set<[string, string]> {\n    return new Set([\n      ...this.edges,\n      ...Array.from(this.waitingEdges).flatMap(([starts, end]) =>\n        starts.map((start) => [start, end] as [string, string])\n      ),\n    ]);\n  }\n\n  _addSchema(stateDefinition: SDZod) {\n    if (this._schemaDefinitions.has(stateDefinition)) {\n      return;\n    }\n    // TODO: Support managed values\n    this._schemaDefinitions.set(stateDefinition, stateDefinition);\n    for (const [key, val] of Object.entries(stateDefinition)) {\n      let channel;\n      if (typeof val === \"function\") {\n        channel = val();\n      } else {\n        channel = val;\n      }\n      if (this.channels[key] !== undefined) {\n        if (this.channels[key] !== channel) {\n          if (channel.lc_graph_name !== \"LastValue\") {\n            throw new Error(\n              `Channel \"${key}\" already exists with a different type.`\n            );\n          }\n        }\n      } else {\n        this.channels[key] = channel;\n      }\n    }\n  }\n\n  override addNode<\n    K extends string,\n    NodeMap extends Record<K, NodeAction<S, U, C, InterruptType, WriterType>>\n  >(\n    nodes: NodeMap\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<\n      NodeReturnType,\n      {\n        [key in keyof NodeMap]: NodeMap[key] extends NodeAction<\n          S,\n          infer U,\n          C,\n          InterruptType,\n          WriterType\n        >\n          ? U\n          : never;\n      }\n    >\n  >;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ][]\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    key: K,\n    action: NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>,\n    options?: StateGraphAddNodeOptions\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<K extends string, NodeInput = S>(\n    key: K,\n    action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n    options?: StateGraphAddNodeOptions\n  ): StateGraph<SD, S, U, N | K, I, O, C, NodeReturnType>;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    ...args:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ]\n      | [\n          nodes:\n            | Record<K, NodeAction<NodeInput, U, C, InterruptType, WriterType>>\n            | [\n                key: K,\n                action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n                options?: StateGraphAddNodeOptions\n              ][]\n        ]\n  ): StateGraph<SD, S, U, N | K, I, O, C> {\n    function isMultipleNodes(\n      args: unknown[]\n    ): args is [\n      nodes:\n        | Record<K, NodeAction<NodeInput, U, C, InterruptType, WriterType>>\n        | [\n            key: K,\n            action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n            options?: AddNodeOptions\n          ][]\n    ] {\n      return args.length >= 1 && typeof args[0] !== \"string\";\n    }\n\n    const nodes = (\n      isMultipleNodes(args) // eslint-disable-line no-nested-ternary\n        ? Array.isArray(args[0])\n          ? args[0]\n          : Object.entries(args[0]).map(([key, action]) => [key, action])\n        : [[args[0], args[1], args[2]]]\n    ) as [\n      K,\n      NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n      StateGraphAddNodeOptions | undefined\n    ][];\n\n    if (nodes.length === 0) {\n      throw new Error(\"No nodes provided in `addNode`\");\n    }\n\n    for (const [key, action, options] of nodes) {\n      if (key in this.channels) {\n        throw new Error(\n          `${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`\n        );\n      }\n\n      for (const reservedChar of [\n        CHECKPOINT_NAMESPACE_SEPARATOR,\n        CHECKPOINT_NAMESPACE_END,\n      ]) {\n        if (key.includes(reservedChar)) {\n          throw new Error(\n            `\"${reservedChar}\" is a reserved character and is not allowed in node names.`\n          );\n        }\n      }\n      this.warnIfCompiled(\n        `Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n      );\n\n      if (key in this.nodes) {\n        throw new Error(`Node \\`${key}\\` already present.`);\n      }\n      if (key === END || key === START) {\n        throw new Error(`Node \\`${key}\\` is reserved.`);\n      }\n\n      let inputSpec = this._schemaDefinition;\n      if (options?.input !== undefined) {\n        if (isInteropZodObject(options.input)) {\n          inputSpec = this._metaRegistry.getChannelsForSchema(options.input);\n        } else if (options.input.spec !== undefined) {\n          inputSpec = options.input.spec;\n        }\n      }\n      if (inputSpec !== undefined) {\n        this._addSchema(inputSpec);\n      }\n\n      let runnable;\n      if (Runnable.isRunnable(action)) {\n        runnable = action;\n      } else if (typeof action === \"function\") {\n        runnable = new RunnableCallable({\n          func: action,\n          name: key,\n          trace: false,\n        });\n      } else {\n        runnable = _coerceToRunnable(action);\n      }\n\n      let cachePolicy = options?.cachePolicy;\n      if (typeof cachePolicy === \"boolean\") {\n        cachePolicy = cachePolicy ? {} : undefined;\n      }\n\n      const nodeSpec: StateGraphNodeSpec<S, U> = {\n        runnable: runnable as unknown as Runnable<S, U>,\n        retryPolicy: options?.retryPolicy,\n        cachePolicy,\n        metadata: options?.metadata,\n        input: inputSpec ?? this._schemaDefinition,\n        subgraphs: isPregelLike(runnable)\n          ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            [runnable as any]\n          : options?.subgraphs,\n        ends: options?.ends,\n        defer: options?.defer,\n      };\n\n      this.nodes[key as unknown as N] = nodeSpec;\n    }\n\n    return this as StateGraph<SD, S, U, N | K, I, O, C>;\n  }\n\n  override addEdge(\n    startKey: typeof START | N | N[],\n    endKey: N | typeof END\n  ): this {\n    if (typeof startKey === \"string\") {\n      return super.addEdge(startKey, endKey);\n    }\n\n    if (this.compiled) {\n      console.warn(\n        \"Adding an edge to a graph that has already been compiled. This will \" +\n          \"not be reflected in the compiled graph.\"\n      );\n    }\n\n    for (const start of startKey) {\n      if (start === END) {\n        throw new Error(\"END cannot be a start node\");\n      }\n      if (!Object.keys(this.nodes).some((node) => node === start)) {\n        throw new Error(`Need to add a node named \"${start}\" first`);\n      }\n    }\n    if (endKey === END) {\n      throw new Error(\"END cannot be an end node\");\n    }\n    if (!Object.keys(this.nodes).some((node) => node === endKey)) {\n      throw new Error(`Need to add a node named \"${endKey}\" first`);\n    }\n\n    this.waitingEdges.add([startKey, endKey]);\n\n    return this;\n  }\n\n  addSequence<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes: [\n      key: K,\n      action: NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>,\n      options?: StateGraphAddNodeOptions\n    ][]\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  addSequence<\n    K extends string,\n    NodeMap extends Record<K, NodeAction<S, U, C, InterruptType, WriterType>>\n  >(\n    nodes: NodeMap\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<\n      NodeReturnType,\n      {\n        [key in keyof NodeMap]: NodeMap[key] extends NodeAction<\n          S,\n          infer U,\n          C,\n          InterruptType,\n          WriterType\n        >\n          ? U\n          : never;\n      }\n    >\n  >;\n\n  addSequence<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ][]\n      | Record<\n          K,\n          NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>\n        >\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  > {\n    const parsedNodes = Array.isArray(nodes) ? nodes : Object.entries(nodes);\n\n    if (parsedNodes.length === 0) {\n      throw new Error(\"Sequence requires at least one node.\");\n    }\n\n    let previousNode: N | undefined;\n    for (const [key, action, options] of parsedNodes) {\n      if (key in this.nodes) {\n        throw new Error(\n          `Node names must be unique: node with the name \"${key}\" already exists.`\n        );\n      }\n\n      const validKey = key as unknown as N;\n      this.addNode(\n        validKey,\n        action as NodeAction<S, U, C, InterruptType, WriterType>,\n        options\n      );\n      if (previousNode != null) {\n        this.addEdge(previousNode, validKey);\n      }\n\n      previousNode = validKey;\n    }\n\n    return this as StateGraph<\n      SD,\n      S,\n      U,\n      N | K,\n      I,\n      O,\n      C,\n      MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n    >;\n  }\n\n  override compile({\n    checkpointer,\n    store,\n    cache,\n    interruptBefore,\n    interruptAfter,\n    name,\n    description,\n  }: {\n    checkpointer?: BaseCheckpointSaver | boolean;\n    store?: BaseStore;\n    cache?: BaseCache;\n    interruptBefore?: N[] | All;\n    interruptAfter?: N[] | All;\n    name?: string;\n    description?: string;\n  } = {}): CompiledStateGraph<\n    Prettify<S>,\n    Prettify<U>,\n    N,\n    I,\n    O,\n    C,\n    NodeReturnType,\n    InterruptType,\n    WriterType\n  > {\n    // validate the graph\n    this.validate([\n      ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n      ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n    ]);\n\n    // prepare output channels\n    const outputKeys = Object.keys(\n      this._schemaDefinitions.get(this._outputDefinition)\n    );\n    const outputChannels =\n      outputKeys.length === 1 && outputKeys[0] === ROOT ? ROOT : outputKeys;\n\n    const streamKeys = Object.keys(this.channels);\n    const streamChannels =\n      streamKeys.length === 1 && streamKeys[0] === ROOT ? ROOT : streamKeys;\n\n    const userInterrupt = this._interrupt;\n    // create empty compiled graph\n    const compiled = new CompiledStateGraph<\n      S,\n      U,\n      N,\n      I,\n      O,\n      C,\n      NodeReturnType,\n      InterruptType,\n      WriterType\n    >({\n      builder: this,\n      checkpointer,\n      interruptAfter,\n      interruptBefore,\n      autoValidate: false,\n      nodes: {} as Record<N | typeof START, PregelNode<S, U>>,\n      channels: {\n        ...this.channels,\n        [START]: new EphemeralValue(),\n      } as Record<N | typeof START | typeof END | string, BaseChannel>,\n      inputChannels: START,\n      outputChannels,\n      streamChannels,\n      streamMode: \"updates\",\n      store,\n      cache,\n      name,\n      description,\n      userInterrupt,\n    });\n\n    // attach nodes, edges and branches\n    compiled.attachNode(START);\n    for (const [key, node] of Object.entries<StateGraphNodeSpec<S, U>>(\n      this.nodes\n    )) {\n      compiled.attachNode(key as N, node);\n    }\n    compiled.attachBranch(START, SELF, _getControlBranch() as Branch<S, N>, {\n      withReader: false,\n    });\n    for (const [key] of Object.entries<StateGraphNodeSpec<S, U>>(this.nodes)) {\n      compiled.attachBranch(\n        key as N,\n        SELF,\n        _getControlBranch() as Branch<S, N>,\n        {\n          withReader: false,\n        }\n      );\n    }\n    for (const [start, end] of this.edges) {\n      compiled.attachEdge(start, end);\n    }\n    for (const [starts, end] of this.waitingEdges) {\n      compiled.attachEdge(starts, end);\n    }\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const [name, branch] of Object.entries(branches)) {\n        compiled.attachBranch(start as N, name, branch);\n      }\n    }\n\n    return compiled.validate();\n  }\n}\n\nfunction _getChannels<Channels extends Record<string, unknown> | unknown>(\n  schema: StateGraphArgs<Channels>[\"channels\"]\n): Record<string, BaseChannel> {\n  const channels: Record<string, BaseChannel> = {};\n  for (const [name, val] of Object.entries(schema)) {\n    if (name === ROOT) {\n      channels[name] = getChannel<Channels>(val as SingleReducer<Channels>);\n    } else {\n      const key = name as keyof Channels;\n      channels[name] = getChannel<Channels[typeof key]>(\n        val as SingleReducer<Channels[typeof key]>\n      );\n    }\n  }\n  return channels;\n}\n\n/**\n * Final result from building and compiling a {@link StateGraph}.\n * Should not be instantiated directly, only using the StateGraph `.compile()`\n * instance method.\n */\nexport class CompiledStateGraph<\n  S,\n  U,\n  N extends string = typeof START,\n  I extends SDZod = StateDefinition,\n  O extends SDZod = StateDefinition,\n  C extends SDZod = StateDefinition,\n  NodeReturnType = unknown,\n  InterruptType = unknown,\n  WriterType = unknown\n> extends CompiledGraph<\n  N,\n  S,\n  U,\n  StateType<ToStateDefinition<C>>,\n  UpdateType<ToStateDefinition<I>>,\n  StateType<ToStateDefinition<O>>,\n  NodeReturnType,\n  CommandInstance<InferInterruptResumeType<InterruptType>, Prettify<U>, N>,\n  InferWriterType<WriterType>\n> {\n  declare builder: StateGraph<unknown, S, U, N, I, O, C, NodeReturnType>;\n\n  /**\n   * The description of the compiled graph.\n   * This is used by the supervisor agent to describe the handoff to the agent.\n   */\n  description?: string;\n\n  /** @internal */\n  _metaRegistry: SchemaMetaRegistry = schemaMetaRegistry;\n\n  constructor({\n    description,\n    ...rest\n  }: { description?: string } & ConstructorParameters<\n    typeof CompiledGraph<\n      N,\n      S,\n      U,\n      StateType<ToStateDefinition<C>>,\n      UpdateType<ToStateDefinition<I>>,\n      StateType<ToStateDefinition<O>>,\n      NodeReturnType,\n      CommandInstance<InferInterruptResumeType<InterruptType>, Prettify<U>, N>,\n      InferWriterType<WriterType>\n    >\n  >[0]) {\n    super(rest);\n    this.description = description;\n  }\n\n  attachNode(key: typeof START, node?: never): void;\n\n  attachNode(key: N, node: StateGraphNodeSpec<S, U>): void;\n\n  attachNode(key: N | typeof START, node?: StateGraphNodeSpec<S, U>): void {\n    let outputKeys: string[];\n    if (key === START) {\n      // Get input schema keys excluding managed values\n      outputKeys = Object.entries(\n        this.builder._schemaDefinitions.get(this.builder._inputDefinition)\n      ).map(([k]) => k);\n    } else {\n      outputKeys = Object.keys(this.builder.channels);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _getRoot(input: unknown): [string, any][] | null {\n      if (isCommand(input)) {\n        if (input.graph === Command.PARENT) {\n          return null;\n        }\n        return input._updateAsTuples();\n      } else if (\n        Array.isArray(input) &&\n        input.length > 0 &&\n        input.some((i) => isCommand(i))\n      ) {\n        const updates: [string, unknown][] = [];\n        for (const i of input) {\n          if (isCommand(i)) {\n            if (i.graph === Command.PARENT) {\n              continue;\n            }\n            updates.push(...i._updateAsTuples());\n          } else {\n            updates.push([ROOT, i]);\n          }\n        }\n        return updates;\n      } else if (input != null) {\n        return [[ROOT, input]];\n      }\n      return null;\n    }\n\n    // to avoid name collision below\n    const nodeKey = key;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _getUpdates(input: U): [string, any][] | null {\n      if (!input) {\n        return null;\n      } else if (isCommand(input)) {\n        if (input.graph === Command.PARENT) {\n          return null;\n        }\n        return input._updateAsTuples().filter(([k]) => outputKeys.includes(k));\n      } else if (\n        Array.isArray(input) &&\n        input.length > 0 &&\n        input.some(isCommand)\n      ) {\n        const updates: [string, unknown][] = [];\n        for (const item of input) {\n          if (isCommand(item)) {\n            if (item.graph === Command.PARENT) {\n              continue;\n            }\n            updates.push(\n              ...item._updateAsTuples().filter(([k]) => outputKeys.includes(k))\n            );\n          } else {\n            const itemUpdates = _getUpdates(item);\n            if (itemUpdates) {\n              updates.push(...(itemUpdates ?? []));\n            }\n          }\n        }\n        return updates;\n      } else if (typeof input === \"object\" && !Array.isArray(input)) {\n        return Object.entries(input).filter(([k]) => outputKeys.includes(k));\n      } else {\n        const typeofInput = Array.isArray(input) ? \"array\" : typeof input;\n        throw new InvalidUpdateError(\n          `Expected node \"${nodeKey.toString()}\" to return an object or an array containing at least one Command object, received ${typeofInput}`,\n          {\n            lc_error_code: \"INVALID_GRAPH_NODE_RETURN_VALUE\",\n          }\n        );\n      }\n    }\n\n    const stateWriteEntries: (ChannelWriteTupleEntry | ChannelWriteEntry)[] = [\n      {\n        value: PASSTHROUGH,\n        mapper: new RunnableCallable({\n          func:\n            outputKeys.length && outputKeys[0] === ROOT\n              ? _getRoot\n              : _getUpdates,\n          trace: false,\n          recurse: false,\n        }),\n      },\n    ];\n\n    // add node and output channel\n    if (key === START) {\n      this.nodes[key] = new PregelNode<S, U>({\n        tags: [TAG_HIDDEN],\n        triggers: [START],\n        channels: [START],\n        writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],\n      });\n    } else {\n      const inputDefinition = node?.input ?? this.builder._schemaDefinition;\n      const inputValues = Object.fromEntries(\n        Object.keys(this.builder._schemaDefinitions.get(inputDefinition)).map(\n          (k) => [k, k]\n        )\n      );\n      const isSingleInput =\n        Object.keys(inputValues).length === 1 && ROOT in inputValues;\n      const branchChannel = `branch:to:${key}` as string | N;\n      this.channels[branchChannel] = node?.defer\n        ? new LastValueAfterFinish()\n        : new EphemeralValue(false);\n      this.nodes[key] = new PregelNode<S, U>({\n        triggers: [branchChannel],\n        // read state keys\n        channels: isSingleInput ? Object.keys(inputValues) : inputValues,\n        // publish to state keys\n        writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],\n        mapper: isSingleInput\n          ? undefined\n          : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (input: Record<string, any>) => {\n              return Object.fromEntries(\n                Object.entries(input).filter(([k]) => k in inputValues)\n              );\n            },\n        bound: node?.runnable,\n        metadata: node?.metadata,\n        retryPolicy: node?.retryPolicy,\n        cachePolicy: node?.cachePolicy,\n        subgraphs: node?.subgraphs,\n        ends: node?.ends,\n      });\n    }\n  }\n\n  attachEdge(starts: N | N[] | \"__start__\", end: N | \"__end__\"): void {\n    if (end === END) return;\n    if (typeof starts === \"string\") {\n      this.nodes[starts].writers.push(\n        new ChannelWrite(\n          [{ channel: `branch:to:${end}`, value: null }],\n          [TAG_HIDDEN]\n        )\n      );\n    } else if (Array.isArray(starts)) {\n      const channelName = `join:${starts.join(\"+\")}:${end}`;\n      // register channel\n      this.channels[channelName as string | N] = this.builder.nodes[end].defer\n        ? new NamedBarrierValueAfterFinish(new Set(starts))\n        : new NamedBarrierValue(new Set(starts));\n      // subscribe to channel\n      this.nodes[end].triggers.push(channelName);\n      // publish to channel\n      for (const start of starts) {\n        this.nodes[start].writers.push(\n          new ChannelWrite(\n            [{ channel: channelName, value: start }],\n            [TAG_HIDDEN]\n          )\n        );\n      }\n    }\n  }\n\n  attachBranch(\n    start: N | typeof START,\n    _: string,\n    branch: Branch<S, N>,\n    options: { withReader?: boolean } = { withReader: true }\n  ): void {\n    const branchWriter = async (\n      packets: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => {\n      const filteredPackets = packets.filter((p) => p !== END);\n      if (!filteredPackets.length) return;\n\n      const writes: (ChannelWriteEntry | Send)[] = filteredPackets.map((p) => {\n        if (_isSend(p)) return p;\n        return { channel: p === END ? p : `branch:to:${p}`, value: start };\n      });\n      await ChannelWrite.doWrite(\n        { ...config, tags: (config.tags ?? []).concat([TAG_HIDDEN]) },\n        writes\n      );\n    };\n    // attach branch publisher\n    this.nodes[start].writers.push(\n      branch.run(\n        branchWriter,\n        // reader\n        options.withReader\n          ? (config) =>\n              ChannelRead.doRead<S>(\n                config,\n                this.streamChannels ?? this.outputChannels,\n                true\n              )\n          : undefined\n      )\n    );\n  }\n\n  protected async _validateInput(\n    input: UpdateType<ToStateDefinition<I>>\n  ): Promise<UpdateType<ToStateDefinition<I>>> {\n    if (input == null) return input;\n\n    const schema = (() => {\n      const input = this.builder._inputRuntimeDefinition;\n      const schema = this.builder._schemaRuntimeDefinition;\n\n      const apply = (schema: InteropZodObject | undefined) => {\n        if (schema == null) return undefined;\n        return this._metaRegistry.getExtendedChannelSchemas(schema, {\n          withReducerSchema: true,\n        });\n      };\n\n      if (isInteropZodObject(input)) return apply(input);\n      if (input === PartialStateSchema) {\n        return interopZodObjectPartial(apply(schema)!);\n      }\n      return undefined;\n    })();\n\n    if (isCommand(input)) {\n      const parsedInput = input;\n      if (input.update && schema != null)\n        parsedInput.update = interopParse(schema, input.update);\n      return parsedInput;\n    }\n    if (schema != null) return interopParse(schema, input);\n    return input;\n  }\n\n  public isInterrupted(input: unknown): input is {\n    [INTERRUPT]: Interrupt<InferInterruptInputType<InterruptType>>[];\n  } {\n    return isInterrupted(input);\n  }\n\n  protected async _validateContext(\n    config: Partial<Record<string, unknown>>\n  ): Promise<Partial<Record<string, unknown>>> {\n    const configSchema = this.builder._configRuntimeSchema;\n    if (isInteropZodObject(configSchema)) interopParse(configSchema, config);\n    return config;\n  }\n}\n\nfunction isStateDefinition(obj: unknown): obj is StateDefinition {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    !Array.isArray(obj) &&\n    Object.keys(obj).length > 0 &&\n    Object.values(obj).every((v) => typeof v === \"function\" || isBaseChannel(v))\n  );\n}\n\nfunction isAnnotationRoot<SD extends StateDefinition>(\n  obj: unknown | AnnotationRoot<SD>\n): obj is AnnotationRoot<SD> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"lc_graph_name\" in obj &&\n    obj.lc_graph_name === \"AnnotationRoot\"\n  );\n}\n\nfunction isStateGraphArgs<Channels extends object | unknown>(\n  obj: unknown | StateGraphArgs<Channels>\n): obj is StateGraphArgs<Channels> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    (obj as StateGraphArgs<Channels>).channels !== undefined\n  );\n}\n\nfunction isStateGraphArgsWithStateSchema<\n  SD extends StateDefinition,\n  I extends StateDefinition,\n  O extends StateDefinition\n>(\n  obj: unknown | StateGraphArgsWithStateSchema<SD, I, O>\n): obj is StateGraphArgsWithStateSchema<SD, I, O> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    (obj as StateGraphArgsWithStateSchema<SD, I, O>).stateSchema !== undefined\n  );\n}\n\nfunction isStateGraphArgsWithInputOutputSchemas<\n  SD extends StateDefinition,\n  O extends StateDefinition\n>(\n  obj: unknown | StateGraphArgsWithInputOutputSchemas<SD, O>\n): obj is StateGraphArgsWithInputOutputSchemas<SD, O> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (obj as any).stateSchema === undefined &&\n    (obj as StateGraphArgsWithInputOutputSchemas<SD, O>).input !== undefined &&\n    (obj as StateGraphArgsWithInputOutputSchemas<SD, O>).output !== undefined\n  );\n}\n\nfunction isZodStateGraphArgsWithStateSchema<\n  SD extends InteropZodObject,\n  I extends InteropZodObject,\n  O extends InteropZodObject\n>(value: unknown): value is ZodStateGraphArgsWithStateSchema<SD, I, O> {\n  if (typeof value !== \"object\" || value == null) {\n    return false;\n  }\n\n  if (!(\"state\" in value) || !isInteropZodObject(value.state)) {\n    return false;\n  }\n\n  if (\"input\" in value && !isInteropZodObject(value.input)) {\n    return false;\n  }\n\n  if (\"output\" in value && !isInteropZodObject(value.output)) {\n    return false;\n  }\n\n  return true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _controlBranch(value: any): (string | Send)[] {\n  if (_isSend(value)) {\n    return [value];\n  }\n  const commands = [];\n  if (isCommand(value)) {\n    commands.push(value);\n  } else if (Array.isArray(value)) {\n    commands.push(...value.filter(isCommand));\n  }\n  const destinations: (string | Send)[] = [];\n\n  for (const command of commands) {\n    if (command.graph === Command.PARENT) {\n      throw new ParentCommand(command);\n    }\n\n    if (_isSend(command.goto)) {\n      destinations.push(command.goto);\n    } else if (typeof command.goto === \"string\") {\n      destinations.push(command.goto);\n    } else {\n      if (Array.isArray(command.goto)) {\n        destinations.push(...command.goto);\n      }\n    }\n  }\n  return destinations;\n}\n\nfunction _getControlBranch() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const CONTROL_BRANCH_PATH = new RunnableCallable<any, (string | Send)[]>({\n    func: _controlBranch,\n    tags: [TAG_HIDDEN],\n    trace: false,\n    recurse: false,\n    name: \"<control_branch>\",\n  });\n  return new Branch({\n    path: CONTROL_BRANCH_PATH,\n  });\n}\n"],"mappings":"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"}