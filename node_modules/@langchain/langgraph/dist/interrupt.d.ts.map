{"version":3,"file":"interrupt.d.ts","names":["interrupt","I","R","FilterAny","T","X","InferInterruptInputType","K","InferInterruptResumeType","TInner"],"sources":["../src/interrupt.d.ts"],"sourcesContent":["/**\n * Interrupts the execution of a graph node.\n * This function can be used to pause execution of a node, and return the value of the `resume`\n * input when the graph is re-invoked using `Command`.\n * Multiple interrupts can be called within a single node, and each will be handled sequentially.\n *\n * When an interrupt is called:\n * 1. If there's a `resume` value available (from a previous `Command`), it returns that value.\n * 2. Otherwise, it throws a `GraphInterrupt` with the provided value\n * 3. The graph can be resumed by passing a `Command` with a `resume` value\n *\n * Because the `interrupt` function propagates by throwing a special `GraphInterrupt` error,\n * you should avoid using `try/catch` blocks around the `interrupt` function,\n * or if you do, ensure that the `GraphInterrupt` error is thrown again within your `catch` block.\n *\n * @param value - The value to include in the interrupt. This will be available in task.interrupts[].value\n * @returns The `resume` value provided when the graph is re-invoked with a Command\n *\n * @example\n * ```typescript\n * // Define a node that uses multiple interrupts\n * const nodeWithInterrupts = () => {\n *   // First interrupt - will pause execution and include {value: 1} in task values\n *   const answer1 = interrupt({ value: 1 });\n *\n *   // Second interrupt - only called after first interrupt is resumed\n *   const answer2 = interrupt({ value: 2 });\n *\n *   // Use the resume values\n *   return { myKey: answer1 + \" \" + answer2 };\n * };\n *\n * // Resume the graph after first interrupt\n * await graph.stream(new Command({ resume: \"answer 1\" }));\n *\n * // Resume the graph after second interrupt\n * await graph.stream(new Command({ resume: \"answer 2\" }));\n * // Final result: { myKey: \"answer 1 answer 2\" }\n * ```\n *\n * @throws {Error} If called outside the context of a graph\n * @throws {GraphInterrupt} When no resume value is available\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport declare function interrupt<I = unknown, R = any>(value: I): R;\ntype FilterAny<X> = (<T>() => T extends X ? 1 : 2) extends <T\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n>() => (T extends any ? 1 : 2) ? never : X;\nexport type InferInterruptInputType<T> = T extends typeof interrupt<infer I, unknown> ? I : T extends {\n    [key: string]: typeof interrupt<any, any>;\n} ? {\n    [K in keyof T]: InferInterruptInputType<T[K]>;\n}[keyof T] : unknown;\nexport type InferInterruptResumeType<T, TInner = false> = T extends typeof interrupt<never, infer R> ? TInner extends true ? FilterAny<R> : R : T extends {\n    [key: string]: typeof interrupt<any, any>;\n} ? {\n    [K in keyof T]: InferInterruptResumeType<T[K], true>;\n}[keyof T] : unknown;\nexport {};\n"],"mappings":";;AA4CA;;;;;AAAqE;;;;;;;AAIrE;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;iBATwBA,uCAAuCC,IAAIC;KAC9DC,yBAAyBC,UAAUC;;QAEhCD,kCAAiCC;KAC7BC,6BAA6BF,iBAAiBJ,8BAA8BC,IAAIG;wBAClEJ;kBAEVI,IAAIE,wBAAwBF,EAAEG,YACtCH;KACII,8CAA8CJ,iBAAiBJ,4BAA4BS,sBAAsBN,UAAUD,KAAKA,IAAIE;wBACtHJ;kBAEVI,IAAII,yBAAyBJ,EAAEG,kBACvCH"}