{"version":3,"file":"base.d.cts","names":["ReadonlyCheckpoint","Checkpoint","isBaseChannel","BaseChannel","ValueType","UpdateType","CheckpointType","getOnlyChannels","Record","emptyChannels","Cc","createCheckpoint"],"sources":["../../src/channels/base.d.ts"],"sourcesContent":["import { ReadonlyCheckpoint, Checkpoint } from \"@langchain/langgraph-checkpoint\";\nexport declare function isBaseChannel(obj: unknown): obj is BaseChannel;\n/** @internal */\nexport declare abstract class BaseChannel<ValueType = unknown, UpdateType = unknown, CheckpointType = unknown> {\n    ValueType: ValueType;\n    UpdateType: UpdateType;\n    /**\n     * The name of the channel.\n     */\n    abstract lc_graph_name: string;\n    /** @ignore */\n    lg_is_channel: boolean;\n    /**\n     * Return a new identical channel, optionally initialized from a checkpoint.\n     * Can be thought of as a \"restoration\" from a checkpoint which is a \"snapshot\" of the channel's state.\n     *\n     * @param {CheckpointType | undefined} checkpoint\n     * @param {CheckpointType | undefined} initialValue\n     * @returns {this}\n     */\n    abstract fromCheckpoint(checkpoint?: CheckpointType): this;\n    /**\n     * Update the channel's value with the given sequence of updates.\n     * The order of the updates in the sequence is arbitrary.\n     * This method is called by Pregel for all channels at the end of each step.\n     * If there are no updates, it is called with an empty sequence.\n     *\n     * Raises InvalidUpdateError if the sequence of updates is invalid.\n     * Returns True if the channel was updated, False otherwise.\n     *\n     * @throws {InvalidUpdateError} if the sequence of updates is invalid.\n     * @param {Array<UpdateType>} values\n     * @returns {void}\n     */\n    abstract update(values: UpdateType[]): boolean;\n    /**\n     * Return the current value of the channel.\n     *\n     * @throws {EmptyChannelError} if the channel is empty (never updated yet).\n     * @returns {ValueType}\n     */\n    abstract get(): ValueType;\n    /**\n     * Return a string representation of the channel's current state.\n     *\n     * @throws {EmptyChannelError} if the channel is empty (never updated yet), or doesn't support checkpoints.\n     * @returns {CheckpointType | undefined}\n     */\n    abstract checkpoint(): CheckpointType | undefined;\n    /**\n     * Mark the current value of the channel as consumed. By default, no-op.\n     * A channel can use this method to modify its state, preventing the value\n     * from being consumed again.\n     *\n     * Returns True if the channel was updated, False otherwise.\n     */\n    consume(): boolean;\n    /**\n     * Notify the channel that the Pregel run is finishing. By default, no-op.\n     * A channel can use this method to modify its state, preventing finish.\n     *\n     * Returns True if the channel was updated, False otherwise.\n     */\n    finish(): boolean;\n    /**\n     * Return True if the channel is available (not empty), False otherwise.\n     * Subclasses should override this method to provide a more efficient\n     * implementation than calling get() and catching EmptyChannelError.\n     */\n    isAvailable(): boolean;\n}\nexport declare function getOnlyChannels(channels: Record<string, BaseChannel>): Record<string, BaseChannel>;\nexport declare function emptyChannels<Cc extends Record<string, BaseChannel>>(channels: Cc, checkpoint: ReadonlyCheckpoint): Cc;\nexport declare function createCheckpoint<ValueType>(checkpoint: ReadonlyCheckpoint, channels: Record<string, BaseChannel<ValueType>> | undefined, step: number, options?: {\n    id?: string;\n}): Checkpoint;\n"],"mappings":";;;;AAG8BG,uBAAAA,WAAW,CAAA,YAAA,OAAA,EAAA,aAAA,OAAA,EAAA,iBAAA,OAAA,CAAA,CAAA;EAAA,SAAA,EAC1BC,SAD0B;YAC1BA,EACCC,UADDD;;;;WAqCKA,aAAAA,EAAAA,MAAAA;;;EA+BIK;;;;;;;;EACAE,SAAAA,cAAgB,CAAA,UAAA,CAAA,EArDCL,cAqDD,CAAA,EAAA,IAAA;EAAA;;;;;;;;;;;;;0BAvCZD;;;;;;;kBAORD;;;;;;;yBAOOE;;;;;;;;;;;;;;;;;;;;;;;iBAwBHG,yBAAyBD,eAAeL,wBAAwBO,gBAAgBV,qBAAqBU;iBACrGC,wCAAwCX,8BAA8BQ,eAAeL,YAAYC;;IAErHH"}