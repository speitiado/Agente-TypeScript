{"version":3,"file":"topic.cjs","names":["BaseChannel","EmptyChannelError"],"sources":["../../src/channels/topic.ts"],"sourcesContent":["import { EmptyChannelError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * A configurable PubSub Topic.\n */\nexport class Topic<Value> extends BaseChannel<\n  Array<Value>,\n  Value | Value[],\n  [Value[], Value[]]\n> {\n  lc_graph_name = \"Topic\";\n\n  unique = false;\n\n  accumulate = false;\n\n  seen: Set<Value>;\n\n  values: Value[];\n\n  constructor(fields?: {\n    /**\n     * Whether to only add unique values to the topic. If `true`, only unique values (using reference equality) will be added to the topic.\n     */\n    unique?: boolean;\n    /**\n     * Whether to accumulate values across steps. If `false`, the channel will be emptied after each step.\n     */\n    accumulate?: boolean;\n  }) {\n    super();\n\n    this.unique = fields?.unique ?? this.unique;\n    this.accumulate = fields?.accumulate ?? this.accumulate;\n    // State\n    this.seen = new Set<Value>();\n    this.values = [];\n  }\n\n  public fromCheckpoint(checkpoint?: [Value[], Value[]]) {\n    const empty = new Topic<Value>({\n      unique: this.unique,\n      accumulate: this.accumulate,\n    });\n    if (typeof checkpoint !== \"undefined\") {\n      empty.seen = new Set(checkpoint[0]);\n      // eslint-disable-next-line prefer-destructuring\n      empty.values = checkpoint[1];\n    }\n    return empty as this;\n  }\n\n  public update(values: Array<Value | Value[]>): boolean {\n    let updated = false;\n    if (!this.accumulate) {\n      updated = this.values.length > 0;\n      this.values = [];\n    }\n    const flatValues = values.flat() as Value[];\n    if (flatValues.length > 0) {\n      if (this.unique) {\n        for (const value of flatValues) {\n          if (!this.seen.has(value)) {\n            updated = true;\n            this.seen.add(value);\n            this.values.push(value);\n          }\n        }\n      } else {\n        updated = true;\n        this.values.push(...flatValues);\n      }\n    }\n    return updated;\n  }\n\n  public get(): Array<Value> {\n    if (this.values.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.values;\n  }\n\n  public checkpoint(): [Value[], Value[]] {\n    return [[...this.seen], this.values];\n  }\n\n  isAvailable(): boolean {\n    return this.values.length !== 0;\n  }\n}\n"],"mappings":";;;;;;;AAMA,IAAa,QAAb,MAAa,cAAqBA,yBAIhC;CACA,gBAAgB;CAEhB,SAAS;CAET,aAAa;CAEb;CAEA;CAEA,YAAY,QAST;AACD;AAEA,OAAK,SAAS,QAAQ,UAAU,KAAK;AACrC,OAAK,aAAa,QAAQ,cAAc,KAAK;AAE7C,OAAK,uBAAO,IAAI;AAChB,OAAK,SAAS;;CAGhB,AAAO,eAAe,YAAiC;EACrD,MAAM,QAAQ,IAAI,MAAa;GAC7B,QAAQ,KAAK;GACb,YAAY,KAAK;;AAEnB,MAAI,OAAO,eAAe,aAAa;AACrC,SAAM,OAAO,IAAI,IAAI,WAAW;AAEhC,SAAM,SAAS,WAAW;;AAE5B,SAAO;;CAGT,AAAO,OAAO,QAAyC;EACrD,IAAI,UAAU;AACd,MAAI,CAAC,KAAK,YAAY;AACpB,aAAU,KAAK,OAAO,SAAS;AAC/B,QAAK,SAAS;;EAEhB,MAAM,aAAa,OAAO;AAC1B,MAAI,WAAW,SAAS,EACtB,KAAI,KAAK,QACP;QAAK,MAAM,SAAS,WAClB,KAAI,CAAC,KAAK,KAAK,IAAI,QAAQ;AACzB,cAAU;AACV,SAAK,KAAK,IAAI;AACd,SAAK,OAAO,KAAK;;SAGhB;AACL,aAAU;AACV,QAAK,OAAO,KAAK,GAAG;;AAGxB,SAAO;;CAGT,AAAO,MAAoB;AACzB,MAAI,KAAK,OAAO,WAAW,EACzB,OAAM,IAAIC;AAEZ,SAAO,KAAK;;CAGd,AAAO,aAAiC;AACtC,SAAO,CAAC,CAAC,GAAG,KAAK,OAAO,KAAK;;CAG/B,cAAuB;AACrB,SAAO,KAAK,OAAO,WAAW"}