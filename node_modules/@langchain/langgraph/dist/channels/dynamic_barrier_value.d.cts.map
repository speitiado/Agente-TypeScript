{"version":3,"file":"dynamic_barrier_value.d.cts","names":["BaseChannel","WaitForNames","Value","DynamicBarrierValue","Set","DynamicBarrierValueAfterFinish"],"sources":["../../src/channels/dynamic_barrier_value.d.ts"],"sourcesContent":["import { BaseChannel } from \"./base.js\";\nexport interface WaitForNames<Value> {\n    __names: Value[];\n}\n/**\n * A channel that switches between two states\n *\n * - in the \"priming\" state it can't be read from.\n *     - if it receives a WaitForNames update, it switches to the \"waiting\" state.\n * - in the \"waiting\" state it collects named values until all are received.\n *     - once all named values are received, it can be read once, and it switches\n *       back to the \"priming\" state.\n */\nexport declare class DynamicBarrierValue<Value> extends BaseChannel<void, Value | WaitForNames<Value>, [\n    Value[] | undefined,\n    Value[]\n]> {\n    lc_graph_name: string;\n    names?: Set<Value>; // Names of nodes that we want to wait for.\n    seen: Set<Value>;\n    constructor();\n    fromCheckpoint(checkpoint?: [Value[] | undefined, Value[]]): this;\n    update(values: (Value | WaitForNames<Value>)[]): boolean;\n    consume(): boolean;\n    // If we have not yet seen all the node names we want to wait for,\n    // throw an error to prevent continuing.\n    get(): void;\n    checkpoint(): [Value[] | undefined, Value[]];\n    isAvailable(): boolean;\n}\n/**\n * A channel that switches between two states with an additional finished flag\n *\n * - in the \"priming\" state it can't be read from.\n *     - if it receives a WaitForNames update, it switches to the \"waiting\" state.\n * - in the \"waiting\" state it collects named values until all are received.\n *     - once all named values are received, and the finished flag is set, it can be read once, and it switches\n *       back to the \"priming\" state.\n * @internal\n */\nexport declare class DynamicBarrierValueAfterFinish<Value> extends BaseChannel<void, Value | WaitForNames<Value>, [\n    Value[] | undefined,\n    Value[],\n    boolean\n]> {\n    lc_graph_name: string;\n    names?: Set<Value>; // Names of nodes that we want to wait for.\n    seen: Set<Value>;\n    finished: boolean;\n    constructor();\n    fromCheckpoint(checkpoint?: [Value[] | undefined, Value[], boolean]): this;\n    update(values: (Value | WaitForNames<Value>)[]): boolean;\n    consume(): boolean;\n    finish(): boolean;\n    get(): void;\n    checkpoint(): [Value[] | undefined, Value[], boolean];\n    isAvailable(): boolean;\n}\n"],"mappings":";;;UACiBC;WACJC;AADb;AAYA;;;;;;;;;AAMcA,cANOC,mBAMPD,CAAAA,KAAAA,CAAAA,SAN0CF,WAM1CE,CAAAA,IAAAA,EAN4DA,KAM5DA,GANoED,YAMpEC,CANiFA,KAMjFA,CAAAA,EAAAA,CALVA,KAKME,EAAAA,GAAAA,SAAAA,EAJNF,KAM6BA,EAAAA;eACbA,EAAAA,MAAAA;OAAqBA,CAAAA,EAJ7BE,GAI6BF,CAJzBA,KAIyBA,CAAAA,CAAAA,CAAAA;MAAbD,EAHlBG,GAGkBH,CAHdC,KAGcD,CAAAA;aAKTC,CAAAA;gBAAqBA,CAAAA,UAAAA,CAAAA,EAAAA,CANPA,KAMOA,EAAAA,GAAAA,SAAAA,EANcA,KAMdA,EAAAA,CAAAA,CAAAA,EAAAA,IAAAA;QAdgBF,CAAAA,MAAAA,EAAAA,CASpCE,KAToCF,GAS5BC,YAT4BD,CASfE,KATeF,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,OAAAA;;;;;iBAcrCE,qBAAqBA"}