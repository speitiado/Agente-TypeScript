{"version":3,"file":"named_barrier_value.cjs","names":["BaseChannel","InvalidUpdateError","EmptyChannelError"],"sources":["../../src/channels/named_barrier_value.ts"],"sourcesContent":["import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\nexport const areSetsEqual = <T>(a: Set<T>, b: Set<T>) =>\n  a.size === b.size && [...a].every((value) => b.has(value));\n\n/**\n * A channel that waits until all named values are received before making the value available.\n *\n * This ensures that if node N and node M both write to channel C, the value of C will not be updated\n * until N and M have completed updating.\n */\nexport class NamedBarrierValue<Value> extends BaseChannel<\n  void,\n  Value,\n  Value[]\n> {\n  lc_graph_name = \"NamedBarrierValue\";\n\n  names: Set<Value>; // Names of nodes that we want to wait for.\n\n  seen: Set<Value>;\n\n  constructor(names: Set<Value>) {\n    super();\n    this.names = names;\n    this.seen = new Set<Value>();\n  }\n\n  fromCheckpoint(checkpoint?: Value[]) {\n    const empty = new NamedBarrierValue<Value>(this.names);\n    if (typeof checkpoint !== \"undefined\") {\n      empty.seen = new Set(checkpoint);\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    let updated = false;\n    for (const nodeName of values) {\n      if (this.names.has(nodeName)) {\n        if (!this.seen.has(nodeName)) {\n          this.seen.add(nodeName);\n          updated = true;\n        }\n      } else {\n        throw new InvalidUpdateError(\n          `Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(\n            this.names\n          )}`\n        );\n      }\n    }\n    return updated;\n  }\n\n  // If we have not yet seen all the node names we want to wait for,\n  // throw an error to prevent continuing.\n  get(): void {\n    if (!areSetsEqual(this.names, this.seen)) {\n      throw new EmptyChannelError();\n    }\n    return undefined;\n  }\n\n  checkpoint(): Value[] {\n    return [...this.seen];\n  }\n\n  consume(): boolean {\n    if (this.seen && this.names && areSetsEqual(this.seen, this.names)) {\n      this.seen = new Set<Value>();\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return !!this.names && areSetsEqual(this.names, this.seen);\n  }\n}\n\n/**\n * A channel that waits until all named values are received before making the value ready to be made available.\n * It is only made available after finish() is called.\n * @internal\n */\nexport class NamedBarrierValueAfterFinish<Value> extends BaseChannel<\n  void,\n  Value,\n  [Value[], boolean]\n> {\n  lc_graph_name = \"NamedBarrierValueAfterFinish\";\n\n  names: Set<Value>; // Names of nodes that we want to wait for.\n\n  seen: Set<Value>;\n\n  finished: boolean;\n\n  constructor(names: Set<Value>) {\n    super();\n    this.names = names;\n    this.seen = new Set<Value>();\n    this.finished = false;\n  }\n\n  fromCheckpoint(checkpoint?: [Value[], boolean]) {\n    const empty = new NamedBarrierValueAfterFinish<Value>(this.names);\n    if (typeof checkpoint !== \"undefined\") {\n      const [seen, finished] = checkpoint;\n      empty.seen = new Set(seen);\n      empty.finished = finished;\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    let updated = false;\n    for (const nodeName of values) {\n      if (this.names.has(nodeName) && !this.seen.has(nodeName)) {\n        this.seen.add(nodeName);\n        updated = true;\n      } else if (!this.names.has(nodeName)) {\n        throw new InvalidUpdateError(\n          `Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(\n            this.names\n          )}`\n        );\n      }\n    }\n    return updated;\n  }\n\n  get(): void {\n    if (!this.finished || !areSetsEqual(this.names, this.seen)) {\n      throw new EmptyChannelError();\n    }\n    return undefined;\n  }\n\n  checkpoint(): [Value[], boolean] {\n    return [[...this.seen], this.finished];\n  }\n\n  consume(): boolean {\n    if (\n      this.finished &&\n      this.seen &&\n      this.names &&\n      areSetsEqual(this.seen, this.names)\n    ) {\n      this.seen = new Set<Value>();\n      this.finished = false;\n      return true;\n    }\n    return false;\n  }\n\n  finish(): boolean {\n    if (!this.finished && !!this.names && areSetsEqual(this.names, this.seen)) {\n      this.finished = true;\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return this.finished && !!this.names && areSetsEqual(this.names, this.seen);\n  }\n}\n"],"mappings":";;;;AAGA,MAAa,gBAAmB,GAAW,MACzC,EAAE,SAAS,EAAE,QAAQ,CAAC,GAAG,GAAG,OAAO,UAAU,EAAE,IAAI;;;;;;;AAQrD,IAAa,oBAAb,MAAa,0BAAiCA,yBAI5C;CACA,gBAAgB;CAEhB;CAEA;CAEA,YAAY,OAAmB;AAC7B;AACA,OAAK,QAAQ;AACb,OAAK,uBAAO,IAAI;;CAGlB,eAAe,YAAsB;EACnC,MAAM,QAAQ,IAAI,kBAAyB,KAAK;AAChD,MAAI,OAAO,eAAe,YACxB,OAAM,OAAO,IAAI,IAAI;AAEvB,SAAO;;CAGT,OAAO,QAA0B;EAC/B,IAAI,UAAU;AACd,OAAK,MAAM,YAAY,OACrB,KAAI,KAAK,MAAM,IAAI,WACjB;OAAI,CAAC,KAAK,KAAK,IAAI,WAAW;AAC5B,SAAK,KAAK,IAAI;AACd,cAAU;;QAGZ,OAAM,IAAIC,kCACR,SAAS,KAAK,UAAU,UAAU,gBAAgB,KAAK,UACrD,KAAK;AAKb,SAAO;;CAKT,MAAY;AACV,MAAI,CAAC,aAAa,KAAK,OAAO,KAAK,MACjC,OAAM,IAAIC;AAEZ,SAAO;;CAGT,aAAsB;AACpB,SAAO,CAAC,GAAG,KAAK;;CAGlB,UAAmB;AACjB,MAAI,KAAK,QAAQ,KAAK,SAAS,aAAa,KAAK,MAAM,KAAK,QAAQ;AAClE,QAAK,uBAAO,IAAI;AAChB,UAAO;;AAET,SAAO;;CAGT,cAAuB;AACrB,SAAO,CAAC,CAAC,KAAK,SAAS,aAAa,KAAK,OAAO,KAAK;;;;;;;;AASzD,IAAa,+BAAb,MAAa,qCAA4CF,yBAIvD;CACA,gBAAgB;CAEhB;CAEA;CAEA;CAEA,YAAY,OAAmB;AAC7B;AACA,OAAK,QAAQ;AACb,OAAK,uBAAO,IAAI;AAChB,OAAK,WAAW;;CAGlB,eAAe,YAAiC;EAC9C,MAAM,QAAQ,IAAI,6BAAoC,KAAK;AAC3D,MAAI,OAAO,eAAe,aAAa;GACrC,MAAM,CAAC,MAAM,YAAY;AACzB,SAAM,OAAO,IAAI,IAAI;AACrB,SAAM,WAAW;;AAEnB,SAAO;;CAGT,OAAO,QAA0B;EAC/B,IAAI,UAAU;AACd,OAAK,MAAM,YAAY,OACrB,KAAI,KAAK,MAAM,IAAI,aAAa,CAAC,KAAK,KAAK,IAAI,WAAW;AACxD,QAAK,KAAK,IAAI;AACd,aAAU;aACD,CAAC,KAAK,MAAM,IAAI,UACzB,OAAM,IAAIC,kCACR,SAAS,KAAK,UAAU,UAAU,gBAAgB,KAAK,UACrD,KAAK;AAKb,SAAO;;CAGT,MAAY;AACV,MAAI,CAAC,KAAK,YAAY,CAAC,aAAa,KAAK,OAAO,KAAK,MACnD,OAAM,IAAIC;AAEZ,SAAO;;CAGT,aAAiC;AAC/B,SAAO,CAAC,CAAC,GAAG,KAAK,OAAO,KAAK;;CAG/B,UAAmB;AACjB,MACE,KAAK,YACL,KAAK,QACL,KAAK,SACL,aAAa,KAAK,MAAM,KAAK,QAC7B;AACA,QAAK,uBAAO,IAAI;AAChB,QAAK,WAAW;AAChB,UAAO;;AAET,SAAO;;CAGT,SAAkB;AAChB,MAAI,CAAC,KAAK,YAAY,CAAC,CAAC,KAAK,SAAS,aAAa,KAAK,OAAO,KAAK,OAAO;AACzE,QAAK,WAAW;AAChB,UAAO;;AAET,SAAO;;CAGT,cAAuB;AACrB,SAAO,KAAK,YAAY,CAAC,CAAC,KAAK,SAAS,aAAa,KAAK,OAAO,KAAK"}