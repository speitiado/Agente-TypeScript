{"version":3,"file":"write.js","names":["writeEntries: [string, any][]","write: TYPE_SEND"],"sources":["../../src/pregel/write.ts"],"sourcesContent":["import {\n  Runnable,\n  RunnableConfig,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { _isSend, CONFIG_KEY_SEND, Send, TASKS } from \"../constants.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport { InvalidUpdateError } from \"../errors.js\";\n\ntype TYPE_SEND = (values: Array<[string, unknown]>) => void;\n\nexport const SKIP_WRITE = {\n  [Symbol.for(\"LG_SKIP_WRITE\")]: true,\n};\n\nfunction _isSkipWrite(x: unknown) {\n  return (\n    typeof x === \"object\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (x as any)?.[Symbol.for(\"LG_SKIP_WRITE\")] !== undefined\n  );\n}\n\nexport const PASSTHROUGH = {\n  [Symbol.for(\"LG_PASSTHROUGH\")]: true,\n};\n\nfunction _isPassthrough(x: unknown) {\n  return (\n    typeof x === \"object\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (x as any)?.[Symbol.for(\"LG_PASSTHROUGH\")] !== undefined\n  );\n}\n\nconst IS_WRITER = Symbol(\"IS_WRITER\");\n\n/**\n * Mapping of write channels to Runnables that return the value to be written,\n * or None to skip writing.\n */\nexport class ChannelWrite<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any\n> extends RunnableCallable<RunInput, RunInput> {\n  writes: Array<ChannelWriteEntry | ChannelWriteTupleEntry | Send>;\n\n  constructor(\n    writes: Array<ChannelWriteEntry | ChannelWriteTupleEntry | Send>,\n    tags?: string[]\n  ) {\n    const name = `ChannelWrite<${writes\n      .map((packet) => {\n        if (_isSend(packet)) {\n          return packet.node;\n        } else if (\"channel\" in packet) {\n          return packet.channel;\n        }\n        return \"...\";\n      })\n      .join(\",\")}>`;\n    super({\n      ...{ writes, name, tags },\n      func: async (input: RunInput, config?: RunnableConfig) => {\n        return this._write(input, config ?? {});\n      },\n    });\n\n    this.writes = writes;\n  }\n\n  async _write(input: unknown, config: RunnableConfig): Promise<unknown> {\n    const writes = this.writes.map((write) => {\n      if (_isChannelWriteTupleEntry(write) && _isPassthrough(write.value)) {\n        return {\n          mapper: write.mapper,\n          value: input,\n        };\n      } else if (_isChannelWriteEntry(write) && _isPassthrough(write.value)) {\n        return {\n          channel: write.channel,\n          value: input,\n          skipNone: write.skipNone,\n          mapper: write.mapper,\n        };\n      } else {\n        return write;\n      }\n    });\n    await ChannelWrite.doWrite(config, writes);\n    return input;\n  }\n\n  // TODO: Support requireAtLeastOneOf\n  static async doWrite(\n    config: RunnableConfig,\n    writes: (ChannelWriteEntry | ChannelWriteTupleEntry | Send)[]\n  ): Promise<void> {\n    // validate\n    for (const w of writes) {\n      if (_isChannelWriteEntry(w)) {\n        if (w.channel === TASKS) {\n          throw new InvalidUpdateError(\n            \"Cannot write to the reserved channel TASKS\"\n          );\n        }\n        if (_isPassthrough(w.value)) {\n          throw new InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n        }\n      }\n      if (_isChannelWriteTupleEntry(w)) {\n        if (_isPassthrough(w.value)) {\n          throw new InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n        }\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const writeEntries: [string, any][] = [];\n    for (const w of writes) {\n      if (_isSend(w)) {\n        writeEntries.push([TASKS, w]);\n      } else if (_isChannelWriteTupleEntry(w)) {\n        const mappedResult = await w.mapper.invoke(w.value, config);\n        if (mappedResult != null && mappedResult.length > 0) {\n          writeEntries.push(...mappedResult);\n        }\n      } else if (_isChannelWriteEntry(w)) {\n        const mappedValue =\n          w.mapper !== undefined\n            ? await w.mapper.invoke(w.value, config)\n            : w.value;\n        if (_isSkipWrite(mappedValue)) {\n          continue;\n        }\n        if (w.skipNone && mappedValue === undefined) {\n          continue;\n        }\n        writeEntries.push([w.channel, mappedValue]);\n      } else {\n        throw new Error(`Invalid write entry: ${JSON.stringify(w)}`);\n      }\n    }\n    const write: TYPE_SEND = config.configurable?.[CONFIG_KEY_SEND];\n    write(writeEntries);\n  }\n\n  static isWriter(runnable: RunnableLike): runnable is ChannelWrite {\n    return (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      runnable instanceof ChannelWrite ||\n      (IS_WRITER in runnable && !!runnable[IS_WRITER])\n    );\n  }\n\n  static registerWriter<T extends Runnable>(runnable: T): T {\n    return Object.defineProperty(runnable, IS_WRITER, { value: true });\n  }\n}\n\nexport interface ChannelWriteEntry {\n  channel: string;\n  value: unknown;\n  skipNone?: boolean;\n  mapper?: Runnable;\n}\n\nfunction _isChannelWriteEntry(x: unknown): x is ChannelWriteEntry {\n  return (\n    x !== undefined && typeof (x as ChannelWriteEntry).channel === \"string\"\n  );\n}\n\nexport interface ChannelWriteTupleEntry {\n  value: unknown;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper: Runnable<any, [string, any][]>;\n}\n\nfunction _isChannelWriteTupleEntry(x: unknown): x is ChannelWriteTupleEntry {\n  return (\n    x !== undefined &&\n    !_isChannelWriteEntry(x) &&\n    Runnable.isRunnable((x as ChannelWriteTupleEntry).mapper)\n  );\n}\n"],"mappings":";;;;;;AAWA,MAAa,aAAa,GACvB,OAAO,IAAI,mBAAmB;AAGjC,SAAS,aAAa,GAAY;AAChC,QACE,OAAO,MAAM,YAEZ,IAAY,OAAO,IAAI,sBAAsB;;AAIlD,MAAa,cAAc,GACxB,OAAO,IAAI,oBAAoB;AAGlC,SAAS,eAAe,GAAY;AAClC,QACE,OAAO,MAAM,YAEZ,IAAY,OAAO,IAAI,uBAAuB;;AAInD,MAAM,YAAY,OAAO;;;;;AAMzB,IAAa,eAAb,MAAa,qBAGH,iBAAqC;CAC7C;CAEA,YACE,QACA,MACA;EACA,MAAM,OAAO,gBAAgB,OAC1B,KAAK,WAAW;AACf,OAAI,QAAQ,QACV,QAAO,OAAO;YACL,aAAa,OACtB,QAAO,OAAO;AAEhB,UAAO;KAER,KAAK,KAAK;AACb,QAAM;GACC;GAAQ;GAAM;GACnB,MAAM,OAAO,OAAiB,WAA4B;AACxD,WAAO,KAAK,OAAO,OAAO,UAAU;;;AAIxC,OAAK,SAAS;;CAGhB,MAAM,OAAO,OAAgB,QAA0C;EACrE,MAAM,SAAS,KAAK,OAAO,KAAK,UAAU;AACxC,OAAI,0BAA0B,UAAU,eAAe,MAAM,OAC3D,QAAO;IACL,QAAQ,MAAM;IACd,OAAO;;YAEA,qBAAqB,UAAU,eAAe,MAAM,OAC7D,QAAO;IACL,SAAS,MAAM;IACf,OAAO;IACP,UAAU,MAAM;IAChB,QAAQ,MAAM;;OAGhB,QAAO;;AAGX,QAAM,aAAa,QAAQ,QAAQ;AACnC,SAAO;;CAIT,aAAa,QACX,QACA,QACe;AAEf,OAAK,MAAM,KAAK,QAAQ;AACtB,OAAI,qBAAqB,IAAI;AAC3B,QAAI,EAAE,YAAY,MAChB,OAAM,IAAI,mBACR;AAGJ,QAAI,eAAe,EAAE,OACnB,OAAM,IAAI,mBAAmB;;AAGjC,OAAI,0BAA0B,IAC5B;QAAI,eAAe,EAAE,OACnB,OAAM,IAAI,mBAAmB;;;EAKnC,MAAMA,eAAgC;AACtC,OAAK,MAAM,KAAK,OACd,KAAI,QAAQ,GACV,cAAa,KAAK,CAAC,OAAO;WACjB,0BAA0B,IAAI;GACvC,MAAM,eAAe,MAAM,EAAE,OAAO,OAAO,EAAE,OAAO;AACpD,OAAI,gBAAgB,QAAQ,aAAa,SAAS,EAChD,cAAa,KAAK,GAAG;aAEd,qBAAqB,IAAI;GAClC,MAAM,cACJ,EAAE,WAAW,SACT,MAAM,EAAE,OAAO,OAAO,EAAE,OAAO,UAC/B,EAAE;AACR,OAAI,aAAa,aACf;AAEF,OAAI,EAAE,YAAY,gBAAgB,OAChC;AAEF,gBAAa,KAAK,CAAC,EAAE,SAAS;QAE9B,OAAM,IAAI,MAAM,wBAAwB,KAAK,UAAU;EAG3D,MAAMC,QAAmB,OAAO,eAAe;AAC/C,QAAM;;CAGR,OAAO,SAAS,UAAkD;AAChE,SAEE,oBAAoB,gBACnB,aAAa,YAAY,CAAC,CAAC,SAAS;;CAIzC,OAAO,eAAmC,UAAgB;AACxD,SAAO,OAAO,eAAe,UAAU,WAAW,EAAE,OAAO;;;AAW/D,SAAS,qBAAqB,GAAoC;AAChE,QACE,MAAM,UAAa,OAAQ,EAAwB,YAAY;;AAUnE,SAAS,0BAA0B,GAAyC;AAC1E,QACE,MAAM,UACN,CAAC,qBAAqB,MACtB,SAAS,WAAY,EAA6B"}