{"version":3,"file":"types.js","names":[],"sources":["../../src/pregel/types.ts"],"sourcesContent":["import type { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport type {\n  All,\n  PendingWrite,\n  CheckpointMetadata,\n  BaseCheckpointSaver,\n  BaseStore,\n  CheckpointListOptions,\n  BaseCache,\n} from \"@langchain/langgraph-checkpoint\";\nimport { Graph as DrawableGraph } from \"@langchain/core/runnables/graph\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { BaseMessage } from \"@langchain/core/messages\";\nimport type { BaseChannel } from \"../channels/base.js\";\nimport type { PregelNode } from \"./read.js\";\nimport type { Interrupt } from \"../constants.js\";\nimport { CachePolicy, RetryPolicy } from \"./utils/index.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\n/**\n * Selects the type of output you'll receive when streaming from the graph. See [Streaming](/langgraphjs/how-tos/#streaming) for more details.\n */\nexport type StreamMode =\n  | \"values\"\n  | \"updates\"\n  | \"debug\"\n  | \"messages\"\n  | \"checkpoints\"\n  | \"tasks\"\n  | \"custom\";\n\nexport type Durability = \"exit\" | \"async\" | \"sync\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelOutputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype StreamMessageOutput = [BaseMessage, Record<string, any>];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype StreamDebugOutput = Record<string, any>;\n\ntype StreamCheckpointsOutput<StreamValues> = {\n  values: StreamValues;\n  next: string[];\n  config: RunnableConfig;\n  metadata?: CheckpointMetadata;\n  parentConfig?: RunnableConfig | undefined;\n  tasks: PregelTaskDescription[];\n};\n\ninterface StreamTasksOutputBase {\n  id: string;\n  name: string;\n  interrupts: Interrupt[];\n}\n\ninterface StreamTasksCreateOutput<StreamValues> extends StreamTasksOutputBase {\n  input: StreamValues;\n  triggers: string[];\n}\n\ninterface StreamTasksResultOutput<Keys, StreamUpdates>\n  extends StreamTasksOutputBase {\n  result: [Keys, StreamUpdates][];\n}\n\ntype StreamTasksOutput<StreamUpdates, StreamValues, Nodes = string> =\n  | StreamTasksCreateOutput<StreamValues>\n  | StreamTasksResultOutput<Nodes, StreamUpdates>;\n\ntype DefaultStreamMode = \"updates\";\n\nexport type IsEventStream<T> = [T] extends [\"text/event-stream\"]\n  ? [\"text/event-stream\"] extends [T]\n    ? true\n    : false\n  : false;\n\nexport type StreamOutputMap<\n  TStreamMode extends StreamMode | StreamMode[] | undefined,\n  TStreamSubgraphs extends boolean,\n  StreamUpdates,\n  StreamValues,\n  Nodes,\n  NodeReturnType,\n  StreamCustom,\n  TEncoding extends \"text/event-stream\" | undefined\n> = IsEventStream<TEncoding> extends true\n  ? Uint8Array\n  : (\n      undefined extends TStreamMode\n        ? []\n        : StreamMode | StreamMode[] extends TStreamMode\n        ? TStreamMode extends StreamMode[]\n          ? TStreamMode[number]\n          : TStreamMode\n        : TStreamMode extends StreamMode[]\n        ? TStreamMode[number]\n        : []\n    ) extends infer Multiple extends StreamMode\n  ? [TStreamSubgraphs] extends [true]\n    ? {\n        values: [string[], \"values\", StreamValues];\n        updates: [\n          string[],\n          \"updates\",\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [string[], \"messages\", StreamMessageOutput];\n        custom: [string[], \"custom\", StreamCustom];\n        checkpoints: [\n          string[],\n          \"checkpoints\",\n          StreamCheckpointsOutput<StreamValues>\n        ];\n        tasks: [\n          string[],\n          \"tasks\",\n          StreamTasksOutput<StreamUpdates, StreamValues>\n        ];\n        debug: [string[], \"debug\", StreamDebugOutput];\n      }[Multiple]\n    : {\n        values: [\"values\", StreamValues];\n        updates: [\n          \"updates\",\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [\"messages\", StreamMessageOutput];\n        custom: [\"custom\", StreamCustom];\n        checkpoints: [\"checkpoints\", StreamCheckpointsOutput<StreamValues>];\n        tasks: [\"tasks\", StreamTasksOutput<StreamUpdates, StreamValues, Nodes>];\n        debug: [\"debug\", StreamDebugOutput];\n      }[Multiple]\n  : (\n      undefined extends TStreamMode ? DefaultStreamMode : TStreamMode\n    ) extends infer Single extends StreamMode\n  ? [TStreamSubgraphs] extends [true]\n    ? {\n        values: [string[], StreamValues];\n        updates: [\n          string[],\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [string[], StreamMessageOutput];\n        custom: [string[], StreamCustom];\n        checkpoints: [string[], StreamCheckpointsOutput<StreamValues>];\n        tasks: [\n          string[],\n          StreamTasksOutput<StreamUpdates, StreamValues, Nodes>\n        ];\n        debug: [string[], StreamDebugOutput];\n      }[Single]\n    : {\n        values: StreamValues;\n        updates: NodeReturnType extends Record<string, unknown>\n          ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n          : Record<Nodes extends string ? Nodes : string, StreamUpdates>;\n        messages: StreamMessageOutput;\n        custom: StreamCustom;\n        checkpoints: StreamCheckpointsOutput<StreamValues>;\n        tasks: StreamTasksOutput<StreamUpdates, StreamValues, Nodes>;\n        debug: StreamDebugOutput;\n      }[Single]\n  : never;\n\n/**\n * Configuration options for executing a Pregel graph.\n * These options control how the graph executes, what data is streamed, and how interrupts are handled.\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} implementations\n * @typeParam ContextType - Type of context that can be passed to the graph\n */\nexport interface PregelOptions<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = Record<string, any>,\n  TStreamMode extends StreamMode | StreamMode[] | undefined =\n    | StreamMode\n    | StreamMode[]\n    | undefined,\n  TSubgraphs extends boolean = boolean,\n  TEncoding extends \"text/event-stream\" | undefined =\n    | \"text/event-stream\"\n    | undefined\n> extends RunnableConfig<ContextType> {\n  /**\n   * Controls what information is streamed during graph execution.\n   * Multiple modes can be enabled simultaneously.\n   *\n   * Supported modes:\n   * - \"values\": Streams complete state after each step\n   * - \"updates\": Streams only state changes after each step\n   * - \"messages\": Streams messages from within nodes\n   * - \"custom\": Streams custom events from within nodes\n   * - \"debug\": Streams detailed execution events for tracing & debugging\n   *\n   * @example\n   * ```typescript\n   * // Stream only values\n   * streamMode: \"values\"\n   *\n   * // Stream both values and debug info\n   * streamMode: [\"values\", \"debug\"]\n   * ```\n   *\n   * @default [\"values\"]\n   */\n  streamMode?: TStreamMode;\n\n  /**\n   * Specifies which channel keys to retrieve from the checkpoint when resuming execution.\n   * This is an advanced option that you generally don't need to set manually.\n   * The graph will automatically determine the appropriate input keys based on its configuration.\n   */\n  inputKeys?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * Specifies which channel keys to include in the output stream and final result.\n   * Use this to filter which parts of the graph state you want to observe.\n   *\n   * @example\n   * ```typescript\n   * // Stream only the 'result' channel\n   * outputKeys: \"result\"\n   *\n   * // Stream multiple channels\n   * outputKeys: [\"result\", \"intermediateState\"]\n   * ```\n   */\n  outputKeys?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * List of nodes where execution should be interrupted BEFORE the node runs.\n   * Can be used for debugging and advanced state manipulation use cases. For\n   * human-in-the-loop workflows, developers should prefer the\n   * @link {interrupt} function instead.\n   *\n   * When interrupted, a resume @link {Command} must be provided to continue\n   * execution.\n   *\n   * @example\n   * ```typescript\n   * // Interrupt before specific nodes\n   * interruptBefore: [\"humanReview\", \"qualityCheck\"]\n   *\n   * // Interrupt before all nodes\n   * interruptBefore: \"all\"\n   * ```\n   */\n  interruptBefore?: All | Array<keyof Nodes>;\n\n  /**\n   * List of nodes where execution should be interrupted AFTER the node runs.\n   * Similar to interruptBefore, but interrupts after node completion.\n   * Useful when the node's output needs to be reviewed before proceeding.\n   *\n   * @example\n   * ```typescript\n   * // Interrupt after specific nodes\n   * interruptAfter: [\"generateContent\", \"analyze\"]\n   *\n   * // Interrupt after all nodes\n   * interruptAfter: \"all\"\n   * ```\n   */\n  interruptAfter?: All | Array<keyof Nodes>;\n\n  /**\n   * Enables detailed debug logging during graph execution.\n   * When enabled, prints information about:\n   * - Task execution\n   * - Channel updates\n   * - Checkpoint writes\n   *\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * Whether to include subgraph execution details in the stream.\n   * When true, state updates from nested graphs will also be streamed.\n   *\n   * @default false\n   */\n  subgraphs?: TSubgraphs;\n\n  /**\n   * Whether to checkpoint intermediate steps, defaults to `true`.\n   * If `false`, only the final checkpoint is saved.\n   * @deprecated Use `durability` instead.\n   */\n  checkpointDuring?: boolean;\n\n  /**\n   * Whether to checkpoint during the run (or only at the end/interruption).\n   * - `\"async\"`: Save checkpoint asynchronously while the next step executes (default).\n   * - `\"sync\"`: Save checkpoint synchronously before the next step starts.\n   * - `\"exit\"`: Save checkpoint only when the graph exits.\n   * @default \"async\"\n   */\n  durability?: Durability;\n\n  /**\n   * A shared value store that allows you to store and retrieve state across\n   * threads. Useful for implementing long-term memory patterns.\n   */\n  store?: BaseStore;\n\n  /**\n   * Optional cache for the graph, useful for caching tasks.\n   */\n  cache?: BaseCache;\n\n  /**\n   * Static context for the graph run, like `userId`, `dbConnection` etc.\n   */\n  context?: ContextType;\n\n  /**\n   * The encoding to use for the stream.\n   * - `undefined`: Use the default format.\n   * - `\"text/event-stream\"`: Use the Server-Sent Events format.\n   * @default undefined\n   */\n  encoding?: TEncoding;\n}\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype StrRecord<K extends string, T> = {\n  [P in K]: T;\n};\n\nexport interface PregelInterface<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = StrRecord<string, any>\n> {\n  lg_is_pregel: boolean;\n\n  withConfig(config: RunnableConfig): PregelInterface<Nodes, Channels>;\n\n  getGraphAsync(\n    config: RunnableConfig & { xray?: boolean | number }\n  ): Promise<DrawableGraph>;\n\n  /** @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release. */\n  getSubgraphs(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Generator<[string, PregelInterface<any, any>]>;\n\n  getSubgraphsAsync(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<[string, PregelInterface<any, any>]>;\n\n  getState(\n    config: RunnableConfig,\n    options?: { subgraphs?: boolean }\n  ): Promise<StateSnapshot>;\n\n  getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot>;\n\n  updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: keyof Nodes | string\n  ): Promise<RunnableConfig>;\n\n  stream(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nodes, Channels, ContextType>>\n  ): Promise<IterableReadableStream<PregelOutputType>>;\n\n  invoke(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nodes, Channels, ContextType>>\n  ): Promise<PregelOutputType>;\n}\n\n/**\n * Parameters for creating a Pregel graph.\n * @internal\n */\nexport type PregelParams<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>\n> = {\n  /**\n   * The name of the graph. @see {@link Runnable.name}\n   */\n  name?: string;\n\n  /**\n   * The nodes in the graph.\n   */\n  nodes: Nodes;\n\n  /**\n   * The channels in the graph.\n   */\n  channels: Channels;\n\n  /**\n   * Whether to validate the graph.\n   *\n   * @default true\n   */\n  autoValidate?: boolean;\n\n  /**\n   * The stream mode for the graph run. See [Streaming](/langgraphjs/how-tos/#streaming) for more details.\n   *\n   * @default [\"values\"]\n   */\n  streamMode?: StreamMode | StreamMode[];\n\n  /**\n   * The input channels for the graph run.\n   */\n  inputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * The output channels for the graph run.\n   */\n  outputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * After processing one of the nodes named in this list, the graph will be interrupted and a resume {@link Command} must be provided to proceed with the execution of this thread.\n   * @default []\n   */\n  interruptAfter?: Array<keyof Nodes> | All;\n\n  /**\n   * Before processing one of the nodes named in this list, the graph will be interrupted and a resume {@link Command} must be provided to proceed with the execution of this thread.\n   * @default []\n   */\n  interruptBefore?: Array<keyof Nodes> | All;\n\n  /**\n   * The channels to stream from the graph run.\n   * @default []\n   */\n  streamChannels?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * @default undefined\n   */\n  stepTimeout?: number;\n\n  /**\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * The {@link BaseCheckpointSaver | checkpointer} to use for the graph run.\n   */\n  checkpointer?: BaseCheckpointSaver | boolean;\n\n  /**\n   * The default retry policy for this graph. For defaults, see {@link RetryPolicy}.\n   */\n  retryPolicy?: RetryPolicy;\n\n  /**\n   * The configuration for the graph run.\n   */\n  config?: LangGraphRunnableConfig;\n\n  /**\n   * External key-value store.\n   */\n  store?: BaseStore;\n\n  /**\n   * Storage used for node caching.\n   */\n  cache?: BaseCache;\n\n  /**\n   * The trigger to node mapping for the graph run.\n   * @internal\n   */\n  triggerToNodes?: Record<string, string[]>;\n\n  /**\n   * Interrupt helper function.\n   * @internal\n   */\n  userInterrupt?: unknown;\n};\n\nexport interface PregelTaskDescription {\n  readonly id: string;\n  readonly name: string;\n  readonly error?: unknown;\n  readonly interrupts: Interrupt[];\n  readonly state?: LangGraphRunnableConfig | StateSnapshot;\n  readonly path?: TaskPath;\n  readonly result?: unknown;\n}\n\ninterface CacheKey {\n  ns: string[];\n  key: string;\n  ttl?: number;\n}\n\nexport interface PregelExecutableTask<\n  NodeKey extends PropertyKey,\n  ChannelKey extends PropertyKey\n> {\n  readonly name: NodeKey;\n  readonly input: unknown;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly proc: Runnable<any, any, LangGraphRunnableConfig>;\n  readonly writes: PendingWrite<ChannelKey>[];\n  readonly config?: LangGraphRunnableConfig;\n  readonly triggers: Array<string>;\n  readonly retry_policy?: RetryPolicy;\n  readonly cache_key?: CacheKey;\n  readonly id: string;\n  readonly path?: TaskPath;\n  readonly subgraphs?: Runnable[];\n  readonly writers: Runnable[];\n}\n\nexport interface StateSnapshot {\n  /**\n   * Current values of channels\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly values: Record<string, any> | any;\n  /**\n   * Nodes to execute in the next step, if any\n   */\n  readonly next: Array<string>;\n  /**\n   * Config used to fetch this snapshot\n   */\n  readonly config: RunnableConfig;\n  /**\n   * Metadata about the checkpoint\n   */\n  readonly metadata?: CheckpointMetadata;\n  /**\n   * Time when the snapshot was created\n   */\n  readonly createdAt?: string;\n  /**\n   * Config used to fetch the parent snapshot, if any\n   * @default undefined\n   */\n  readonly parentConfig?: RunnableConfig | undefined;\n  /**\n   * Tasks to execute in this step. If already attempted, may contain an error.\n   */\n  readonly tasks: PregelTaskDescription[];\n}\n\n/**\n * Options for subscribing to multiple channels.\n */\nexport type MultipleChannelSubscriptionOptions = {\n  /**\n   * Optional tags to associate with the subscription.\n   */\n  tags?: string[];\n};\n\n/**\n * Options for subscribing to a single channel.\n */\nexport type SingleChannelSubscriptionOptions = {\n  /**\n   * When specified, the channel mapping will be an object with this key pointing\n   * to the array of channels to subscribe to. Otherwise, the channel mapping\n   * will be an array of channels.\n   */\n  key?: string;\n  /**\n   * Optional tags to associate with the subscription.\n   */\n  tags?: string[];\n};\n\n/**\n * Options for getting the state of the graph.\n */\nexport type GetStateOptions = {\n  /**\n   * Whether to include subgraph states.\n   * @default false\n   */\n  subgraphs?: boolean;\n};\n\n/**\n * Used for storing/retrieving internal execution state.\n *\n * @internal\n */\nexport type PregelScratchpad<Resume = unknown> = {\n  /** Counter for tracking call invocations */\n  callCounter: number;\n  /** Counter for tracking interrupts */\n  interruptCounter: number;\n  /** List of resume values */\n  resume: Resume[];\n  /** Single resume value for null task ID */\n  nullResume: Resume;\n\n  consumeNullResume: () => Resume | undefined;\n  /** Counter for tracking subgraph invocations */\n  subgraphCounter: number;\n\n  /** The input to the currently executing task */\n  currentTaskInput: unknown;\n};\n\n/**\n * @internal\n */\nexport type PregelAbortSignals = {\n  /** Aborts when the user calls `stream.cancel()` or aborts the {@link AbortSignal} that they passed in via the `signal` option */\n  externalAbortSignal?: AbortSignal;\n\n  /**\n   * Aborts when the currently executing task throws any error other than a {@link GraphBubbleUp}\n   */\n  timeoutAbortSignal?: AbortSignal;\n\n  /**\n   * A reference to the AbortSignal that is passed to the node. Aborts on step timeout, stream cancel, or when an error is thrown.\n   */\n  composedAbortSignal?: AbortSignal;\n};\n\nexport type CallOptions = {\n  func: (...args: unknown[]) => unknown | Promise<unknown>;\n  name: string;\n  input: unknown;\n  cache?: CachePolicy;\n  retry?: RetryPolicy;\n  callbacks?: unknown;\n};\n\nexport class Call {\n  func: (...args: unknown[]) => unknown | Promise<unknown>;\n\n  name: string;\n\n  input: unknown;\n\n  retry?: RetryPolicy;\n\n  cache?: CachePolicy;\n\n  callbacks?: unknown;\n\n  readonly __lg_type = \"call\";\n\n  constructor({ func, name, input, retry, cache, callbacks }: CallOptions) {\n    this.func = func;\n    this.name = name;\n    this.input = input;\n    this.retry = retry;\n    this.cache = cache;\n    this.callbacks = callbacks;\n  }\n}\n\nexport function isCall(value: unknown): value is Call {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"__lg_type\" in value &&\n    value.__lg_type === \"call\"\n  );\n}\n\nexport type SimpleTaskPath = [string, string | number];\nexport type VariadicTaskPath = [string, ...(string | number)[], boolean];\nexport type CallTaskPath =\n  | [string, ...(string | number)[], Call]\n  | [string, TaskPath, ...(string | number)[], Call];\nexport type TaskPath = SimpleTaskPath | CallTaskPath | VariadicTaskPath;\n"],"mappings":";AA6pBA,IAAa,OAAb,MAAkB;CAChB;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA,AAAS,YAAY;CAErB,YAAY,EAAE,MAAM,MAAM,OAAO,OAAO,OAAO,aAA0B;AACvE,OAAK,OAAO;AACZ,OAAK,OAAO;AACZ,OAAK,QAAQ;AACb,OAAK,QAAQ;AACb,OAAK,QAAQ;AACb,OAAK,YAAY;;;AAIrB,SAAgB,OAAO,OAA+B;AACpD,QACE,OAAO,UAAU,YACjB,UAAU,QACV,eAAe,SACf,MAAM,cAAc"}