{"version":3,"file":"index.cjs","names":["channelMappingOrArray: string[] | Record<string, string>","triggers: string[]","PregelNode","channelWriteEntries: Array<ChannelWriteEntry>","PASSTHROUGH","Runnable","ChannelWrite","TASKS","Topic","findSubgraphPregel","CHECKPOINT_NAMESPACE_SEPARATOR","emptyChannels","NULL_TASK_ID","INPUT","_prepareNextTasks","gatherIterator","taskStates: Record<string, RunnableConfig | StateSnapshot>","CHECKPOINT_NAMESPACE_END","config: RunnableConfig","config","subgraphConfig: RunnableConfig","CONFIG_KEY_CHECKPOINTER","ERROR","INTERRUPT","SCHEDULED","tasksWithWrites","readChannels","patchCheckpointMap","GraphValueError","checkpointNamespace: string","recastCheckpointNamespace","patchConfigurable","checkpointer: BaseCheckpointSaver","checkpointer: BaseCheckpointSaver | undefined","InvalidUpdateError","nextConfig","createCheckpoint","END","getNewChannelVersions","COPY","values","asNode","mapInput","tasks","validUpdates: Array<{\n        values: Record<string, unknown> | unknown;\n        asNode: keyof Nodes | string;\n        taskId?: string;\n      }>","tasks: PregelExecutableTask<keyof Nodes, keyof Channels>[]","RunnableSequence","CONFIG_KEY_SEND","CONFIG_KEY_READ","_localRead","PUSH","defaultStreamMode: StreamMode[]","CONFIG_KEY_TASK_ID","defaultCheckpointer: BaseCheckpointSaver | undefined","defaultStore: BaseStore | undefined","defaultCache: BaseCache | undefined","checkpointDuringDurability: Durability | undefined","defaultDurability: Durability","CONFIG_KEY_DURABILITY","combineAbortSignals","IterableReadableStreamWithAbortSignal","toEventStream","combineCallbacks","ensureLangGraphConfig","IterableReadableWritableStream","ns: string","CONFIG_KEY_CHECKPOINT_NS","StreamMessagesHandler","getConfig","interrupt","_coerceToDict","getOnlyChannels","loop: PregelLoop | undefined","loopError: unknown","PregelLoop","PregelRunner","CONFIG_KEY_NODE_FINISHED","CONFIG_KEY_STREAM","interruptChunks: Interrupt[][]","latest: OutputType | undefined","isInterrupted","GraphRecursionError"],"sources":["../../src/pregel/index.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport {\n  _coerceToRunnable,\n  getCallbackManagerForConfig,\n  mergeConfigs,\n  patchConfig,\n  Runnable,\n  RunnableConfig,\n  RunnableFunc,\n  RunnableLike,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport type { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport {\n  All,\n  BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n  CheckpointListOptions,\n  CheckpointMetadata,\n  CheckpointTuple,\n  compareChannelVersions,\n  copyCheckpoint,\n  emptyCheckpoint,\n  PendingWrite,\n  SCHEDULED,\n  SendProtocol,\n  uuid5,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n  getOnlyChannels,\n} from \"../channels/base.js\";\nimport {\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_NODE_FINISHED,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_SEND,\n  CONFIG_KEY_STREAM,\n  CONFIG_KEY_TASK_ID,\n  COPY,\n  END,\n  ERROR,\n  INPUT,\n  INTERRUPT,\n  Interrupt,\n  isInterrupted,\n  NULL_TASK_ID,\n  PUSH,\n  CONFIG_KEY_DURABILITY,\n  CONFIG_KEY_CHECKPOINT_NS,\n  type CommandInstance,\n  TASKS,\n} from \"../constants.js\";\nimport {\n  GraphRecursionError,\n  GraphValueError,\n  InvalidUpdateError,\n} from \"../errors.js\";\nimport { gatherIterator, patchConfigurable } from \"../utils.js\";\nimport {\n  _applyWrites,\n  _localRead,\n  _prepareNextTasks,\n  StrRecord,\n  WritesProtocol,\n} from \"./algo.js\";\nimport {\n  printStepCheckpoint,\n  printStepTasks,\n  printStepWrites,\n  tasksWithWrites,\n} from \"./debug.js\";\nimport { mapInput, readChannels } from \"./io.js\";\nimport { PregelLoop } from \"./loop.js\";\nimport { StreamMessagesHandler } from \"./messages.js\";\nimport { PregelNode } from \"./read.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { PregelRunner } from \"./runner.js\";\nimport {\n  IterableReadableStreamWithAbortSignal,\n  IterableReadableWritableStream,\n  toEventStream,\n} from \"./stream.js\";\nimport type {\n  Durability,\n  GetStateOptions,\n  MultipleChannelSubscriptionOptions,\n  PregelExecutableTask,\n  PregelInputType,\n  PregelInterface,\n  PregelOptions,\n  PregelOutputType,\n  PregelParams,\n  SingleChannelSubscriptionOptions,\n  StateSnapshot,\n  StreamMode,\n  StreamOutputMap,\n} from \"./types.js\";\nimport {\n  ensureLangGraphConfig,\n  getConfig,\n  recastCheckpointNamespace,\n} from \"./utils/config.js\";\nimport {\n  _coerceToDict,\n  combineAbortSignals,\n  combineCallbacks,\n  getNewChannelVersions,\n  patchCheckpointMap,\n  RetryPolicy,\n} from \"./utils/index.js\";\nimport { findSubgraphPregel } from \"./utils/subgraph.js\";\nimport { validateGraph, validateKeys } from \"./validate.js\";\nimport { ChannelWrite, ChannelWriteEntry, PASSTHROUGH } from \"./write.js\";\nimport { Topic } from \"../channels/topic.js\";\nimport { interrupt } from \"../interrupt.js\";\n\ntype WriteValue = Runnable | RunnableFunc<unknown, unknown> | unknown;\ntype StreamEventsOptions = Parameters<Runnable[\"streamEvents\"]>[2];\n\n/**\n * Utility class for working with channels in the Pregel system.\n * Provides static methods for subscribing to channels and writing to them.\n *\n * Channels are the communication pathways between nodes in a Pregel graph.\n * They enable message passing and state updates between different parts of the graph.\n */\nexport class Channel {\n  /**\n   * Creates a PregelNode that subscribes to a single channel.\n   * This is used to define how nodes receive input from channels.\n   *\n   * @example\n   * ```typescript\n   * // Subscribe to a single channel\n   * const node = Channel.subscribeTo(\"messages\");\n   *\n   * // Subscribe to multiple channels\n   * const node = Channel.subscribeTo([\"messages\", \"state\"]);\n   *\n   * // Subscribe with a custom key\n   * const node = Channel.subscribeTo(\"messages\", { key: \"chat\" });\n   * ```\n   *\n   * @param channel Single channel name to subscribe to\n   * @param options Subscription options\n   * @returns A PregelNode configured to receive from the specified channels\n   * @throws {Error} If a key is specified when subscribing to multiple channels\n   */\n  static subscribeTo(\n    channel: string,\n    options?: SingleChannelSubscriptionOptions\n  ): PregelNode;\n\n  /**\n   * Creates a PregelNode that subscribes to multiple channels.\n   * This is used to define how nodes receive input from channels.\n   *\n   * @example\n   * ```typescript\n   * // Subscribe to a single channel\n   * const node = Channel.subscribeTo(\"messages\");\n   *\n   * // Subscribe to multiple channels\n   * const node = Channel.subscribeTo([\"messages\", \"state\"]);\n   *\n   * // Subscribe with a custom key\n   * const node = Channel.subscribeTo(\"messages\", { key: \"chat\" });\n   * ```\n   *\n   * @param channels Single channel name to subscribe to\n   * @param options Subscription options\n   * @returns A PregelNode configured to receive from the specified channels\n   * @throws {Error} If a key is specified when subscribing to multiple channels\n   */\n  static subscribeTo(\n    channels: string[],\n    options?: MultipleChannelSubscriptionOptions\n  ): PregelNode;\n\n  static subscribeTo(\n    channels: string | string[],\n    options?:\n      | SingleChannelSubscriptionOptions\n      | MultipleChannelSubscriptionOptions\n  ): PregelNode {\n    const { key, tags } = {\n      key: undefined,\n      tags: undefined,\n      ...(options ?? {}),\n    };\n    if (Array.isArray(channels) && key !== undefined) {\n      throw new Error(\n        \"Can't specify a key when subscribing to multiple channels\"\n      );\n    }\n\n    let channelMappingOrArray: string[] | Record<string, string>;\n\n    if (typeof channels === \"string\") {\n      if (key) {\n        channelMappingOrArray = { [key]: channels };\n      } else {\n        channelMappingOrArray = [channels];\n      }\n    } else {\n      channelMappingOrArray = Object.fromEntries(\n        channels.map((chan) => [chan, chan])\n      );\n    }\n\n    const triggers: string[] = Array.isArray(channels) ? channels : [channels];\n\n    return new PregelNode({\n      channels: channelMappingOrArray,\n      triggers,\n      tags,\n    });\n  }\n\n  /**\n   * Creates a ChannelWrite that specifies how to write values to channels.\n   * This is used to define how nodes send output to channels.\n   *\n   * @example\n   * ```typescript\n   * // Write to multiple channels\n   * const write = Channel.writeTo([\"output\", \"state\"]);\n   *\n   * // Write with specific values\n   * const write = Channel.writeTo([\"output\"], {\n   *   state: \"completed\",\n   *   result: calculateResult()\n   * });\n   *\n   * // Write with a transformation function\n   * const write = Channel.writeTo([\"output\"], {\n   *   result: (x) => processResult(x)\n   * });\n   * ```\n   *\n   * @param channels - Array of channel names to write to\n   * @param writes - Optional map of channel names to values or transformations\n   * @returns A ChannelWrite object that can be used to write to the specified channels\n   */\n  static writeTo(\n    channels: string[],\n    writes?: Record<string, WriteValue>\n  ): ChannelWrite {\n    const channelWriteEntries: Array<ChannelWriteEntry> = [];\n\n    for (const channel of channels) {\n      channelWriteEntries.push({\n        channel,\n        value: PASSTHROUGH,\n        skipNone: false,\n      });\n    }\n\n    for (const [key, value] of Object.entries(writes ?? {})) {\n      if (Runnable.isRunnable(value) || typeof value === \"function\") {\n        channelWriteEntries.push({\n          channel: key,\n          value: PASSTHROUGH,\n          skipNone: true,\n          mapper: _coerceToRunnable(value as RunnableLike),\n        });\n      } else {\n        channelWriteEntries.push({\n          channel: key,\n          value,\n          skipNone: false,\n        });\n      }\n    }\n\n    return new ChannelWrite(channelWriteEntries);\n  }\n}\n\nexport type { PregelInputType, PregelOptions, PregelOutputType };\n\n// This is a workaround to allow Pregel to override `invoke` / `stream` and `withConfig`\n// without having to adhere to the types in the `Runnable` class (thanks to `any`).\n// Alternatively we could mark those methods with @ts-ignore / @ts-expect-error,\n// but these do not get carried over when building via `tsc`.\nclass PartialRunnable<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  override invoke(\n    _input: RunInput,\n    _options?: Partial<CallOptions>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    throw new Error(\"Not implemented\");\n  }\n\n  // Overriden by `Pregel`\n  override withConfig(_config: CallOptions): typeof this {\n    return super.withConfig(_config) as typeof this;\n  }\n\n  // Overriden by `Pregel`\n  override stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<IterableReadableStream<any>> {\n    return super.stream(input, options);\n  }\n}\n\n/**\n * The Pregel class is the core runtime engine of LangGraph, implementing a message-passing graph computation model\n * inspired by [Google's Pregel system](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/).\n * It provides the foundation for building reliable, controllable agent workflows that can evolve state over time.\n *\n * Key features:\n * - Message passing between nodes in discrete \"supersteps\"\n * - Built-in persistence layer through checkpointers\n * - First-class streaming support for values, updates, and events\n * - Human-in-the-loop capabilities via interrupts\n * - Support for parallel node execution within supersteps\n *\n * The Pregel class is not intended to be instantiated directly by consumers. Instead, use the following higher-level APIs:\n * - {@link StateGraph}: The main graph class for building agent workflows\n *   - Compiling a {@link StateGraph} will return a {@link CompiledGraph} instance, which extends `Pregel`\n * - Functional API: A declarative approach using tasks and entrypoints\n *   - A `Pregel` instance is returned by the {@link entrypoint} function\n *\n * @example\n * ```typescript\n * // Using StateGraph API\n * const graph = new StateGraph(annotation)\n *   .addNode(\"nodeA\", myNodeFunction)\n *   .addEdge(\"nodeA\", \"nodeB\")\n *   .compile();\n *\n * // The compiled graph is a Pregel instance\n * const result = await graph.invoke(input);\n * ```\n *\n * @example\n * ```typescript\n * // Using Functional API\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * // Define tasks that can be composed\n * const addOne = task(\"add\", async (x: number) => x + 1);\n *\n * // Create a workflow using the entrypoint function\n * const workflow = entrypoint({\n *   name: \"workflow\",\n *   checkpointer: new MemorySaver()\n * }, async (numbers: number[]) => {\n *   // Tasks can be run in parallel\n *   const results = await Promise.all(numbers.map(n => addOne(n)));\n *   return results;\n * });\n *\n * // The workflow is a Pregel instance\n * const result = await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} or {@link ManagedValueSpec} implementations\n * @typeParam ContextType - Type of context that can be passed to the graph\n * @typeParam InputType - Type of input values accepted by the graph\n * @typeParam OutputType - Type of output values produced by the graph\n */\nexport class Pregel<\n    Nodes extends StrRecord<string, PregelNode>,\n    Channels extends StrRecord<string, BaseChannel>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ContextType extends Record<string, any> = StrRecord<string, any>,\n    InputType = PregelInputType,\n    OutputType = PregelOutputType,\n    StreamUpdatesType = InputType,\n    StreamValuesType = OutputType,\n    NodeReturnType = unknown,\n    CommandType = CommandInstance,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    StreamCustom = any\n  >\n  extends PartialRunnable<\n    InputType | CommandType | null,\n    OutputType,\n    PregelOptions<Nodes, Channels, ContextType>\n  >\n  implements PregelInterface<Nodes, Channels, ContextType>\n{\n  /**\n   * Name of the class when serialized\n   * @internal\n   */\n  static lc_name() {\n    return \"LangGraph\";\n  }\n\n  /** @internal Used for type inference */\n  declare \"~InputType\": InputType;\n\n  /** @internal Used for type inference */\n  declare \"~OutputType\": OutputType;\n\n  /** @internal LangChain namespace for serialization necessary because Pregel extends Runnable */\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  /** @internal Flag indicating this is a Pregel instance - necessary for serialization */\n  lg_is_pregel = true;\n\n  /** The nodes in the graph, mapping node names to their PregelNode instances */\n  nodes: Nodes;\n\n  /** The channels in the graph, mapping channel names to their BaseChannel or ManagedValueSpec instances */\n  channels: Channels;\n\n  /**\n   * The input channels for the graph. These channels receive the initial input when the graph is invoked.\n   * Can be a single channel key or an array of channel keys.\n   */\n  inputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * The output channels for the graph. These channels contain the final output when the graph completes.\n   * Can be a single channel key or an array of channel keys.\n   */\n  outputChannels: keyof Channels | Array<keyof Channels>;\n\n  /** Whether to automatically validate the graph structure when it is compiled. Defaults to true. */\n  autoValidate: boolean = true;\n\n  /**\n   * The streaming modes enabled for this graph. Defaults to [\"values\"].\n   * Supported modes:\n   * - \"values\": Streams the full state after each step\n   * - \"updates\": Streams state updates after each step\n   * - \"messages\": Streams messages from within nodes\n   * - \"custom\": Streams custom events from within nodes\n   * - \"debug\": Streams events related to the execution of the graph - useful for tracing & debugging graph execution\n   */\n  streamMode: StreamMode[] = [\"values\"];\n\n  /**\n   * Optional channels to stream. If not specified, all channels will be streamed.\n   * Can be a single channel key or an array of channel keys.\n   */\n  streamChannels?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * Optional array of node names or \"all\" to interrupt after executing these nodes.\n   * Used for implementing human-in-the-loop workflows.\n   */\n  interruptAfter?: Array<keyof Nodes> | All;\n\n  /**\n   * Optional array of node names or \"all\" to interrupt before executing these nodes.\n   * Used for implementing human-in-the-loop workflows.\n   */\n  interruptBefore?: Array<keyof Nodes> | All;\n\n  /** Optional timeout in milliseconds for the execution of each superstep */\n  stepTimeout?: number;\n\n  /** Whether to enable debug logging. Defaults to false. */\n  debug: boolean = false;\n\n  /**\n   * Optional checkpointer for persisting graph state.\n   * When provided, saves a checkpoint of the graph state at every superstep.\n   * When false or undefined, checkpointing is disabled, and the graph will not be able to save or restore state.\n   */\n  checkpointer?: BaseCheckpointSaver | boolean;\n\n  /** Optional retry policy for handling failures in node execution */\n  retryPolicy?: RetryPolicy;\n\n  /** The default configuration for graph execution, can be overridden on a per-invocation basis */\n  config?: LangGraphRunnableConfig;\n\n  /**\n   * Optional long-term memory store for the graph, allows for persistence & retrieval of data across threads\n   */\n  store?: BaseStore;\n\n  /**\n   * Optional cache for the graph, useful for caching tasks.\n   */\n  cache?: BaseCache;\n\n  /**\n   * Optional interrupt helper function.\n   * @internal\n   */\n  private userInterrupt?: unknown;\n\n  /**\n   * The trigger to node mapping for the graph run.\n   * @internal\n   */\n  private triggerToNodes: Record<string, string[]> = {};\n\n  /**\n   * Constructor for Pregel - meant for internal use only.\n   *\n   * @internal\n   */\n  constructor(fields: PregelParams<Nodes, Channels>) {\n    super(fields);\n\n    let { streamMode } = fields;\n    if (streamMode != null && !Array.isArray(streamMode)) {\n      streamMode = [streamMode];\n    }\n\n    this.nodes = fields.nodes;\n    this.channels = fields.channels;\n\n    if (\n      TASKS in this.channels &&\n      \"lc_graph_name\" in this.channels[TASKS] &&\n      this.channels[TASKS].lc_graph_name !== \"Topic\"\n    ) {\n      throw new Error(\n        `Channel '${TASKS}' is reserved and cannot be used in the graph.`\n      );\n    } else {\n      (this.channels as Record<string, BaseChannel>)[TASKS] =\n        new Topic<SendProtocol>({ accumulate: false });\n    }\n\n    this.autoValidate = fields.autoValidate ?? this.autoValidate;\n    this.streamMode = streamMode ?? this.streamMode;\n    this.inputChannels = fields.inputChannels;\n    this.outputChannels = fields.outputChannels;\n    this.streamChannels = fields.streamChannels ?? this.streamChannels;\n    this.interruptAfter = fields.interruptAfter;\n    this.interruptBefore = fields.interruptBefore;\n    this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;\n    this.debug = fields.debug ?? this.debug;\n    this.checkpointer = fields.checkpointer;\n    this.retryPolicy = fields.retryPolicy;\n    this.config = fields.config;\n    this.store = fields.store;\n    this.cache = fields.cache;\n    this.name = fields.name;\n    this.triggerToNodes = fields.triggerToNodes ?? this.triggerToNodes;\n    this.userInterrupt = fields.userInterrupt;\n\n    if (this.autoValidate) {\n      this.validate();\n    }\n  }\n\n  /**\n   * Creates a new instance of the Pregel graph with updated configuration.\n   * This method follows the immutable pattern - instead of modifying the current instance,\n   * it returns a new instance with the merged configuration.\n   *\n   * @example\n   * ```typescript\n   * // Create a new instance with debug enabled\n   * const debugGraph = graph.withConfig({ debug: true });\n   *\n   * // Create a new instance with a specific thread ID\n   * const threadGraph = graph.withConfig({\n   *   configurable: { thread_id: \"123\" }\n   * });\n   * ```\n   *\n   * @param config - The configuration to merge with the current configuration\n   * @returns A new Pregel instance with the merged configuration\n   */\n  override withConfig(\n    config: Omit<LangGraphRunnableConfig, \"store\" | \"writer\" | \"interrupt\">\n  ): typeof this {\n    const mergedConfig = mergeConfigs(this.config, config);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new (this.constructor as any)({ ...this, config: mergedConfig });\n  }\n\n  /**\n   * Validates the graph structure to ensure it is well-formed.\n   * Checks for:\n   * - No orphaned nodes\n   * - Valid input/output channel configurations\n   * - Valid interrupt configurations\n   *\n   * @returns this - The Pregel instance for method chaining\n   * @throws {GraphValidationError} If the graph structure is invalid\n   */\n  validate(): this {\n    validateGraph<Nodes, Channels>({\n      nodes: this.nodes,\n      channels: this.channels,\n      outputChannels: this.outputChannels,\n      inputChannels: this.inputChannels,\n      streamChannels: this.streamChannels,\n      interruptAfterNodes: this.interruptAfter,\n      interruptBeforeNodes: this.interruptBefore,\n    });\n\n    for (const [name, node] of Object.entries(this.nodes)) {\n      for (const trigger of node.triggers) {\n        this.triggerToNodes[trigger] ??= [];\n        this.triggerToNodes[trigger].push(name);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets a list of all channels that should be streamed.\n   * If streamChannels is specified, returns those channels.\n   * Otherwise, returns all channels in the graph.\n   *\n   * @returns Array of channel keys to stream\n   */\n  get streamChannelsList(): Array<keyof Channels> {\n    if (Array.isArray(this.streamChannels)) {\n      return this.streamChannels;\n    } else if (this.streamChannels) {\n      return [this.streamChannels];\n    } else {\n      return Object.keys(this.channels);\n    }\n  }\n\n  /**\n   * Gets the channels to stream in their original format.\n   * If streamChannels is specified, returns it as-is (either single key or array).\n   * Otherwise, returns all channels in the graph as an array.\n   *\n   * @returns Channel keys to stream, either as a single key or array\n   */\n  get streamChannelsAsIs(): keyof Channels | Array<keyof Channels> {\n    if (this.streamChannels) {\n      return this.streamChannels;\n    } else {\n      return Object.keys(this.channels);\n    }\n  }\n\n  /**\n   * Gets a drawable representation of the graph structure.\n   * This is an async version of getGraph() and is the preferred method to use.\n   *\n   * @param config - Configuration for generating the graph visualization\n   * @returns A representation of the graph that can be visualized\n   */\n  async getGraphAsync(config: RunnableConfig) {\n    return this.getGraph(config);\n  }\n\n  /**\n   * Gets all subgraphs within this graph.\n   * A subgraph is a Pregel instance that is nested within a node of this graph.\n   *\n   * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.\n   * @param namespace - Optional namespace to filter subgraphs\n   * @param recurse - Whether to recursively get subgraphs of subgraphs\n   * @returns Generator yielding tuples of [name, subgraph]\n   */\n  *getSubgraphs(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Generator<[string, Pregel<any, any>]> {\n    for (const [name, node] of Object.entries(this.nodes)) {\n      // filter by prefix\n      if (namespace !== undefined) {\n        if (!namespace.startsWith(name)) {\n          continue;\n        }\n      }\n      // find the subgraph if any\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      type SubgraphPregelType = Pregel<any, any> | undefined;\n\n      const candidates = node.subgraphs?.length ? node.subgraphs : [node.bound];\n\n      for (const candidate of candidates) {\n        const graph = findSubgraphPregel(candidate) as SubgraphPregelType;\n\n        if (graph !== undefined) {\n          if (name === namespace) {\n            yield [name, graph];\n            return;\n          }\n\n          if (namespace === undefined) {\n            yield [name, graph];\n          }\n\n          if (recurse) {\n            let newNamespace = namespace;\n            if (namespace !== undefined) {\n              newNamespace = namespace.slice(name.length + 1);\n            }\n            for (const [subgraphName, subgraph] of graph.getSubgraphs(\n              newNamespace,\n              recurse\n            )) {\n              yield [\n                `${name}${CHECKPOINT_NAMESPACE_SEPARATOR}${subgraphName}`,\n                subgraph,\n              ];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets all subgraphs within this graph asynchronously.\n   * A subgraph is a Pregel instance that is nested within a node of this graph.\n   *\n   * @param namespace - Optional namespace to filter subgraphs\n   * @param recurse - Whether to recursively get subgraphs of subgraphs\n   * @returns AsyncGenerator yielding tuples of [name, subgraph]\n   */\n  async *getSubgraphsAsync(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<[string, Pregel<any, any>]> {\n    yield* this.getSubgraphs(namespace, recurse);\n  }\n\n  /**\n   * Prepares a state snapshot from saved checkpoint data.\n   * This is an internal method used by getState and getStateHistory.\n   *\n   * @param config - Configuration for preparing the snapshot\n   * @param saved - Optional saved checkpoint data\n   * @param subgraphCheckpointer - Optional checkpointer for subgraphs\n   * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels\n   * @returns A snapshot of the graph state\n   * @internal\n   */\n  protected async _prepareStateSnapshot({\n    config,\n    saved,\n    subgraphCheckpointer,\n    applyPendingWrites = false,\n  }: {\n    config: RunnableConfig;\n    saved?: CheckpointTuple;\n    subgraphCheckpointer?: BaseCheckpointSaver;\n    applyPendingWrites?: boolean;\n  }): Promise<StateSnapshot> {\n    if (saved === undefined) {\n      return {\n        values: {},\n        next: [],\n        config,\n        tasks: [],\n      };\n    }\n\n    // Create all channels\n    const channels = emptyChannels(\n      this.channels as Record<string, BaseChannel>,\n      saved.checkpoint\n    );\n\n    // Apply null writes first (from NULL_TASK_ID)\n    if (saved.pendingWrites?.length) {\n      const nullWrites = saved.pendingWrites\n        .filter(([taskId, _]) => taskId === NULL_TASK_ID)\n        .map(\n          ([_, channel, value]) => [String(channel), value] as [string, unknown]\n        );\n\n      if (nullWrites.length > 0) {\n        _applyWrites(\n          saved.checkpoint,\n          channels,\n          [\n            {\n              name: INPUT,\n              writes: nullWrites as PendingWrite[],\n              triggers: [],\n            },\n          ],\n          undefined,\n          this.triggerToNodes\n        );\n      }\n    }\n\n    // Prepare next tasks\n    const nextTasks = Object.values(\n      _prepareNextTasks(\n        saved.checkpoint,\n        saved.pendingWrites,\n        this.nodes,\n        channels,\n        saved.config,\n        true,\n        { step: (saved.metadata?.step ?? -1) + 1, store: this.store }\n      )\n    );\n\n    // Find subgraphs\n    const subgraphs = await gatherIterator(this.getSubgraphsAsync());\n    const parentNamespace = saved.config.configurable?.checkpoint_ns ?? \"\";\n    const taskStates: Record<string, RunnableConfig | StateSnapshot> = {};\n\n    // Prepare task states for subgraphs\n    for (const task of nextTasks) {\n      const matchingSubgraph = subgraphs.find(([name]) => name === task.name);\n      if (!matchingSubgraph) {\n        continue;\n      }\n      // assemble checkpoint_ns for this task\n      let taskNs = `${String(task.name)}${CHECKPOINT_NAMESPACE_END}${task.id}`;\n      if (parentNamespace) {\n        taskNs = `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${taskNs}`;\n      }\n      if (subgraphCheckpointer === undefined) {\n        // set config as signal that subgraph checkpoints exist\n        const config: RunnableConfig = {\n          configurable: {\n            thread_id: saved.config.configurable?.thread_id,\n            checkpoint_ns: taskNs,\n          },\n        };\n        taskStates[task.id] = config;\n      } else {\n        // get the state of the subgraph\n        const subgraphConfig: RunnableConfig = {\n          configurable: {\n            [CONFIG_KEY_CHECKPOINTER]: subgraphCheckpointer,\n            thread_id: saved.config.configurable?.thread_id,\n            checkpoint_ns: taskNs,\n          },\n        };\n        const pregel = matchingSubgraph[1];\n        taskStates[task.id] = await pregel.getState(subgraphConfig, {\n          subgraphs: true,\n        });\n      }\n    }\n\n    // Apply pending writes to tasks and then to channels if applyPendingWrites is true\n    if (applyPendingWrites && saved.pendingWrites?.length) {\n      // Map task IDs to task objects for easy lookup\n      const nextTaskById = Object.fromEntries(\n        nextTasks.map((task) => [task.id, task])\n      );\n\n      // Apply pending writes to the appropriate tasks\n      for (const [taskId, channel, value] of saved.pendingWrites) {\n        // Skip special channels and tasks not in nextTasks\n        if ([ERROR, INTERRUPT, SCHEDULED].includes(channel)) {\n          continue;\n        }\n        if (!(taskId in nextTaskById)) {\n          continue;\n        }\n        // Add the write to the task\n        nextTaskById[taskId].writes.push([String(channel), value]);\n      }\n\n      // Apply writes from tasks that have writes\n      const tasksWithWrites = nextTasks.filter(\n        (task) => task.writes.length > 0\n      );\n      if (tasksWithWrites.length > 0) {\n        _applyWrites(\n          saved.checkpoint,\n          channels,\n          tasksWithWrites as unknown as WritesProtocol[],\n          undefined,\n          this.triggerToNodes\n        );\n      }\n    }\n\n    // Preserve thread_id from the config in metadata\n    let metadata = saved?.metadata;\n    if (metadata && saved?.config?.configurable?.thread_id) {\n      metadata = {\n        ...metadata,\n        thread_id: saved.config.configurable.thread_id as string,\n      } as CheckpointMetadata;\n    }\n\n    // Filter next tasks - only include tasks without writes\n    const nextList = nextTasks\n      .filter((task) => task.writes.length === 0)\n      .map((task) => task.name as string);\n\n    // assemble the state snapshot\n    return {\n      values: readChannels(\n        channels,\n        this.streamChannelsAsIs as string | string[]\n      ),\n      next: nextList,\n      tasks: tasksWithWrites(\n        nextTasks,\n        saved?.pendingWrites ?? [],\n        taskStates,\n        this.streamChannelsAsIs\n      ),\n      metadata,\n      config: patchCheckpointMap(saved.config, saved.metadata),\n      createdAt: saved.checkpoint.ts,\n      parentConfig: saved.parentConfig,\n    };\n  }\n\n  /**\n   * Gets the current state of the graph.\n   * Requires a checkpointer to be configured.\n   *\n   * @param config - Configuration for retrieving the state\n   * @param options - Additional options\n   * @returns A snapshot of the current graph state\n   * @throws {GraphValueError} If no checkpointer is configured\n   */\n  async getState(\n    config: RunnableConfig,\n    options?: GetStateOptions\n  ): Promise<StateSnapshot> {\n    const checkpointer =\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n\n    const checkpointNamespace: string =\n      config.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      // remove task_ids from checkpoint_ns\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n      for await (const [name, subgraph] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        if (name === recastNamespace) {\n          return await subgraph.getState(\n            patchConfigurable(config, {\n              [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n            }),\n            { subgraphs: options?.subgraphs }\n          );\n        }\n      }\n      throw new Error(\n        `Subgraph with namespace \"${recastNamespace}\" not found.`\n      );\n    }\n\n    const mergedConfig = mergeConfigs(this.config, config);\n    const saved = await checkpointer.getTuple(config);\n    const snapshot = await this._prepareStateSnapshot({\n      config: mergedConfig,\n      saved,\n      subgraphCheckpointer: options?.subgraphs ? checkpointer : undefined,\n      applyPendingWrites: !config.configurable?.checkpoint_id,\n    });\n    return snapshot;\n  }\n\n  /**\n   * Gets the history of graph states.\n   * Requires a checkpointer to be configured.\n   * Useful for:\n   * - Debugging execution history\n   * - Implementing time travel\n   * - Analyzing graph behavior\n   *\n   * @param config - Configuration for retrieving the history\n   * @param options - Options for filtering the history\n   * @returns An async iterator of state snapshots\n   * @throws {Error} If no checkpointer is configured\n   */\n  async *getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot> {\n    const checkpointer: BaseCheckpointSaver =\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n\n    const checkpointNamespace: string =\n      config.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n\n      // find the subgraph with the matching name\n      for await (const [name, pregel] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        if (name === recastNamespace) {\n          yield* pregel.getStateHistory(\n            patchConfigurable(config, {\n              [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n            }),\n            options\n          );\n          return;\n        }\n      }\n      throw new Error(\n        `Subgraph with namespace \"${recastNamespace}\" not found.`\n      );\n    }\n\n    const mergedConfig = mergeConfigs(this.config, config, {\n      configurable: { checkpoint_ns: checkpointNamespace },\n    });\n\n    for await (const checkpointTuple of checkpointer.list(\n      mergedConfig,\n      options\n    )) {\n      yield this._prepareStateSnapshot({\n        config: checkpointTuple.config,\n        saved: checkpointTuple,\n      });\n    }\n  }\n\n  /**\n   * Apply updates to the graph state in bulk.\n   * Requires a checkpointer to be configured.\n   *\n   * This method is useful for recreating a thread\n   * from a list of updates, especially if a checkpoint\n   * is created as a result of multiple tasks.\n   *\n   * @internal The API might change in the future.\n   *\n   * @param startConfig - Configuration for the update\n   * @param updates - The list of updates to apply to graph state\n   * @returns Updated configuration\n   * @throws {GraphValueError} If no checkpointer is configured\n   * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.\n   */\n  async bulkUpdateState(\n    startConfig: LangGraphRunnableConfig,\n    supersteps: Array<{\n      updates: Array<{\n        values?: Record<string, unknown> | unknown;\n        asNode?: keyof Nodes | string;\n      }>;\n    }>\n  ): Promise<RunnableConfig> {\n    const checkpointer: BaseCheckpointSaver | undefined =\n      startConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n    if (supersteps.length === 0) {\n      throw new Error(\"No supersteps provided\");\n    }\n\n    if (supersteps.some((s) => s.updates.length === 0)) {\n      throw new Error(\"No updates provided\");\n    }\n\n    // delegate to subgraph\n    const checkpointNamespace: string =\n      startConfig.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      startConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      // remove task_ids from checkpoint_ns\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n      // find the subgraph with the matching name\n      // eslint-disable-next-line no-unreachable-loop\n      for await (const [, pregel] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        return await pregel.bulkUpdateState(\n          patchConfigurable(startConfig, {\n            [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n          }),\n          supersteps\n        );\n      }\n      throw new Error(`Subgraph \"${recastNamespace}\" not found`);\n    }\n\n    const updateSuperStep = async (\n      inputConfig: LangGraphRunnableConfig,\n      updates: {\n        values?: Record<string, unknown> | unknown;\n        asNode?: keyof Nodes | string;\n        taskId?: string;\n      }[]\n    ) => {\n      // get last checkpoint\n      const config = this.config\n        ? mergeConfigs(this.config, inputConfig)\n        : inputConfig;\n      const saved = await checkpointer.getTuple(config);\n      const checkpoint =\n        saved !== undefined\n          ? copyCheckpoint(saved.checkpoint)\n          : emptyCheckpoint();\n      const checkpointPreviousVersions = {\n        ...saved?.checkpoint.channel_versions,\n      };\n      const step = saved?.metadata?.step ?? -1;\n\n      // merge configurable fields with previous checkpoint config\n      let checkpointConfig = patchConfigurable(config, {\n        checkpoint_ns: config.configurable?.checkpoint_ns ?? \"\",\n      });\n      let checkpointMetadata = config.metadata ?? {};\n      if (saved?.config.configurable) {\n        checkpointConfig = patchConfigurable(config, saved.config.configurable);\n        checkpointMetadata = {\n          ...saved.metadata,\n          ...checkpointMetadata,\n        };\n      }\n\n      // Find last node that updated the state, if not provided\n      const { values, asNode } = updates[0];\n      if (values == null && asNode === undefined) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot create empty checkpoint with multiple updates`\n          );\n        }\n\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, undefined, step),\n          {\n            source: \"update\",\n            step: step + 1,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          {}\n        );\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      // update channels\n      const channels = emptyChannels(\n        this.channels as Record<string, BaseChannel>,\n        checkpoint\n      );\n\n      if (values === null && asNode === END) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot apply multiple updates when clearing state`\n          );\n        }\n\n        if (saved) {\n          // tasks for this checkpoint\n          const nextTasks = _prepareNextTasks(\n            checkpoint,\n            saved.pendingWrites || [],\n            this.nodes,\n            channels,\n            saved.config,\n            true,\n            {\n              step: (saved.metadata?.step ?? -1) + 1,\n              checkpointer,\n              store: this.store,\n            }\n          );\n\n          // apply null writes\n          const nullWrites = (saved.pendingWrites || [])\n            .filter((w) => w[0] === NULL_TASK_ID)\n            .map((w) => w.slice(1)) as PendingWrite<string>[];\n          if (nullWrites.length > 0) {\n            _applyWrites(\n              checkpoint,\n              channels,\n              [\n                {\n                  name: INPUT,\n                  writes: nullWrites,\n                  triggers: [],\n                },\n              ],\n              checkpointer.getNextVersion.bind(checkpointer),\n              this.triggerToNodes\n            );\n          }\n          // apply writes from tasks that already ran\n          for (const [taskId, k, v] of saved.pendingWrites || []) {\n            if ([ERROR, INTERRUPT, SCHEDULED].includes(k)) {\n              continue;\n            }\n            if (!(taskId in nextTasks)) {\n              continue;\n            }\n            nextTasks[taskId].writes.push([k, v]);\n          }\n          // clear all current tasks\n          _applyWrites(\n            checkpoint,\n            channels,\n            Object.values(nextTasks) as WritesProtocol<string>[],\n            checkpointer.getNextVersion.bind(checkpointer),\n            this.triggerToNodes\n          );\n        }\n        // save checkpoint\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, channels, step),\n          {\n            ...checkpointMetadata,\n            source: \"update\",\n            step: step + 1,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          getNewChannelVersions(\n            checkpointPreviousVersions,\n            checkpoint.channel_versions\n          )\n        );\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      if (asNode === COPY) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot copy checkpoint with multiple updates`\n          );\n        }\n\n        if (saved == null) {\n          throw new InvalidUpdateError(`Cannot copy a non-existent checkpoint`);\n        }\n\n        const isCopyWithUpdates = (\n          values: unknown\n        ): values is [values: unknown, asNode: string][] => {\n          if (!Array.isArray(values)) return false;\n          if (values.length === 0) return false;\n          return values.every((v) => Array.isArray(v) && v.length === 2);\n        };\n\n        const nextCheckpoint = createCheckpoint(checkpoint, undefined, step);\n        const nextConfig = await checkpointer.put(\n          saved.parentConfig ??\n            patchConfigurable(saved.config, { checkpoint_id: undefined }),\n          nextCheckpoint,\n          {\n            source: \"fork\",\n            step: step + 1,\n            parents: saved.metadata?.parents ?? {},\n          },\n          {}\n        );\n\n        // We want to both clone a checkpoint and update state in one go.\n        // Reuse the same task ID if possible.\n        if (isCopyWithUpdates(values)) {\n          // figure out the task IDs for the next update checkpoint\n          const nextTasks = _prepareNextTasks(\n            nextCheckpoint,\n            saved.pendingWrites,\n            this.nodes,\n            channels,\n            nextConfig,\n            false,\n            { step: step + 2 }\n          );\n\n          const tasksGroupBy = Object.values(nextTasks).reduce<\n            Record<string, { id: string }[]>\n          >((acc, { name, id }) => {\n            acc[name] ??= [];\n            acc[name].push({ id });\n            return acc;\n          }, {});\n\n          const userGroupBy = values.reduce<\n            Record<\n              string,\n              { values: unknown; asNode: string; taskId?: string }[]\n            >\n          >((acc, item) => {\n            const [values, asNode] = item;\n            acc[asNode] ??= [];\n\n            const targetIdx = acc[asNode].length;\n            const taskId = tasksGroupBy[asNode]?.[targetIdx]?.id;\n            acc[asNode].push({ values, asNode, taskId });\n\n            return acc;\n          }, {});\n\n          return updateSuperStep(\n            patchCheckpointMap(nextConfig, saved.metadata),\n            Object.values(userGroupBy).flat()\n          );\n        }\n\n        return patchCheckpointMap(nextConfig, saved.metadata);\n      }\n\n      if (asNode === INPUT) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot apply multiple updates when updating as input`\n          );\n        }\n\n        const inputWrites = await gatherIterator(\n          mapInput(this.inputChannels, values)\n        );\n        if (inputWrites.length === 0) {\n          throw new InvalidUpdateError(\n            `Received no input writes for ${JSON.stringify(\n              this.inputChannels,\n              null,\n              2\n            )}`\n          );\n        }\n\n        // apply to checkpoint\n        _applyWrites(\n          checkpoint,\n          channels,\n          [\n            {\n              name: INPUT,\n              writes: inputWrites as PendingWrite[],\n              triggers: [],\n            },\n          ],\n          checkpointer.getNextVersion.bind(this.checkpointer),\n          this.triggerToNodes\n        );\n\n        // apply input write to channels\n        const nextStep =\n          saved?.metadata?.step != null ? saved.metadata.step + 1 : -1;\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, channels, nextStep),\n          {\n            source: \"input\",\n            step: nextStep,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          getNewChannelVersions(\n            checkpointPreviousVersions,\n            checkpoint.channel_versions\n          )\n        );\n\n        // Store the writes\n        await checkpointer.putWrites(\n          nextConfig,\n          inputWrites as PendingWrite[],\n          uuid5(INPUT, checkpoint.id)\n        );\n\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      // apply pending writes, if not on specific checkpoint\n      if (\n        config.configurable?.checkpoint_id === undefined &&\n        saved?.pendingWrites !== undefined &&\n        saved.pendingWrites.length > 0\n      ) {\n        // tasks for this checkpoint\n        const nextTasks = _prepareNextTasks(\n          checkpoint,\n          saved.pendingWrites,\n          this.nodes,\n          channels,\n          saved.config,\n          true,\n          {\n            store: this.store,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            checkpointer: this.checkpointer as any,\n            step: (saved.metadata?.step ?? -1) + 1,\n          }\n        );\n        // apply null writes\n        const nullWrites = (saved.pendingWrites ?? [])\n          .filter((w) => w[0] === NULL_TASK_ID)\n          .map((w) => w.slice(1)) as PendingWrite<string>[];\n        if (nullWrites.length > 0) {\n          _applyWrites(\n            saved.checkpoint,\n            channels,\n            [{ name: INPUT, writes: nullWrites, triggers: [] }],\n            undefined,\n            this.triggerToNodes\n          );\n        }\n        // apply writes\n        for (const [tid, k, v] of saved.pendingWrites) {\n          if (\n            [ERROR, INTERRUPT, SCHEDULED].includes(k) ||\n            nextTasks[tid] === undefined\n          ) {\n            continue;\n          }\n          nextTasks[tid].writes.push([k, v]);\n        }\n        const tasks = Object.values(nextTasks).filter((task) => {\n          return task.writes.length > 0;\n        });\n        if (tasks.length > 0) {\n          _applyWrites(\n            checkpoint,\n            channels,\n            tasks as WritesProtocol[],\n            undefined,\n            this.triggerToNodes\n          );\n        }\n      }\n      const nonNullVersion = Object.values(checkpoint.versions_seen)\n        .map((seenVersions) => {\n          return Object.values(seenVersions);\n        })\n        .flat()\n        .find((v) => !!v);\n\n      const validUpdates: Array<{\n        values: Record<string, unknown> | unknown;\n        asNode: keyof Nodes | string;\n        taskId?: string;\n      }> = [];\n\n      if (updates.length === 1) {\n        // eslint-disable-next-line prefer-const\n        let { values, asNode, taskId } = updates[0];\n        if (asNode === undefined && Object.keys(this.nodes).length === 1) {\n          // if only one node, use it\n          [asNode] = Object.keys(this.nodes);\n        } else if (asNode === undefined && nonNullVersion === undefined) {\n          if (\n            typeof this.inputChannels === \"string\" &&\n            this.nodes[this.inputChannels] !== undefined\n          ) {\n            asNode = this.inputChannels;\n          }\n        } else if (asNode === undefined) {\n          const lastSeenByNode = Object.entries(checkpoint.versions_seen)\n            .map(([n, seen]) => {\n              return Object.values(seen).map((v) => {\n                return [v, n] as const;\n              });\n            })\n            .flat()\n            .filter(([_, v]) => v !== INTERRUPT)\n            .sort(([aNumber], [bNumber]) =>\n              compareChannelVersions(aNumber, bNumber)\n            );\n          // if two nodes updated the state at the same time, it's ambiguous\n          if (lastSeenByNode) {\n            if (lastSeenByNode.length === 1) {\n              // eslint-disable-next-line prefer-destructuring\n              asNode = lastSeenByNode[0][1];\n            } else if (\n              lastSeenByNode[lastSeenByNode.length - 1][0] !==\n              lastSeenByNode[lastSeenByNode.length - 2][0]\n            ) {\n              // eslint-disable-next-line prefer-destructuring\n              asNode = lastSeenByNode[lastSeenByNode.length - 1][1];\n            }\n          }\n        }\n\n        if (asNode === undefined) {\n          throw new InvalidUpdateError(`Ambiguous update, specify \"asNode\"`);\n        }\n\n        validUpdates.push({ values, asNode, taskId });\n      } else {\n        for (const { asNode, values, taskId } of updates) {\n          if (asNode == null) {\n            throw new InvalidUpdateError(\n              `\"asNode\" is required when applying multiple updates`\n            );\n          }\n\n          validUpdates.push({ values, asNode, taskId });\n        }\n      }\n\n      const tasks: PregelExecutableTask<keyof Nodes, keyof Channels>[] = [];\n      for (const { asNode, values, taskId } of validUpdates) {\n        if (this.nodes[asNode] === undefined) {\n          throw new InvalidUpdateError(\n            `Node \"${asNode.toString()}\" does not exist`\n          );\n        }\n\n        // run all writers of the chosen node\n        const writers = this.nodes[asNode].getWriters();\n        if (!writers.length) {\n          throw new InvalidUpdateError(\n            `No writers found for node \"${asNode.toString()}\"`\n          );\n        }\n        tasks.push({\n          name: asNode,\n          input: values,\n          proc:\n            writers.length > 1\n              ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                RunnableSequence.from(writers as any, {\n                  omitSequenceTags: true,\n                })\n              : writers[0],\n          writes: [],\n          triggers: [INTERRUPT],\n          id: taskId ?? uuid5(INTERRUPT, checkpoint.id),\n          writers: [],\n        });\n      }\n\n      for (const task of tasks) {\n        // execute task\n        await task.proc.invoke(\n          task.input,\n          patchConfig<LangGraphRunnableConfig>(\n            {\n              ...config,\n              store: config?.store ?? this.store,\n            },\n            {\n              runName: config.runName ?? `${this.getName()}UpdateState`,\n              configurable: {\n                [CONFIG_KEY_SEND]: (items: [keyof Channels, unknown][]) =>\n                  task.writes.push(...items),\n                [CONFIG_KEY_READ]: (\n                  select_: Array<keyof Channels> | keyof Channels,\n                  fresh_: boolean = false\n                ) =>\n                  _localRead(\n                    checkpoint,\n                    channels,\n                    // TODO: Why does keyof StrRecord allow number and symbol?\n                    task as PregelExecutableTask<string, string>,\n                    select_ as string | string[],\n                    fresh_\n                  ),\n              },\n            }\n          )\n        );\n      }\n\n      for (const task of tasks) {\n        // channel writes are saved to current checkpoint\n        const channelWrites = task.writes.filter((w) => w[0] !== PUSH);\n        // save task writes\n        if (saved !== undefined && channelWrites.length > 0) {\n          await checkpointer.putWrites(\n            checkpointConfig,\n            channelWrites as PendingWrite[],\n            task.id\n          );\n        }\n      }\n\n      // apply to checkpoint\n      // TODO: Why does keyof StrRecord allow number and symbol?\n      _applyWrites(\n        checkpoint,\n        channels,\n        tasks as PregelExecutableTask<string, string>[],\n        checkpointer.getNextVersion.bind(this.checkpointer),\n        this.triggerToNodes\n      );\n\n      const newVersions = getNewChannelVersions(\n        checkpointPreviousVersions,\n        checkpoint.channel_versions\n      );\n      const nextConfig = await checkpointer.put(\n        checkpointConfig,\n        createCheckpoint(checkpoint, channels, step + 1),\n        {\n          source: \"update\",\n          step: step + 1,\n          parents: saved?.metadata?.parents ?? {},\n        },\n        newVersions\n      );\n\n      for (const task of tasks) {\n        // push writes are saved to next checkpoint\n        const pushWrites = task.writes.filter((w) => w[0] === PUSH);\n\n        if (pushWrites.length > 0) {\n          await checkpointer.putWrites(\n            nextConfig,\n            pushWrites as PendingWrite[],\n            task.id\n          );\n        }\n      }\n\n      return patchCheckpointMap(nextConfig, saved ? saved.metadata : undefined);\n    };\n\n    let currentConfig = startConfig;\n    for (const { updates } of supersteps) {\n      currentConfig = await updateSuperStep(currentConfig, updates);\n    }\n\n    return currentConfig;\n  }\n\n  /**\n   * Updates the state of the graph with new values.\n   * Requires a checkpointer to be configured.\n   *\n   * This method can be used for:\n   * - Implementing human-in-the-loop workflows\n   * - Modifying graph state during breakpoints\n   * - Integrating external inputs into the graph\n   *\n   * @param inputConfig - Configuration for the update\n   * @param values - The values to update the state with\n   * @param asNode - Optional node name to attribute the update to\n   * @returns Updated configuration\n   * @throws {GraphValueError} If no checkpointer is configured\n   * @throws {InvalidUpdateError} If the update cannot be attributed to a node\n   */\n  async updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: keyof Nodes | string\n  ): Promise<RunnableConfig> {\n    return this.bulkUpdateState(inputConfig, [\n      { updates: [{ values, asNode }] },\n    ]);\n  }\n\n  /**\n   * Gets the default values for various graph configuration options.\n   * This is an internal method used to process and normalize configuration options.\n   *\n   * @param config - The input configuration options\n   * @returns A tuple containing normalized values for:\n   * - debug mode\n   * - stream modes\n   * - input keys\n   * - output keys\n   * - remaining config\n   * - interrupt before nodes\n   * - interrupt after nodes\n   * - checkpointer\n   * - store\n   * - whether stream mode is single\n   * - node cache\n   * - whether checkpoint during is enabled\n   * @internal\n   */\n  _defaults(config: PregelOptions<Nodes, Channels>): [\n    boolean, // debug\n    StreamMode[], // stream mode\n    string | string[], // input keys\n    string | string[], // output keys\n    LangGraphRunnableConfig, // config without pregel keys\n    All | string[], // interrupt before\n    All | string[], // interrupt after\n    BaseCheckpointSaver | undefined, // checkpointer\n    BaseStore | undefined, // store\n    boolean, // stream mode single\n    BaseCache | undefined, // node cache\n    Durability // durability\n  ] {\n    const {\n      debug,\n      streamMode,\n      inputKeys,\n      outputKeys,\n      interruptAfter,\n      interruptBefore,\n      ...rest\n    } = config;\n    let streamModeSingle = true;\n    const defaultDebug = debug !== undefined ? debug : this.debug;\n\n    let defaultOutputKeys = outputKeys;\n    if (defaultOutputKeys === undefined) {\n      defaultOutputKeys = this.streamChannelsAsIs;\n    } else {\n      validateKeys(defaultOutputKeys, this.channels);\n    }\n\n    let defaultInputKeys = inputKeys;\n    if (defaultInputKeys === undefined) {\n      defaultInputKeys = this.inputChannels;\n    } else {\n      validateKeys(defaultInputKeys, this.channels);\n    }\n\n    const defaultInterruptBefore =\n      interruptBefore ?? this.interruptBefore ?? [];\n\n    const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];\n\n    let defaultStreamMode: StreamMode[];\n    if (streamMode !== undefined) {\n      defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];\n      streamModeSingle = typeof streamMode === \"string\";\n    } else {\n      // if being called as a node in another graph, default to values mode\n      // but don't overwrite `streamMode`if provided\n      if (config.configurable?.[CONFIG_KEY_TASK_ID] !== undefined) {\n        defaultStreamMode = [\"values\"];\n      } else {\n        defaultStreamMode = this.streamMode;\n      }\n\n      streamModeSingle = true;\n    }\n\n    let defaultCheckpointer: BaseCheckpointSaver | undefined;\n    if (this.checkpointer === false) {\n      defaultCheckpointer = undefined;\n    } else if (\n      config !== undefined &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] !== undefined\n    ) {\n      defaultCheckpointer = config.configurable[CONFIG_KEY_CHECKPOINTER];\n    } else if (this.checkpointer === true) {\n      throw new Error(\"checkpointer: true cannot be used for root graphs.\");\n    } else {\n      defaultCheckpointer = this.checkpointer;\n    }\n    const defaultStore: BaseStore | undefined = config.store ?? this.store;\n    const defaultCache: BaseCache | undefined = config.cache ?? this.cache;\n\n    if (config.durability != null && config.checkpointDuring != null) {\n      throw new Error(\n        \"Cannot use both `durability` and `checkpointDuring` at the same time.\"\n      );\n    }\n\n    const checkpointDuringDurability: Durability | undefined = (() => {\n      if (config.checkpointDuring == null) return undefined;\n      if (config.checkpointDuring === false) return \"exit\";\n      return \"async\";\n    })();\n\n    const defaultDurability: Durability =\n      config.durability ??\n      checkpointDuringDurability ??\n      config?.configurable?.[CONFIG_KEY_DURABILITY] ??\n      \"async\";\n\n    return [\n      defaultDebug,\n      defaultStreamMode,\n      defaultInputKeys as string | string[],\n      defaultOutputKeys as string | string[],\n      rest,\n      defaultInterruptBefore as All | string[],\n      defaultInterruptAfter as All | string[],\n      defaultCheckpointer,\n      defaultStore,\n      streamModeSingle,\n      defaultCache,\n      defaultDurability,\n    ];\n  }\n\n  /**\n   * Streams the execution of the graph, emitting state updates as they occur.\n   * This is the primary method for observing graph execution in real-time.\n   *\n   * Stream modes:\n   * - \"values\": Emits complete state after each step\n   * - \"updates\": Emits only state changes after each step\n   * - \"debug\": Emits detailed debug information\n   * - \"messages\": Emits messages from within nodes\n   * - \"custom\": Emits custom events from within nodes\n   * - \"checkpoints\": Emits checkpoints from within nodes\n   * - \"tasks\": Emits tasks from within nodes\n   *\n   * @param input - The input to start graph execution with\n   * @param options - Configuration options for streaming\n   * @returns An async iterable stream of graph state updates\n   */\n  override async stream<\n    TStreamMode extends StreamMode | StreamMode[] | undefined,\n    TSubgraphs extends boolean,\n    TEncoding extends \"text/event-stream\" | undefined\n  >(\n    input: InputType | CommandType | null,\n    options?: Partial<\n      PregelOptions<\n        Nodes,\n        Channels,\n        ContextType,\n        TStreamMode,\n        TSubgraphs,\n        TEncoding\n      >\n    >\n  ): Promise<\n    IterableReadableStream<\n      StreamOutputMap<\n        TStreamMode,\n        TSubgraphs,\n        StreamUpdatesType,\n        StreamValuesType,\n        keyof Nodes,\n        NodeReturnType,\n        StreamCustom,\n        TEncoding\n      >\n    >\n  > {\n    // The ensureConfig method called internally defaults recursionLimit to 25 if not\n    // passed directly in `options`.\n    // There is currently no way in _streamIterator to determine whether this was\n    // set by by ensureConfig or manually by the user, so we specify the bound value here\n    // and override if it is passed as an explicit param in `options`.\n    const abortController = new AbortController();\n\n    const config = {\n      recursionLimit: this.config?.recursionLimit,\n      ...options,\n      signal: combineAbortSignals(options?.signal, abortController.signal)\n        .signal,\n    };\n\n    const stream = await super.stream(input, config);\n    return new IterableReadableStreamWithAbortSignal(\n      options?.encoding === \"text/event-stream\"\n        ? toEventStream(stream)\n        : stream,\n      abortController\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<StreamEvent>;\n\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<Uint8Array>;\n\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    const abortController = new AbortController();\n\n    const config = {\n      recursionLimit: this.config?.recursionLimit,\n      ...options,\n      // Similar to `stream`, we need to pass the `config.callbacks` here,\n      // otherwise the user-provided callback will get lost in `ensureLangGraphConfig`.\n\n      // extend the callbacks with the ones from the config\n      callbacks: combineCallbacks(this.config?.callbacks, options?.callbacks),\n      signal: combineAbortSignals(options?.signal, abortController.signal)\n        .signal,\n    };\n\n    return new IterableReadableStreamWithAbortSignal(\n      super.streamEvents(input, config, streamOptions),\n      abortController\n    );\n  }\n\n  /**\n   * Validates the input for the graph.\n   * @param input - The input to validate\n   * @returns The validated input\n   * @internal\n   */\n  protected async _validateInput(input: PregelInputType) {\n    return input;\n  }\n\n  /**\n   * Validates the context options for the graph.\n   * @param context - The context options to validate\n   * @returns The validated context options\n   * @internal\n   */\n  protected async _validateContext(\n    context: Partial<LangGraphRunnableConfig[\"context\"]>\n  ): Promise<LangGraphRunnableConfig[\"context\"]> {\n    return context;\n  }\n\n  /**\n   * Internal iterator used by stream() to generate state updates.\n   * This method handles the core logic of graph execution and streaming.\n   *\n   * @param input - The input to start graph execution with\n   * @param options - Configuration options for streaming\n   * @returns AsyncGenerator yielding state updates\n   * @internal\n   */\n  override async *_streamIterator(\n    input: PregelInputType | Command,\n    options?: Partial<PregelOptions<Nodes, Channels>>\n  ): AsyncGenerator<PregelOutputType> {\n    // Skip LGP encoding option is `streamEvents` is used\n    const streamEncoding =\n      \"version\" in (options ?? {}) ? undefined : options?.encoding ?? undefined;\n    const streamSubgraphs = options?.subgraphs;\n    const inputConfig = ensureLangGraphConfig(this.config, options);\n    if (\n      inputConfig.recursionLimit === undefined ||\n      inputConfig.recursionLimit < 1\n    ) {\n      throw new Error(`Passed \"recursionLimit\" must be at least 1.`);\n    }\n    if (\n      this.checkpointer !== undefined &&\n      this.checkpointer !== false &&\n      inputConfig.configurable === undefined\n    ) {\n      throw new Error(\n        `Checkpointer requires one or more of the following \"configurable\" keys: \"thread_id\", \"checkpoint_ns\", \"checkpoint_id\"`\n      );\n    }\n\n    const validInput = await this._validateInput(input);\n    const { runId, ...restConfig } = inputConfig;\n    // assign defaults\n    const [\n      debug,\n      streamMode,\n      ,\n      outputKeys,\n      config,\n      interruptBefore,\n      interruptAfter,\n      checkpointer,\n      store,\n      streamModeSingle,\n      cache,\n      durability,\n    ] = this._defaults(restConfig);\n\n    // At entrypoint, `configurable` is an alias for `context`.\n    if (typeof config.context !== \"undefined\") {\n      config.context = await this._validateContext(config.context);\n    } else {\n      config.configurable = await this._validateContext(config.configurable);\n    }\n\n    const stream = new IterableReadableWritableStream({\n      modes: new Set(streamMode),\n    });\n\n    // set up subgraph checkpointing\n    if (this.checkpointer === true) {\n      config.configurable ??= {};\n      const ns: string = config.configurable[CONFIG_KEY_CHECKPOINT_NS] ?? \"\";\n      config.configurable[CONFIG_KEY_CHECKPOINT_NS] = ns\n        .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0])\n        .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n    }\n\n    // set up messages stream mode\n    if (streamMode.includes(\"messages\")) {\n      const messageStreamer = new StreamMessagesHandler((chunk) =>\n        stream.push(chunk)\n      );\n      const { callbacks } = config;\n      if (callbacks === undefined) {\n        config.callbacks = [messageStreamer];\n      } else if (Array.isArray(callbacks)) {\n        config.callbacks = callbacks.concat(messageStreamer);\n      } else {\n        const copiedCallbacks = callbacks.copy();\n        copiedCallbacks.addHandler(messageStreamer, true);\n        config.callbacks = copiedCallbacks;\n      }\n    }\n\n    config.writer ??= (chunk: unknown) => {\n      if (!streamMode.includes(\"custom\")) return;\n      const ns = (\n        getConfig()?.configurable?.[CONFIG_KEY_CHECKPOINT_NS] as\n          | string\n          | undefined\n      )\n        ?.split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .slice(0, -1);\n\n      stream.push([ns ?? [], \"custom\", chunk]);\n    };\n\n    config.interrupt ??= (this.userInterrupt as typeof interrupt) ?? interrupt;\n\n    const callbackManager = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager?.handleChainStart(\n      this.toJSON(), // chain\n      _coerceToDict(input, \"input\"), // inputs\n      runId, // run_id\n      undefined, // run_type\n      undefined, // tags\n      undefined, // metadata\n      config?.runName ?? this.getName() // run_name\n    );\n\n    const channelSpecs = getOnlyChannels(this.channels);\n    let loop: PregelLoop | undefined;\n    let loopError: unknown;\n\n    /**\n     * The PregelLoop will yield events from concurrent tasks as soon as they are\n     * generated. Each task can push multiple events onto the stream in any order.\n     *\n     * We use a separate background method and stream here in order to yield events\n     * from the loop to the main stream and therefore back to the user as soon as\n     * they are available.\n     */\n    const createAndRunLoop = async () => {\n      try {\n        loop = await PregelLoop.initialize({\n          input: validInput,\n          config,\n          checkpointer,\n          nodes: this.nodes,\n          channelSpecs,\n          outputKeys,\n          streamKeys: this.streamChannelsAsIs as string | string[],\n          store,\n          cache: cache as BaseCache<PendingWrite<string>[]>,\n          stream,\n          interruptAfter,\n          interruptBefore,\n          manager: runManager,\n          debug: this.debug,\n          triggerToNodes: this.triggerToNodes,\n          durability,\n        });\n\n        const runner = new PregelRunner({\n          loop,\n          nodeFinished: config.configurable?.[CONFIG_KEY_NODE_FINISHED],\n        });\n\n        if (options?.subgraphs) {\n          loop.config.configurable = {\n            ...loop.config.configurable,\n            [CONFIG_KEY_STREAM]: loop.stream,\n          };\n        }\n        await this._runLoop({ loop, runner, debug, config });\n\n        // wait for checkpoints to be persisted\n        if (durability === \"sync\") {\n          await Promise.all(loop?.checkpointerPromises ?? []);\n        }\n      } catch (e) {\n        loopError = e;\n      } finally {\n        try {\n          // Call `.stop()` again incase it was not called in the loop, e.g due to an error.\n          if (loop) {\n            await loop.store?.stop();\n            await loop.cache?.stop();\n          }\n          await Promise.all(loop?.checkpointerPromises ?? []);\n        } catch (e) {\n          loopError = loopError ?? e;\n        }\n        if (loopError) {\n          // \"Causes any future interactions with the associated stream to error\".\n          // Wraps ReadableStreamDefaultController#error:\n          // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/error\n          stream.error(loopError);\n        } else {\n          // Will end the iterator outside of this method,\n          // keeping previously enqueued chunks.\n          // Wraps ReadableStreamDefaultController#close:\n          // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/close\n          stream.close();\n        }\n      }\n    };\n    const runLoopPromise = createAndRunLoop();\n\n    try {\n      for await (const chunk of stream) {\n        if (chunk === undefined) {\n          throw new Error(\"Data structure error.\");\n        }\n        const [namespace, mode, payload] = chunk;\n        if (streamMode.includes(mode)) {\n          if (streamEncoding === \"text/event-stream\") {\n            if (streamSubgraphs) {\n              yield [namespace, mode, payload];\n            } else {\n              yield [null, mode, payload];\n            }\n            continue;\n          }\n          if (streamSubgraphs && !streamModeSingle) {\n            yield [namespace, mode, payload];\n          } else if (!streamModeSingle) {\n            yield [mode, payload];\n          } else if (streamSubgraphs) {\n            yield [namespace, payload];\n          } else {\n            yield payload;\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(loopError);\n      throw e;\n    } finally {\n      await runLoopPromise;\n    }\n    await runManager?.handleChainEnd(\n      loop?.output ?? {},\n      runId, // run_id\n      undefined, // run_type\n      undefined, // tags\n      undefined // metadata\n    );\n  }\n\n  /**\n   * Run the graph with a single input and config.\n   * @param input The input to the graph.\n   * @param options The configuration to use for the run.\n   */\n  override async invoke(\n    input: InputType | CommandType | null,\n    options?: Partial<\n      Omit<PregelOptions<Nodes, Channels, ContextType>, \"encoding\">\n    >\n  ): Promise<OutputType> {\n    const streamMode = options?.streamMode ?? \"values\";\n    const config = {\n      ...options,\n      outputKeys: options?.outputKeys ?? this.outputChannels,\n      streamMode,\n      encoding: undefined,\n    };\n    const chunks = [];\n    const stream = await this.stream(input, config);\n    const interruptChunks: Interrupt[][] = [];\n\n    let latest: OutputType | undefined;\n\n    for await (const chunk of stream) {\n      if (streamMode === \"values\") {\n        if (isInterrupted(chunk)) {\n          interruptChunks.push(chunk[INTERRUPT]);\n        } else {\n          latest = chunk as OutputType;\n        }\n      } else {\n        chunks.push(chunk);\n      }\n    }\n\n    if (streamMode === \"values\") {\n      if (interruptChunks.length > 0) {\n        const interrupts = interruptChunks.flat(1);\n        if (latest == null) return { [INTERRUPT]: interrupts } as OutputType;\n        if (typeof latest === \"object\") {\n          return { ...latest, [INTERRUPT]: interrupts };\n        }\n      }\n\n      return latest as OutputType;\n    }\n    return chunks as OutputType;\n  }\n\n  private async _runLoop(params: {\n    loop: PregelLoop;\n    runner: PregelRunner;\n    config: RunnableConfig;\n    debug: boolean;\n  }): Promise<void> {\n    const { loop, runner, debug, config } = params;\n    let tickError;\n    try {\n      while (\n        await loop.tick({ inputKeys: this.inputChannels as string | string[] })\n      ) {\n        for (const { task } of await loop._matchCachedWrites()) {\n          loop._outputWrites(task.id, task.writes, true);\n        }\n\n        if (debug) {\n          printStepCheckpoint(\n            loop.checkpointMetadata.step,\n            loop.channels,\n            this.streamChannelsList as string[]\n          );\n        }\n        if (debug) {\n          printStepTasks(loop.step, Object.values(loop.tasks));\n        }\n        await runner.tick({\n          timeout: this.stepTimeout,\n          retryPolicy: this.retryPolicy,\n          onStepWrite: (step, writes) => {\n            if (debug) {\n              printStepWrites(\n                step,\n                writes,\n                this.streamChannelsList as string[]\n              );\n            }\n          },\n          maxConcurrency: config.maxConcurrency,\n          signal: config.signal,\n        });\n      }\n      if (loop.status === \"out_of_steps\") {\n        throw new GraphRecursionError(\n          [\n            `Recursion limit of ${config.recursionLimit} reached`,\n            \"without hitting a stop condition. You can increase the\",\n            `limit by setting the \"recursionLimit\" config key.`,\n          ].join(\" \"),\n          {\n            lc_error_code: \"GRAPH_RECURSION_LIMIT\",\n          }\n        );\n      }\n    } catch (e) {\n      tickError = e as Error;\n      const suppress = await loop.finishAndHandleError(tickError);\n      if (!suppress) {\n        throw e;\n      }\n    } finally {\n      if (tickError === undefined) {\n        await loop.finishAndHandleError();\n      }\n    }\n  }\n\n  async clearCache(): Promise<void> {\n    await this.cache?.clear([]);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsIA,IAAa,UAAb,MAAqB;CAqDnB,OAAO,YACL,UACA,SAGY;EACZ,MAAM,EAAE,KAAK,SAAS;GACpB,KAAK;GACL,MAAM;GACN,GAAI,WAAW;;AAEjB,MAAI,MAAM,QAAQ,aAAa,QAAQ,OACrC,OAAM,IAAI,MACR;EAIJ,IAAIA;AAEJ,MAAI,OAAO,aAAa,SACtB,KAAI,IACF,yBAAwB,GAAG,MAAM;MAEjC,yBAAwB,CAAC;MAG3B,yBAAwB,OAAO,YAC7B,SAAS,KAAK,SAAS,CAAC,MAAM;EAIlC,MAAMC,WAAqB,MAAM,QAAQ,YAAY,WAAW,CAAC;AAEjE,SAAO,IAAIC,wBAAW;GACpB,UAAU;GACV;GACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BJ,OAAO,QACL,UACA,QACc;EACd,MAAMC,sBAAgD;AAEtD,OAAK,MAAM,WAAW,SACpB,qBAAoB,KAAK;GACvB;GACA,OAAOC;GACP,UAAU;;AAId,OAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,UAAU,IAClD,KAAIC,oCAAS,WAAW,UAAU,OAAO,UAAU,WACjD,qBAAoB,KAAK;GACvB,SAAS;GACT,OAAOD;GACP,UAAU;GACV,0DAA0B;;MAG5B,qBAAoB,KAAK;GACvB,SAAS;GACT;GACA,UAAU;;AAKhB,SAAO,IAAIE,2BAAa;;;AAU5B,IAAM,kBAAN,cAIUD,oCAA2C;CACnD,eAAe,CAAC,aAAa;CAE7B,AAAS,OACP,QACA,UAEc;AACd,QAAM,IAAI,MAAM;;CAIlB,AAAS,WAAW,SAAmC;AACrD,SAAO,MAAM,WAAW;;CAI1B,AAAS,OACP,OACA,SAEsC;AACtC,SAAO,MAAM,OAAO,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+D/B,IAAa,SAAb,cAcU,gBAMV;;;;;CAKE,OAAO,UAAU;AACf,SAAO;;;CAUT,eAAe,CAAC,aAAa;;CAG7B,eAAe;;CAGf;;CAGA;;;;;CAMA;;;;;CAMA;;CAGA,eAAwB;;;;;;;;;;CAWxB,aAA2B,CAAC;;;;;CAM5B;;;;;CAMA;;;;;CAMA;;CAGA;;CAGA,QAAiB;;;;;;CAOjB;;CAGA;;CAGA;;;;CAKA;;;;CAKA;;;;;CAMA,AAAQ;;;;;CAMR,AAAQ,iBAA2C;;;;;;CAOnD,YAAY,QAAuC;AACjD,QAAM;EAEN,IAAI,EAAE,eAAe;AACrB,MAAI,cAAc,QAAQ,CAAC,MAAM,QAAQ,YACvC,cAAa,CAAC;AAGhB,OAAK,QAAQ,OAAO;AACpB,OAAK,WAAW,OAAO;AAEvB,MACEE,2BAAS,KAAK,YACd,mBAAmB,KAAK,SAASA,4BACjC,KAAK,SAASA,yBAAO,kBAAkB,QAEvC,OAAM,IAAI,MACR,YAAYA,wBAAM;MAGpB,CAAC,KAAK,SAAyCA,2BAC7C,IAAIC,oBAAoB,EAAE,YAAY;AAG1C,OAAK,eAAe,OAAO,gBAAgB,KAAK;AAChD,OAAK,aAAa,cAAc,KAAK;AACrC,OAAK,gBAAgB,OAAO;AAC5B,OAAK,iBAAiB,OAAO;AAC7B,OAAK,iBAAiB,OAAO,kBAAkB,KAAK;AACpD,OAAK,iBAAiB,OAAO;AAC7B,OAAK,kBAAkB,OAAO;AAC9B,OAAK,cAAc,OAAO,eAAe,KAAK;AAC9C,OAAK,QAAQ,OAAO,SAAS,KAAK;AAClC,OAAK,eAAe,OAAO;AAC3B,OAAK,cAAc,OAAO;AAC1B,OAAK,SAAS,OAAO;AACrB,OAAK,QAAQ,OAAO;AACpB,OAAK,QAAQ,OAAO;AACpB,OAAK,OAAO,OAAO;AACnB,OAAK,iBAAiB,OAAO,kBAAkB,KAAK;AACpD,OAAK,gBAAgB,OAAO;AAE5B,MAAI,KAAK,aACP,MAAK;;;;;;;;;;;;;;;;;;;;;CAuBT,AAAS,WACP,QACa;EACb,MAAM,4DAA4B,KAAK,QAAQ;AAE/C,SAAO,IAAK,KAAK,YAAoB;GAAE,GAAG;GAAM,QAAQ;;;;;;;;;;;;;CAa1D,WAAiB;AACf,iCAA+B;GAC7B,OAAO,KAAK;GACZ,UAAU,KAAK;GACf,gBAAgB,KAAK;GACrB,eAAe,KAAK;GACpB,gBAAgB,KAAK;GACrB,qBAAqB,KAAK;GAC1B,sBAAsB,KAAK;;AAG7B,OAAK,MAAM,CAAC,MAAM,SAAS,OAAO,QAAQ,KAAK,OAC7C,MAAK,MAAM,WAAW,KAAK,UAAU;AACnC,QAAK,eAAe,aAAa;AACjC,QAAK,eAAe,SAAS,KAAK;;AAItC,SAAO;;;;;;;;;CAUT,IAAI,qBAA4C;AAC9C,MAAI,MAAM,QAAQ,KAAK,gBACrB,QAAO,KAAK;WACH,KAAK,eACd,QAAO,CAAC,KAAK;MAEb,QAAO,OAAO,KAAK,KAAK;;;;;;;;;CAW5B,IAAI,qBAA6D;AAC/D,MAAI,KAAK,eACP,QAAO,KAAK;MAEZ,QAAO,OAAO,KAAK,KAAK;;;;;;;;;CAW5B,MAAM,cAAc,QAAwB;AAC1C,SAAO,KAAK,SAAS;;;;;;;;;;;CAYvB,CAAC,aACC,WACA,SAEuC;AACvC,OAAK,MAAM,CAAC,MAAM,SAAS,OAAO,QAAQ,KAAK,QAAQ;AAErD,OAAI,cAAc,QAChB;QAAI,CAAC,UAAU,WAAW,MACxB;;GAOJ,MAAM,aAAa,KAAK,WAAW,SAAS,KAAK,YAAY,CAAC,KAAK;AAEnE,QAAK,MAAM,aAAa,YAAY;IAClC,MAAM,QAAQC,oCAAmB;AAEjC,QAAI,UAAU,QAAW;AACvB,SAAI,SAAS,WAAW;AACtB,YAAM,CAAC,MAAM;AACb;;AAGF,SAAI,cAAc,OAChB,OAAM,CAAC,MAAM;AAGf,SAAI,SAAS;MACX,IAAI,eAAe;AACnB,UAAI,cAAc,OAChB,gBAAe,UAAU,MAAM,KAAK,SAAS;AAE/C,WAAK,MAAM,CAAC,cAAc,aAAa,MAAM,aAC3C,cACA,SAEA,OAAM,CACJ,GAAG,OAAOC,mDAAiC,gBAC3C;;;;;;;;;;;;;;CAiBd,OAAO,kBACL,WACA,SAE4C;AAC5C,SAAO,KAAK,aAAa,WAAW;;;;;;;;;;;;;CActC,MAAgB,sBAAsB,EACpC,QACA,OACA,sBACA,qBAAqB,SAMI;AACzB,MAAI,UAAU,OACZ,QAAO;GACL,QAAQ;GACR,MAAM;GACN;GACA,OAAO;;EAKX,MAAM,WAAWC,2BACf,KAAK,UACL,MAAM;AAIR,MAAI,MAAM,eAAe,QAAQ;GAC/B,MAAM,aAAa,MAAM,cACtB,QAAQ,CAAC,QAAQ,OAAO,WAAWC,gCACnC,KACE,CAAC,GAAG,SAAS,WAAW,CAAC,OAAO,UAAU;AAG/C,OAAI,WAAW,SAAS,EACtB,2BACE,MAAM,YACN,UACA,CACE;IACE,MAAMC;IACN,QAAQ;IACR,UAAU;OAGd,QACA,KAAK;;EAMX,MAAM,YAAY,OAAO,OACvBC,+BACE,MAAM,YACN,MAAM,eACN,KAAK,OACL,UACA,MAAM,QACN,MACA;GAAE,OAAO,MAAM,UAAU,QAAQ,MAAM;GAAG,OAAO,KAAK;;EAK1D,MAAM,YAAY,MAAMC,6BAAe,KAAK;EAC5C,MAAM,kBAAkB,MAAM,OAAO,cAAc,iBAAiB;EACpE,MAAMC,aAA6D;AAGnE,OAAK,MAAM,QAAQ,WAAW;GAC5B,MAAM,mBAAmB,UAAU,MAAM,CAAC,UAAU,SAAS,KAAK;AAClE,OAAI,CAAC,iBACH;GAGF,IAAI,SAAS,GAAG,OAAO,KAAK,QAAQC,6CAA2B,KAAK;AACpE,OAAI,gBACF,UAAS,GAAG,kBAAkBP,mDAAiC;AAEjE,OAAI,yBAAyB,QAAW;IAEtC,MAAMQ,WAAyB,EAC7B,cAAc;KACZ,WAAW,MAAM,OAAO,cAAc;KACtC,eAAe;;AAGnB,eAAW,KAAK,MAAMC;UACjB;IAEL,MAAMC,iBAAiC,EACrC,cAAc;MACXC,4CAA0B;KAC3B,WAAW,MAAM,OAAO,cAAc;KACtC,eAAe;;IAGnB,MAAM,SAAS,iBAAiB;AAChC,eAAW,KAAK,MAAM,MAAM,OAAO,SAAS,gBAAgB,EAC1D,WAAW;;;AAMjB,MAAI,sBAAsB,MAAM,eAAe,QAAQ;GAErD,MAAM,eAAe,OAAO,YAC1B,UAAU,KAAK,SAAS,CAAC,KAAK,IAAI;AAIpC,QAAK,MAAM,CAAC,QAAQ,SAAS,UAAU,MAAM,eAAe;AAE1D,QAAI;KAACC;KAAOC;KAAWC;MAAW,SAAS,SACzC;AAEF,QAAI,EAAE,UAAU,cACd;AAGF,iBAAa,QAAQ,OAAO,KAAK,CAAC,OAAO,UAAU;;GAIrD,MAAMC,oBAAkB,UAAU,QAC/B,SAAS,KAAK,OAAO,SAAS;AAEjC,OAAIA,kBAAgB,SAAS,EAC3B,2BACE,MAAM,YACN,UACAA,mBACA,QACA,KAAK;;EAMX,IAAI,WAAW,OAAO;AACtB,MAAI,YAAY,OAAO,QAAQ,cAAc,UAC3C,YAAW;GACT,GAAG;GACH,WAAW,MAAM,OAAO,aAAa;;EAKzC,MAAM,WAAW,UACd,QAAQ,SAAS,KAAK,OAAO,WAAW,GACxC,KAAK,SAAS,KAAK;AAGtB,SAAO;GACL,QAAQC,wBACN,UACA,KAAK;GAEP,MAAM;GACN,OAAOD,8BACL,WACA,OAAO,iBAAiB,IACxB,YACA,KAAK;GAEP;GACA,QAAQE,iCAAmB,MAAM,QAAQ,MAAM;GAC/C,WAAW,MAAM,WAAW;GAC5B,cAAc,MAAM;;;;;;;;;;;;CAaxB,MAAM,SACJ,QACA,SACwB;EACxB,MAAM,eACJ,OAAO,eAAeN,8CAA4B,KAAK;AACzD,MAAI,CAAC,aACH,OAAM,IAAIO,+BAAgB,uBAAuB,EAC/C,eAAe;EAInB,MAAMC,sBACJ,OAAO,cAAc,iBAAiB;AACxC,MACE,wBAAwB,MACxB,OAAO,eAAeR,+CAA6B,QACnD;GAEA,MAAM,kBAAkBS,yCAA0B;AAClD,cAAW,MAAM,CAAC,MAAM,aAAa,KAAK,kBACxC,iBACA,MAEA,KAAI,SAAS,gBACX,QAAO,MAAM,SAAS,SACpBC,gCAAkB,QAAQ,GACvBV,4CAA0B,iBAE7B,EAAE,WAAW,SAAS;AAI5B,SAAM,IAAI,MACR,4BAA4B,gBAAgB;;EAIhD,MAAM,4DAA4B,KAAK,QAAQ;EAC/C,MAAM,QAAQ,MAAM,aAAa,SAAS;EAC1C,MAAM,WAAW,MAAM,KAAK,sBAAsB;GAChD,QAAQ;GACR;GACA,sBAAsB,SAAS,YAAY,eAAe;GAC1D,oBAAoB,CAAC,OAAO,cAAc;;AAE5C,SAAO;;;;;;;;;;;;;;;CAgBT,OAAO,gBACL,QACA,SACsC;EACtC,MAAMW,eACJ,OAAO,eAAeX,8CAA4B,KAAK;AACzD,MAAI,CAAC,aACH,OAAM,IAAIO,+BAAgB,uBAAuB,EAC/C,eAAe;EAInB,MAAMC,sBACJ,OAAO,cAAc,iBAAiB;AACxC,MACE,wBAAwB,MACxB,OAAO,eAAeR,+CAA6B,QACnD;GACA,MAAM,kBAAkBS,yCAA0B;AAGlD,cAAW,MAAM,CAAC,MAAM,WAAW,KAAK,kBACtC,iBACA,MAEA,KAAI,SAAS,iBAAiB;AAC5B,WAAO,OAAO,gBACZC,gCAAkB,QAAQ,GACvBV,4CAA0B,iBAE7B;AAEF;;AAGJ,SAAM,IAAI,MACR,4BAA4B,gBAAgB;;EAIhD,MAAM,4DAA4B,KAAK,QAAQ,QAAQ,EACrD,cAAc,EAAE,eAAe;AAGjC,aAAW,MAAM,mBAAmB,aAAa,KAC/C,cACA,SAEA,OAAM,KAAK,sBAAsB;GAC/B,QAAQ,gBAAgB;GACxB,OAAO;;;;;;;;;;;;;;;;;;;CAqBb,MAAM,gBACJ,aACA,YAMyB;EACzB,MAAMY,eACJ,YAAY,eAAeZ,8CAA4B,KAAK;AAC9D,MAAI,CAAC,aACH,OAAM,IAAIO,+BAAgB,uBAAuB,EAC/C,eAAe;AAGnB,MAAI,WAAW,WAAW,EACxB,OAAM,IAAI,MAAM;AAGlB,MAAI,WAAW,MAAM,MAAM,EAAE,QAAQ,WAAW,GAC9C,OAAM,IAAI,MAAM;EAIlB,MAAMC,sBACJ,YAAY,cAAc,iBAAiB;AAC7C,MACE,wBAAwB,MACxB,YAAY,eAAeR,+CAA6B,QACxD;GAEA,MAAM,kBAAkBS,yCAA0B;AAGlD,cAAW,MAAM,GAAG,WAAW,KAAK,kBAClC,iBACA,MAEA,QAAO,MAAM,OAAO,gBAClBC,gCAAkB,aAAa,GAC5BV,4CAA0B,iBAE7B;AAGJ,SAAM,IAAI,MAAM,aAAa,gBAAgB;;EAG/C,MAAM,kBAAkB,OACtB,aACA,YAKG;GAEH,MAAM,SAAS,KAAK,sDACH,KAAK,QAAQ,eAC1B;GACJ,MAAM,QAAQ,MAAM,aAAa,SAAS;GAC1C,MAAM,aACJ,UAAU,8DACS,MAAM;GAE3B,MAAM,6BAA6B,EACjC,GAAG,OAAO,WAAW;GAEvB,MAAM,OAAO,OAAO,UAAU,QAAQ;GAGtC,IAAI,mBAAmBU,gCAAkB,QAAQ,EAC/C,eAAe,OAAO,cAAc,iBAAiB;GAEvD,IAAI,qBAAqB,OAAO,YAAY;AAC5C,OAAI,OAAO,OAAO,cAAc;AAC9B,uBAAmBA,gCAAkB,QAAQ,MAAM,OAAO;AAC1D,yBAAqB;KACnB,GAAG,MAAM;KACT,GAAG;;;GAKP,MAAM,EAAE,QAAQ,WAAW,QAAQ;AACnC,OAAI,UAAU,QAAQ,WAAW,QAAW;AAC1C,QAAI,QAAQ,SAAS,EACnB,OAAM,IAAIG,kCACR;IAIJ,MAAMC,eAAa,MAAM,aAAa,IACpC,kBACAC,8BAAiB,YAAY,QAAW,OACxC;KACE,QAAQ;KACR,MAAM,OAAO;KACb,SAAS,OAAO,UAAU,WAAW;OAEvC;AAEF,WAAOT,iCACLQ,cACA,QAAQ,MAAM,WAAW;;GAK7B,MAAM,WAAWxB,2BACf,KAAK,UACL;AAGF,OAAI,WAAW,QAAQ,WAAW0B,uBAAK;AACrC,QAAI,QAAQ,SAAS,EACnB,OAAM,IAAIH,kCACR;AAIJ,QAAI,OAAO;KAET,MAAM,YAAYpB,+BAChB,YACA,MAAM,iBAAiB,IACvB,KAAK,OACL,UACA,MAAM,QACN,MACA;MACE,OAAO,MAAM,UAAU,QAAQ,MAAM;MACrC;MACA,OAAO,KAAK;;KAKhB,MAAM,cAAc,MAAM,iBAAiB,IACxC,QAAQ,MAAM,EAAE,OAAOF,gCACvB,KAAK,MAAM,EAAE,MAAM;AACtB,SAAI,WAAW,SAAS,EACtB,2BACE,YACA,UACA,CACE;MACE,MAAMC;MACN,QAAQ;MACR,UAAU;SAGd,aAAa,eAAe,KAAK,eACjC,KAAK;AAIT,UAAK,MAAM,CAAC,QAAQ,GAAG,MAAM,MAAM,iBAAiB,IAAI;AACtD,UAAI;OAACS;OAAOC;OAAWC;QAAW,SAAS,GACzC;AAEF,UAAI,EAAE,UAAU,WACd;AAEF,gBAAU,QAAQ,OAAO,KAAK,CAAC,GAAG;;AAGpC,+BACE,YACA,UACA,OAAO,OAAO,YACd,aAAa,eAAe,KAAK,eACjC,KAAK;;IAIT,MAAMW,eAAa,MAAM,aAAa,IACpC,kBACAC,8BAAiB,YAAY,UAAU,OACvC;KACE,GAAG;KACH,QAAQ;KACR,MAAM,OAAO;KACb,SAAS,OAAO,UAAU,WAAW;OAEvCE,oCACE,4BACA,WAAW;AAGf,WAAOX,iCACLQ,cACA,QAAQ,MAAM,WAAW;;AAI7B,OAAI,WAAWI,wBAAM;AACnB,QAAI,QAAQ,SAAS,EACnB,OAAM,IAAIL,kCACR;AAIJ,QAAI,SAAS,KACX,OAAM,IAAIA,kCAAmB;IAG/B,MAAM,qBACJ,aACkD;AAClD,SAAI,CAAC,MAAM,QAAQM,UAAS,QAAO;AACnC,SAAIA,SAAO,WAAW,EAAG,QAAO;AAChC,YAAOA,SAAO,OAAO,MAAM,MAAM,QAAQ,MAAM,EAAE,WAAW;;IAG9D,MAAM,iBAAiBJ,8BAAiB,YAAY,QAAW;IAC/D,MAAMD,eAAa,MAAM,aAAa,IACpC,MAAM,gBACJJ,gCAAkB,MAAM,QAAQ,EAAE,eAAe,WACnD,gBACA;KACE,QAAQ;KACR,MAAM,OAAO;KACb,SAAS,MAAM,UAAU,WAAW;OAEtC;AAKF,QAAI,kBAAkB,SAAS;KAE7B,MAAM,YAAYjB,+BAChB,gBACA,MAAM,eACN,KAAK,OACL,UACAqB,cACA,OACA,EAAE,MAAM,OAAO;KAGjB,MAAM,eAAe,OAAO,OAAO,WAAW,QAE3C,KAAK,EAAE,MAAM,SAAS;AACvB,UAAI,UAAU;AACd,UAAI,MAAM,KAAK,EAAE;AACjB,aAAO;QACN;KAEH,MAAM,cAAc,OAAO,QAKxB,KAAK,SAAS;MACf,MAAM,CAACK,UAAQC,YAAU;AACzB,UAAIA,cAAY;MAEhB,MAAM,YAAY,IAAIA,UAAQ;MAC9B,MAAM,SAAS,aAAaA,YAAU,YAAY;AAClD,UAAIA,UAAQ,KAAK;OAAE;OAAQ;OAAQ;;AAEnC,aAAO;QACN;AAEH,YAAO,gBACLd,iCAAmBQ,cAAY,MAAM,WACrC,OAAO,OAAO,aAAa;;AAI/B,WAAOR,iCAAmBQ,cAAY,MAAM;;AAG9C,OAAI,WAAWtB,yBAAO;AACpB,QAAI,QAAQ,SAAS,EACnB,OAAM,IAAIqB,kCACR;IAIJ,MAAM,cAAc,MAAMnB,6BACxB2B,oBAAS,KAAK,eAAe;AAE/B,QAAI,YAAY,WAAW,EACzB,OAAM,IAAIR,kCACR,gCAAgC,KAAK,UACnC,KAAK,eACL,MACA;AAMN,8BACE,YACA,UACA,CACE;KACE,MAAMrB;KACN,QAAQ;KACR,UAAU;QAGd,aAAa,eAAe,KAAK,KAAK,eACtC,KAAK;IAIP,MAAM,WACJ,OAAO,UAAU,QAAQ,OAAO,MAAM,SAAS,OAAO,IAAI;IAC5D,MAAMsB,eAAa,MAAM,aAAa,IACpC,kBACAC,8BAAiB,YAAY,UAAU,WACvC;KACE,QAAQ;KACR,MAAM;KACN,SAAS,OAAO,UAAU,WAAW;OAEvCE,oCACE,4BACA,WAAW;AAKf,UAAM,aAAa,UACjBH,cACA,yDACMtB,yBAAO,WAAW;AAG1B,WAAOc,iCACLQ,cACA,QAAQ,MAAM,WAAW;;AAK7B,OACE,OAAO,cAAc,kBAAkB,UACvC,OAAO,kBAAkB,UACzB,MAAM,cAAc,SAAS,GAC7B;IAEA,MAAM,YAAYrB,+BAChB,YACA,MAAM,eACN,KAAK,OACL,UACA,MAAM,QACN,MACA;KACE,OAAO,KAAK;KAEZ,cAAc,KAAK;KACnB,OAAO,MAAM,UAAU,QAAQ,MAAM;;IAIzC,MAAM,cAAc,MAAM,iBAAiB,IACxC,QAAQ,MAAM,EAAE,OAAOF,gCACvB,KAAK,MAAM,EAAE,MAAM;AACtB,QAAI,WAAW,SAAS,EACtB,2BACE,MAAM,YACN,UACA,CAAC;KAAE,MAAMC;KAAO,QAAQ;KAAY,UAAU;QAC9C,QACA,KAAK;AAIT,SAAK,MAAM,CAAC,KAAK,GAAG,MAAM,MAAM,eAAe;AAC7C,SACE;MAACS;MAAOC;MAAWC;OAAW,SAAS,MACvC,UAAU,SAAS,OAEnB;AAEF,eAAU,KAAK,OAAO,KAAK,CAAC,GAAG;;IAEjC,MAAMmB,UAAQ,OAAO,OAAO,WAAW,QAAQ,SAAS;AACtD,YAAO,KAAK,OAAO,SAAS;;AAE9B,QAAIA,QAAM,SAAS,EACjB,2BACE,YACA,UACAA,SACA,QACA,KAAK;;GAIX,MAAM,iBAAiB,OAAO,OAAO,WAAW,eAC7C,KAAK,iBAAiB;AACrB,WAAO,OAAO,OAAO;MAEtB,OACA,MAAM,MAAM,CAAC,CAAC;GAEjB,MAAMC,eAID;AAEL,OAAI,QAAQ,WAAW,GAAG;IAExB,IAAI,EAAE,kBAAQ,kBAAQ,WAAW,QAAQ;AACzC,QAAIH,aAAW,UAAa,OAAO,KAAK,KAAK,OAAO,WAAW,EAE7D,EAACA,YAAU,OAAO,KAAK,KAAK;aACnBA,aAAW,UAAa,mBAAmB,QACpD;SACE,OAAO,KAAK,kBAAkB,YAC9B,KAAK,MAAM,KAAK,mBAAmB,OAEnC,YAAS,KAAK;eAEPA,aAAW,QAAW;KAC/B,MAAM,iBAAiB,OAAO,QAAQ,WAAW,eAC9C,KAAK,CAAC,GAAG,UAAU;AAClB,aAAO,OAAO,OAAO,MAAM,KAAK,MAAM;AACpC,cAAO,CAAC,GAAG;;QAGd,OACA,QAAQ,CAAC,GAAG,OAAO,MAAMlB,6BACzB,MAAM,CAAC,UAAU,CAAC,0EACM,SAAS;AAGpC,SAAI,gBACF;UAAI,eAAe,WAAW,EAE5B,YAAS,eAAe,GAAG;eAE3B,eAAe,eAAe,SAAS,GAAG,OAC1C,eAAe,eAAe,SAAS,GAAG,GAG1C,YAAS,eAAe,eAAe,SAAS,GAAG;;;AAKzD,QAAIkB,aAAW,OACb,OAAM,IAAIP,kCAAmB;AAG/B,iBAAa,KAAK;KAAE;KAAQ;KAAQ;;SAEpC,MAAK,MAAM,EAAE,kBAAQ,kBAAQ,YAAY,SAAS;AAChD,QAAIO,YAAU,KACZ,OAAM,IAAIP,kCACR;AAIJ,iBAAa,KAAK;KAAE;KAAQ;KAAQ;;;GAIxC,MAAMW,QAA6D;AACnE,QAAK,MAAM,EAAE,kBAAQ,kBAAQ,YAAY,cAAc;AACrD,QAAI,KAAK,MAAMJ,cAAY,OACzB,OAAM,IAAIP,kCACR,SAASO,SAAO,WAAW;IAK/B,MAAM,UAAU,KAAK,MAAMA,UAAQ;AACnC,QAAI,CAAC,QAAQ,OACX,OAAM,IAAIP,kCACR,8BAA8BO,SAAO,WAAW;AAGpD,UAAM,KAAK;KACT,MAAMA;KACN,OAAOD;KACP,MACE,QAAQ,SAAS,IAEbM,4CAAiB,KAAK,SAAgB,EACpC,kBAAkB,UAEpB,QAAQ;KACd,QAAQ;KACR,UAAU,CAACvB;KACX,IAAI,sDAAgBA,6BAAW,WAAW;KAC1C,SAAS;;;AAIb,QAAK,MAAM,QAAQ,MAEjB,OAAM,KAAK,KAAK,OACd,KAAK,mDAEH;IACE,GAAG;IACH,OAAO,QAAQ,SAAS,KAAK;MAE/B;IACE,SAAS,OAAO,WAAW,GAAG,KAAK,UAAU;IAC7C,cAAc;MACXwB,qCAAmB,UAClB,KAAK,OAAO,KAAK,GAAG;MACrBC,qCACC,SACA,SAAkB,UAElBC,wBACE,YACA,UAEA,MACA,SACA;;;AAQd,QAAK,MAAM,QAAQ,OAAO;IAExB,MAAM,gBAAgB,KAAK,OAAO,QAAQ,MAAM,EAAE,OAAOC;AAEzD,QAAI,UAAU,UAAa,cAAc,SAAS,EAChD,OAAM,aAAa,UACjB,kBACA,eACA,KAAK;;AAOX,6BACE,YACA,UACA,OACA,aAAa,eAAe,KAAK,KAAK,eACtC,KAAK;GAGP,MAAM,cAAcZ,oCAClB,4BACA,WAAW;GAEb,MAAM,aAAa,MAAM,aAAa,IACpC,kBACAF,8BAAiB,YAAY,UAAU,OAAO,IAC9C;IACE,QAAQ;IACR,MAAM,OAAO;IACb,SAAS,OAAO,UAAU,WAAW;MAEvC;AAGF,QAAK,MAAM,QAAQ,OAAO;IAExB,MAAM,aAAa,KAAK,OAAO,QAAQ,MAAM,EAAE,OAAOc;AAEtD,QAAI,WAAW,SAAS,EACtB,OAAM,aAAa,UACjB,YACA,YACA,KAAK;;AAKX,UAAOvB,iCAAmB,YAAY,QAAQ,MAAM,WAAW;;EAGjE,IAAI,gBAAgB;AACpB,OAAK,MAAM,EAAE,aAAa,WACxB,iBAAgB,MAAM,gBAAgB,eAAe;AAGvD,SAAO;;;;;;;;;;;;;;;;;;CAmBT,MAAM,YACJ,aACA,QACA,QACyB;AACzB,SAAO,KAAK,gBAAgB,aAAa,CACvC,EAAE,SAAS,CAAC;GAAE;GAAQ;;;;;;;;;;;;;;;;;;;;;;;CAwB1B,UAAU,QAaR;EACA,MAAM,EACJ,OACA,YACA,WACA,YACA,gBACA,gBACA,GAAG,SACD;EACJ,IAAI,mBAAmB;EACvB,MAAM,eAAe,UAAU,SAAY,QAAQ,KAAK;EAExD,IAAI,oBAAoB;AACxB,MAAI,sBAAsB,OACxB,qBAAoB,KAAK;MAEzB,+BAAa,mBAAmB,KAAK;EAGvC,IAAI,mBAAmB;AACvB,MAAI,qBAAqB,OACvB,oBAAmB,KAAK;MAExB,+BAAa,kBAAkB,KAAK;EAGtC,MAAM,yBACJ,mBAAmB,KAAK,mBAAmB;EAE7C,MAAM,wBAAwB,kBAAkB,KAAK,kBAAkB;EAEvE,IAAIwB;AACJ,MAAI,eAAe,QAAW;AAC5B,uBAAoB,MAAM,QAAQ,cAAc,aAAa,CAAC;AAC9D,sBAAmB,OAAO,eAAe;SACpC;AAGL,OAAI,OAAO,eAAeC,0CAAwB,OAChD,qBAAoB,CAAC;OAErB,qBAAoB,KAAK;AAG3B,sBAAmB;;EAGrB,IAAIC;AACJ,MAAI,KAAK,iBAAiB,MACxB,uBAAsB;WAEtB,WAAW,UACX,OAAO,eAAehC,+CAA6B,OAEnD,uBAAsB,OAAO,aAAaA;WACjC,KAAK,iBAAiB,KAC/B,OAAM,IAAI,MAAM;MAEhB,uBAAsB,KAAK;EAE7B,MAAMiC,eAAsC,OAAO,SAAS,KAAK;EACjE,MAAMC,eAAsC,OAAO,SAAS,KAAK;AAEjE,MAAI,OAAO,cAAc,QAAQ,OAAO,oBAAoB,KAC1D,OAAM,IAAI,MACR;EAIJ,MAAMC,oCAA4D;AAChE,OAAI,OAAO,oBAAoB,KAAM,QAAO;AAC5C,OAAI,OAAO,qBAAqB,MAAO,QAAO;AAC9C,UAAO;;EAGT,MAAMC,oBACJ,OAAO,cACP,8BACA,QAAQ,eAAeC,4CACvB;AAEF,SAAO;GACL;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;;;;;;;;;;;;;;;;;;;;CAqBJ,MAAe,OAKb,OACA,SAuBA;EAMA,MAAM,kBAAkB,IAAI;EAE5B,MAAM,SAAS;GACb,gBAAgB,KAAK,QAAQ;GAC7B,GAAG;GACH,QAAQC,kCAAoB,SAAS,QAAQ,gBAAgB,QAC1D;;EAGL,MAAM,SAAS,MAAM,MAAM,OAAO,OAAO;AACzC,SAAO,IAAIC,qDACT,SAAS,aAAa,sBAClBC,6BAAc,UACd,QACJ;;CAwBJ,AAAS,aACP,OACA,SAGA,eACkD;EAClD,MAAM,kBAAkB,IAAI;EAE5B,MAAM,SAAS;GACb,gBAAgB,KAAK,QAAQ;GAC7B,GAAG;GAKH,WAAWC,+BAAiB,KAAK,QAAQ,WAAW,SAAS;GAC7D,QAAQH,kCAAoB,SAAS,QAAQ,gBAAgB,QAC1D;;AAGL,SAAO,IAAIC,qDACT,MAAM,aAAa,OAAO,QAAQ,gBAClC;;;;;;;;CAUJ,MAAgB,eAAe,OAAwB;AACrD,SAAO;;;;;;;;CAST,MAAgB,iBACd,SAC6C;AAC7C,SAAO;;;;;;;;;;;CAYT,OAAgB,gBACd,OACA,SACkC;EAElC,MAAM,iBACJ,cAAc,WAAW,MAAM,SAAY,SAAS,YAAY;EAClE,MAAM,kBAAkB,SAAS;EACjC,MAAM,cAAcG,qCAAsB,KAAK,QAAQ;AACvD,MACE,YAAY,mBAAmB,UAC/B,YAAY,iBAAiB,EAE7B,OAAM,IAAI,MAAM;AAElB,MACE,KAAK,iBAAiB,UACtB,KAAK,iBAAiB,SACtB,YAAY,iBAAiB,OAE7B,OAAM,IAAI,MACR;EAIJ,MAAM,aAAa,MAAM,KAAK,eAAe;EAC7C,MAAM,EAAE,MAAO,GAAG,eAAe;EAEjC,MAAM,CACJ,OACA,cAEA,YACA,QACA,iBACA,gBACA,cACA,OACA,kBACA,OACA,cACE,KAAK,UAAU;AAGnB,MAAI,OAAO,OAAO,YAAY,YAC5B,QAAO,UAAU,MAAM,KAAK,iBAAiB,OAAO;MAEpD,QAAO,eAAe,MAAM,KAAK,iBAAiB,OAAO;EAG3D,MAAM,SAAS,IAAIC,8CAA+B,EAChD,OAAO,IAAI,IAAI;AAIjB,MAAI,KAAK,iBAAiB,MAAM;AAC9B,UAAO,iBAAiB;GACxB,MAAMC,KAAa,OAAO,aAAaC,+CAA6B;AACpE,UAAO,aAAaA,8CAA4B,GAC7C,MAAMxD,kDACN,KAAK,SAAS,KAAK,MAAMO,4CAA0B,IACnD,KAAKP;;AAIV,MAAI,WAAW,SAAS,aAAa;GACnC,MAAM,kBAAkB,IAAIyD,wCAAuB,UACjD,OAAO,KAAK;GAEd,MAAM,EAAE,cAAc;AACtB,OAAI,cAAc,OAChB,QAAO,YAAY,CAAC;YACX,MAAM,QAAQ,WACvB,QAAO,YAAY,UAAU,OAAO;QAC/B;IACL,MAAM,kBAAkB,UAAU;AAClC,oBAAgB,WAAW,iBAAiB;AAC5C,WAAO,YAAY;;;AAIvB,SAAO,YAAY,UAAmB;AACpC,OAAI,CAAC,WAAW,SAAS,UAAW;GACpC,MAAM,MACJC,4BAAa,eAAeF,8CAI1B,MAAMxD,kDACP,MAAM,GAAG;AAEZ,UAAO,KAAK;IAAC,MAAM;IAAI;IAAU;;;AAGnC,SAAO,cAAe,KAAK,iBAAsC2D;EAEjE,MAAM,kBAAkB,kEAAkC;EAC1D,MAAM,aAAa,MAAM,iBAAiB,iBACxC,KAAK,UACLC,4BAAc,OAAO,UACrB,OACA,QACA,QACA,QACA,QAAQ,WAAW,KAAK;EAG1B,MAAM,eAAeC,6BAAgB,KAAK;EAC1C,IAAIC;EACJ,IAAIC;;;;;;;;;EAUJ,MAAM,mBAAmB,YAAY;AACnC,OAAI;AACF,WAAO,MAAMC,wBAAW,WAAW;KACjC,OAAO;KACP;KACA;KACA,OAAO,KAAK;KACZ;KACA;KACA,YAAY,KAAK;KACjB;KACO;KACP;KACA;KACA;KACA,SAAS;KACT,OAAO,KAAK;KACZ,gBAAgB,KAAK;KACrB;;IAGF,MAAM,SAAS,IAAIC,4BAAa;KAC9B;KACA,cAAc,OAAO,eAAeC;;AAGtC,QAAI,SAAS,UACX,MAAK,OAAO,eAAe;KACzB,GAAG,KAAK,OAAO;MACdC,sCAAoB,KAAK;;AAG9B,UAAM,KAAK,SAAS;KAAE;KAAM;KAAQ;KAAO;;AAG3C,QAAI,eAAe,OACjB,OAAM,QAAQ,IAAI,MAAM,wBAAwB;YAE3C,GAAG;AACV,gBAAY;aACJ;AACR,QAAI;AAEF,SAAI,MAAM;AACR,YAAM,KAAK,OAAO;AAClB,YAAM,KAAK,OAAO;;AAEpB,WAAM,QAAQ,IAAI,MAAM,wBAAwB;aACzC,GAAG;AACV,iBAAY,aAAa;;AAE3B,QAAI,UAIF,QAAO,MAAM;QAMb,QAAO;;;EAIb,MAAM,iBAAiB;AAEvB,MAAI;AACF,cAAW,MAAM,SAAS,QAAQ;AAChC,QAAI,UAAU,OACZ,OAAM,IAAI,MAAM;IAElB,MAAM,CAAC,WAAW,MAAM,WAAW;AACnC,QAAI,WAAW,SAAS,OAAO;AAC7B,SAAI,mBAAmB,qBAAqB;AAC1C,UAAI,gBACF,OAAM;OAAC;OAAW;OAAM;;UAExB,OAAM;OAAC;OAAM;OAAM;;AAErB;;AAEF,SAAI,mBAAmB,CAAC,iBACtB,OAAM;MAAC;MAAW;MAAM;;cACf,CAAC,iBACV,OAAM,CAAC,MAAM;cACJ,gBACT,OAAM,CAAC,WAAW;SAElB,OAAM;;;WAIL,GAAG;AACV,SAAM,YAAY,iBAAiB;AACnC,SAAM;YACE;AACR,SAAM;;AAER,QAAM,YAAY,eAChB,MAAM,UAAU,IAChB,OACA,QACA,QACA;;;;;;;CASJ,MAAe,OACb,OACA,SAGqB;EACrB,MAAM,aAAa,SAAS,cAAc;EAC1C,MAAM,SAAS;GACb,GAAG;GACH,YAAY,SAAS,cAAc,KAAK;GACxC;GACA,UAAU;;EAEZ,MAAM,SAAS;EACf,MAAM,SAAS,MAAM,KAAK,OAAO,OAAO;EACxC,MAAMC,kBAAiC;EAEvC,IAAIC;AAEJ,aAAW,MAAM,SAAS,OACxB,KAAI,eAAe,SACjB,KAAIC,gCAAc,OAChB,iBAAgB,KAAK,MAAMzD;MAE3B,UAAS;MAGX,QAAO,KAAK;AAIhB,MAAI,eAAe,UAAU;AAC3B,OAAI,gBAAgB,SAAS,GAAG;IAC9B,MAAM,aAAa,gBAAgB,KAAK;AACxC,QAAI,UAAU,KAAM,QAAO,GAAGA,8BAAY;AAC1C,QAAI,OAAO,WAAW,SACpB,QAAO;KAAE,GAAG;MAASA,8BAAY;;;AAIrC,UAAO;;AAET,SAAO;;CAGT,MAAc,SAAS,QAKL;EAChB,MAAM,EAAE,MAAM,QAAQ,OAAO,WAAW;EACxC,IAAI;AACJ,MAAI;AACF,UACE,MAAM,KAAK,KAAK,EAAE,WAAW,KAAK,kBAClC;AACA,SAAK,MAAM,EAAE,UAAU,MAAM,KAAK,qBAChC,MAAK,cAAc,KAAK,IAAI,KAAK,QAAQ;AAG3C,QAAI,MACF,mCACE,KAAK,mBAAmB,MACxB,KAAK,UACL,KAAK;AAGT,QAAI,MACF,8BAAe,KAAK,MAAM,OAAO,OAAO,KAAK;AAE/C,UAAM,OAAO,KAAK;KAChB,SAAS,KAAK;KACd,aAAa,KAAK;KAClB,cAAc,MAAM,WAAW;AAC7B,UAAI,MACF,+BACE,MACA,QACA,KAAK;;KAIX,gBAAgB,OAAO;KACvB,QAAQ,OAAO;;;AAGnB,OAAI,KAAK,WAAW,eAClB,OAAM,IAAI0D,mCACR;IACE,sBAAsB,OAAO,eAAe;IAC5C;IACA;KACA,KAAK,MACP,EACE,eAAe;WAId,GAAG;AACV,eAAY;GACZ,MAAM,WAAW,MAAM,KAAK,qBAAqB;AACjD,OAAI,CAAC,SACH,OAAM;YAEA;AACR,OAAI,cAAc,OAChB,OAAM,KAAK;;;CAKjB,MAAM,aAA4B;AAChC,QAAM,KAAK,OAAO,MAAM"}