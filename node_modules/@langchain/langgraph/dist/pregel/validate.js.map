{"version":3,"file":"validate.js","names":[],"sources":["../../src/pregel/validate.ts"],"sourcesContent":["import { All } from \"@langchain/langgraph-checkpoint\";\nimport { BaseChannel } from \"../channels/index.js\";\nimport { INTERRUPT } from \"../constants.js\";\nimport { PregelNode } from \"./read.js\";\n\nexport class GraphValidationError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"GraphValidationError\";\n  }\n}\n\nexport function validateGraph<\n  Nn extends Record<string, PregelNode>,\n  Cc extends Record<string, BaseChannel>\n>({\n  nodes,\n  channels,\n  inputChannels,\n  outputChannels,\n  streamChannels,\n  interruptAfterNodes,\n  interruptBeforeNodes,\n}: {\n  nodes: Nn;\n  channels: Cc;\n  inputChannels: keyof Cc | Array<keyof Cc>;\n  outputChannels: keyof Cc | Array<keyof Cc>;\n  streamChannels?: keyof Cc | Array<keyof Cc>;\n  interruptAfterNodes?: Array<keyof Nn> | All;\n  interruptBeforeNodes?: Array<keyof Nn> | All;\n}): void {\n  if (!channels) {\n    throw new GraphValidationError(\"Channels not provided\");\n  }\n\n  const subscribedChannels = new Set<keyof Cc>();\n  const allOutputChannels = new Set<keyof Cc>();\n\n  for (const [name, node] of Object.entries(nodes)) {\n    if (name === INTERRUPT) {\n      throw new GraphValidationError(`\"Node name ${INTERRUPT} is reserved\"`);\n    }\n    if (node.constructor === PregelNode) {\n      node.triggers.forEach((trigger) => subscribedChannels.add(trigger));\n    } else {\n      throw new GraphValidationError(\n        `Invalid node type ${typeof node}, expected PregelNode`\n      );\n    }\n  }\n\n  // side effect: update channels\n  for (const chan of subscribedChannels) {\n    if (!(chan in channels)) {\n      throw new GraphValidationError(\n        `Subscribed channel '${String(chan)}' not in channels`\n      );\n    }\n  }\n\n  if (!Array.isArray(inputChannels)) {\n    if (!subscribedChannels.has(inputChannels)) {\n      throw new GraphValidationError(\n        `Input channel ${String(\n          inputChannels\n        )} is not subscribed to by any node`\n      );\n    }\n  } else {\n    if (inputChannels.every((channel) => !subscribedChannels.has(channel))) {\n      throw new GraphValidationError(\n        `None of the input channels ${inputChannels} are subscribed to by any node`\n      );\n    }\n  }\n\n  if (!Array.isArray(outputChannels)) {\n    allOutputChannels.add(outputChannels);\n  } else {\n    outputChannels.forEach((chan) => allOutputChannels.add(chan));\n  }\n\n  if (streamChannels && !Array.isArray(streamChannels)) {\n    allOutputChannels.add(streamChannels);\n  } else if (Array.isArray(streamChannels)) {\n    streamChannels.forEach((chan) => allOutputChannels.add(chan));\n  }\n\n  for (const chan of allOutputChannels) {\n    if (!(chan in channels)) {\n      throw new GraphValidationError(\n        `Output channel '${String(chan)}' not in channels`\n      );\n    }\n  }\n\n  // validate interrupt before/after\n  if (interruptAfterNodes && interruptAfterNodes !== \"*\") {\n    for (const node of interruptAfterNodes) {\n      if (!(node in nodes)) {\n        throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n      }\n    }\n  }\n\n  if (interruptBeforeNodes && interruptBeforeNodes !== \"*\") {\n    for (const node of interruptBeforeNodes) {\n      if (!(node in nodes)) {\n        throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n      }\n    }\n  }\n}\n\nexport function validateKeys<Cc extends Record<string, BaseChannel>>(\n  keys: keyof Cc | Array<keyof Cc>,\n  channels: Cc\n): void {\n  if (Array.isArray(keys)) {\n    for (const key of keys) {\n      if (!(key in channels)) {\n        throw new Error(`Key ${String(key)} not found in channels`);\n      }\n    }\n  } else {\n    if (!(keys in channels)) {\n      throw new Error(`Key ${String(keys)} not found in channels`);\n    }\n  }\n}\n"],"mappings":";;;;AAKA,IAAa,uBAAb,cAA0C,MAAM;CAC9C,YAAY,SAAkB;AAC5B,QAAM;AACN,OAAK,OAAO;;;AAIhB,SAAgB,cAGd,EACA,OACA,UACA,eACA,gBACA,gBACA,qBACA,wBASO;AACP,KAAI,CAAC,SACH,OAAM,IAAI,qBAAqB;CAGjC,MAAM,qCAAqB,IAAI;CAC/B,MAAM,oCAAoB,IAAI;AAE9B,MAAK,MAAM,CAAC,MAAM,SAAS,OAAO,QAAQ,QAAQ;AAChD,MAAI,SAAS,UACX,OAAM,IAAI,qBAAqB,cAAc,UAAU;AAEzD,MAAI,KAAK,gBAAgB,WACvB,MAAK,SAAS,SAAS,YAAY,mBAAmB,IAAI;MAE1D,OAAM,IAAI,qBACR,qBAAqB,OAAO,KAAK;;AAMvC,MAAK,MAAM,QAAQ,mBACjB,KAAI,EAAE,QAAQ,UACZ,OAAM,IAAI,qBACR,uBAAuB,OAAO,MAAM;AAK1C,KAAI,CAAC,MAAM,QAAQ,gBACjB;MAAI,CAAC,mBAAmB,IAAI,eAC1B,OAAM,IAAI,qBACR,iBAAiB,OACf,eACA;YAIF,cAAc,OAAO,YAAY,CAAC,mBAAmB,IAAI,UAC3D,OAAM,IAAI,qBACR,8BAA8B,cAAc;AAKlD,KAAI,CAAC,MAAM,QAAQ,gBACjB,mBAAkB,IAAI;KAEtB,gBAAe,SAAS,SAAS,kBAAkB,IAAI;AAGzD,KAAI,kBAAkB,CAAC,MAAM,QAAQ,gBACnC,mBAAkB,IAAI;UACb,MAAM,QAAQ,gBACvB,gBAAe,SAAS,SAAS,kBAAkB,IAAI;AAGzD,MAAK,MAAM,QAAQ,kBACjB,KAAI,EAAE,QAAQ,UACZ,OAAM,IAAI,qBACR,mBAAmB,OAAO,MAAM;AAMtC,KAAI,uBAAuB,wBAAwB,KACjD;OAAK,MAAM,QAAQ,oBACjB,KAAI,EAAE,QAAQ,OACZ,OAAM,IAAI,qBAAqB,QAAQ,OAAO,MAAM;;AAK1D,KAAI,wBAAwB,yBAAyB,KACnD;OAAK,MAAM,QAAQ,qBACjB,KAAI,EAAE,QAAQ,OACZ,OAAM,IAAI,qBAAqB,QAAQ,OAAO,MAAM;;;AAM5D,SAAgB,aACd,MACA,UACM;AACN,KAAI,MAAM,QAAQ,OAChB;OAAK,MAAM,OAAO,KAChB,KAAI,EAAE,OAAO,UACX,OAAM,IAAI,MAAM,OAAO,OAAO,KAAK;YAInC,EAAE,QAAQ,UACZ,OAAM,IAAI,MAAM,OAAO,OAAO,MAAM"}