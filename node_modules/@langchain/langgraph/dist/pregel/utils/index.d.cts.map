{"version":3,"file":"index.d.cts","names":["Callbacks","RunnableConfig","ChannelVersions","CheckpointMetadata","getNullChannelVersion","getNewChannelVersions","_coerceToDict","RetryPolicy","CachePolicy","patchConfigurable","Record","patchCheckpointMap","combineAbortSignals","AbortSignal","combineCallbacks"],"sources":["../../../src/pregel/utils/index.d.ts"],"sourcesContent":["import { Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { ChannelVersions, CheckpointMetadata } from \"@langchain/langgraph-checkpoint\";\nexport declare function getNullChannelVersion(currentVersions: ChannelVersions): \"\" | 0 | undefined;\nexport declare function getNewChannelVersions(previousVersions: ChannelVersions, currentVersions: ChannelVersions): ChannelVersions;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport declare function _coerceToDict(value: any, defaultKey: string): any;\nexport type RetryPolicy = {\n    /**\n     * Amount of time that must elapse before the first retry occurs in milliseconds.\n     * @default 500\n     */\n    initialInterval?: number;\n    /**\n     * Multiplier by which the interval increases after each retry.\n     * @default 2\n     */\n    backoffFactor?: number;\n    /**\n     * Maximum amount of time that may elapse between retries in milliseconds.\n     * @default 128000\n     */\n    maxInterval?: number;\n    /**\n     * Maximum amount of time that may elapse between retries.\n     * @default 3\n     */\n    maxAttempts?: number;\n    /** Whether to add random jitter to the interval between retries. */\n    jitter?: boolean;\n    /** A function that returns True for exceptions that should trigger a retry. */\n    retryOn?: (e: any) => boolean; // eslint-disable-line @typescript-eslint/no-explicit-any\n    /** Whether to log a warning when a retry is attempted. Defaults to true. */\n    logWarning?: boolean;\n};\n/**\n * Configuration for caching nodes.\n */\nexport type CachePolicy = {\n    /**\n     * A function used to generate a cache key from node's input.\n     * @returns A key for the cache.\n     */\n    keyFunc?: (args: unknown[]) => string;\n    /**\n     * The time to live for the cache in seconds.\n     * If not defined, the entry will never expire.\n     */\n    ttl?: number;\n};\nexport declare function patchConfigurable(config: RunnableConfig | undefined, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\npatch: Record<string, any>): RunnableConfig;\nexport declare function patchCheckpointMap(config: RunnableConfig, metadata?: CheckpointMetadata): RunnableConfig;\n/**\n * Combine multiple abort signals into a single abort signal.\n * @param signals - The abort signals to combine.\n * @returns A combined abort signal and a dispose function to remove the abort listener if unused.\n */\nexport declare function combineAbortSignals(...x: (AbortSignal | undefined)[]): {\n    signal: AbortSignal | undefined;\n    dispose?: () => void;\n};\n/**\n * Combine multiple callbacks into a single callback.\n * @param callback1 - The first callback to combine.\n * @param callback2 - The second callback to combine.\n * @returns A single callback that is a combination of the input callbacks.\n */\nexport declare const combineCallbacks: (callback1?: Callbacks | undefined, callback2?: Callbacks | undefined) => Callbacks | undefined;\n"],"mappings":";;;;;KAOYO,WAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA+BAC,WAAAA"}