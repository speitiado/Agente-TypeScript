{"version":3,"file":"loop.cjs","names":["IterableReadableWritableStream","BaseCache","START","CONFIG_KEY_RESUMING","isCommand","increment","CONFIG_KEY_STREAM","CONFIG_KEY_SCRATCHPAD","patchConfigurable","CONFIG_KEY_CHECKPOINT_NS","CHECKPOINT_NAMESPACE_SEPARATOR","CONFIG_KEY_READ","CONFIG_KEY_CHECKPOINT_MAP","saved: CheckpointTuple","emptyChannels","AsyncBatchedStore","WRITES_IDX_MAP","CONFIG_KEY_CHECKPOINT_ID","ERROR","INTERRUPT","TAG_HIDDEN","PUSH","gatherIteratorSync","prefixGenerator","mapOutputUpdates","mapDebugTaskResults","matched: {\n      task: PregelExecutableTask<string, string>;\n      result: unknown;\n    }[]","keys: CacheFullKey[]","keyMap: Record<string, PregelExecutableTask<string, string>>","GraphInterrupt","_applyWrites","gatherIterator","mapOutputValues","shouldInterrupt","_prepareNextTasks","mapDebugCheckpoint","RESUME","mapDebugTasks","CHECKPOINT_NAMESPACE_END","readChannels","isGraphInterrupt","_prepareSingleTask","task","NULL_TASK_ID","isXXH3","CONFIG_KEY_RESUME_MAP","writes: { [key: string]: PendingWrite[] }","mapCommand","EmptyInputError","INPUT","mapInput","getNewChannelVersions","createCheckpoint","byTask: Record<string, PendingWrite<string>[]>"],"sources":["../../src/pregel/loop.ts"],"sourcesContent":["import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  BaseCheckpointSaver,\n  Checkpoint,\n  CheckpointTuple,\n  copyCheckpoint,\n  emptyCheckpoint,\n  PendingWrite,\n  CheckpointPendingWrite,\n  CheckpointMetadata,\n  All,\n  BaseStore,\n  AsyncBatchedStore,\n  WRITES_IDX_MAP,\n  BaseCache,\n  CacheFullKey,\n  CacheNamespace,\n} from \"@langchain/langgraph-checkpoint\";\n\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n} from \"../channels/base.js\";\nimport type {\n  Call,\n  CallTaskPath,\n  Durability,\n  PregelExecutableTask,\n  PregelScratchpad,\n  StreamMode,\n} from \"./types.js\";\nimport {\n  isCommand,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_RESUMING,\n  CONFIG_KEY_STREAM,\n  ERROR,\n  INPUT,\n  INTERRUPT,\n  NULL_TASK_ID,\n  RESUME,\n  TAG_HIDDEN,\n  PUSH,\n  CONFIG_KEY_SCRATCHPAD,\n  CONFIG_KEY_CHECKPOINT_NS,\n  CHECKPOINT_NAMESPACE_END,\n  CONFIG_KEY_CHECKPOINT_ID,\n  CONFIG_KEY_RESUME_MAP,\n  START,\n} from \"../constants.js\";\nimport {\n  _applyWrites,\n  _prepareNextTasks,\n  _prepareSingleTask,\n  increment,\n  shouldInterrupt,\n  WritesProtocol,\n} from \"./algo.js\";\nimport {\n  gatherIterator,\n  gatherIteratorSync,\n  prefixGenerator,\n} from \"../utils.js\";\nimport {\n  mapCommand,\n  mapInput,\n  mapOutputUpdates,\n  mapOutputValues,\n  readChannels,\n} from \"./io.js\";\nimport {\n  EmptyInputError,\n  GraphInterrupt,\n  isGraphInterrupt,\n} from \"../errors.js\";\nimport { getNewChannelVersions, patchConfigurable } from \"./utils/index.js\";\nimport {\n  mapDebugTasks,\n  mapDebugCheckpoint,\n  mapDebugTaskResults,\n  printStepTasks,\n} from \"./debug.js\";\nimport { PregelNode } from \"./read.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { IterableReadableWritableStream, StreamChunk } from \"./stream.js\";\nimport { isXXH3 } from \"../hash.js\";\n\nconst INPUT_DONE = Symbol.for(\"INPUT_DONE\");\nconst INPUT_RESUMING = Symbol.for(\"INPUT_RESUMING\");\nconst DEFAULT_LOOP_LIMIT = 25;\n\nexport type PregelLoopInitializeParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any | Command;\n  config: RunnableConfig;\n  checkpointer?: BaseCheckpointSaver;\n  outputKeys: string | string[];\n  streamKeys: string | string[];\n  nodes: Record<string, PregelNode>;\n  channelSpecs: Record<string, BaseChannel>;\n  stream: IterableReadableWritableStream;\n  store?: BaseStore;\n  cache?: BaseCache<PendingWrite<string>[]>;\n  interruptAfter: string[] | All;\n  interruptBefore: string[] | All;\n  durability: Durability;\n  manager?: CallbackManagerForChainRun;\n  debug: boolean;\n  triggerToNodes: Record<string, string[]>;\n};\n\ntype PregelLoopParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any | Command;\n  config: RunnableConfig;\n  checkpointer?: BaseCheckpointSaver;\n  checkpoint: Checkpoint;\n  checkpointMetadata: CheckpointMetadata;\n  checkpointPreviousVersions: Record<string, string | number>;\n  checkpointPendingWrites: CheckpointPendingWrite[];\n  checkpointConfig: RunnableConfig;\n  channels: Record<string, BaseChannel>;\n  step: number;\n  stop: number;\n  outputKeys: string | string[];\n  streamKeys: string | string[];\n  nodes: Record<string, PregelNode>;\n  checkpointNamespace: string[];\n  skipDoneTasks: boolean;\n  isNested: boolean;\n  manager?: CallbackManagerForChainRun;\n  stream: IterableReadableWritableStream;\n  store?: AsyncBatchedStore;\n  cache?: BaseCache<PendingWrite<string>[]>;\n  prevCheckpointConfig: RunnableConfig | undefined;\n  interruptAfter: string[] | All;\n  interruptBefore: string[] | All;\n  durability: Durability;\n  debug: boolean;\n  triggerToNodes: Record<string, string[]>;\n};\n\nfunction createDuplexStream(...streams: IterableReadableWritableStream[]) {\n  return new IterableReadableWritableStream({\n    passthroughFn: (value: StreamChunk) => {\n      for (const stream of streams) {\n        if (stream.modes.has(value[1])) {\n          stream.push(value);\n        }\n      }\n    },\n    modes: new Set(streams.flatMap((s) => Array.from(s.modes))),\n  });\n}\n\nclass AsyncBatchedCache extends BaseCache<PendingWrite<string>[]> {\n  protected cache: BaseCache<PendingWrite<string>[]>;\n\n  private queue: Promise<unknown> = Promise.resolve();\n\n  constructor(cache: BaseCache<unknown>) {\n    super();\n    this.cache = cache as BaseCache<PendingWrite<string>[]>;\n  }\n\n  async get(keys: CacheFullKey[]) {\n    return this.enqueueOperation(\"get\", keys);\n  }\n\n  async set(\n    pairs: {\n      key: CacheFullKey;\n      value: PendingWrite<string>[];\n      ttl?: number;\n    }[]\n  ) {\n    return this.enqueueOperation(\"set\", pairs);\n  }\n\n  async clear(namespaces: CacheNamespace[]) {\n    return this.enqueueOperation(\"clear\", namespaces);\n  }\n\n  async stop() {\n    await this.queue;\n  }\n\n  private enqueueOperation<Type extends \"get\" | \"set\" | \"clear\">(\n    type: Type,\n    ...args: Parameters<(typeof this.cache)[Type]>\n  ) {\n    const newPromise = this.queue.then(() => {\n      // @ts-expect-error Tuple type warning\n      return this.cache[type](...args) as Promise<\n        ReturnType<(typeof this.cache)[Type]>\n      >;\n    });\n\n    this.queue = newPromise.then(\n      () => void 0,\n      () => void 0\n    );\n\n    return newPromise;\n  }\n}\n\nexport class PregelLoop {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected input?: any | Command;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  output: any;\n\n  config: LangGraphRunnableConfig;\n\n  protected checkpointer?: BaseCheckpointSaver;\n\n  protected checkpointerGetNextVersion: (current: number | undefined) => number;\n\n  channels: Record<string, BaseChannel>;\n\n  protected checkpoint: Checkpoint;\n\n  protected checkpointIdSaved: string | undefined;\n\n  protected checkpointConfig: RunnableConfig;\n\n  checkpointMetadata: CheckpointMetadata;\n\n  protected checkpointNamespace: string[];\n\n  protected checkpointPendingWrites: CheckpointPendingWrite[] = [];\n\n  protected checkpointPreviousVersions: Record<string, string | number>;\n\n  step: number;\n\n  protected stop: number;\n\n  protected durability: Durability;\n\n  protected outputKeys: string | string[];\n\n  protected streamKeys: string | string[];\n\n  protected nodes: Record<string, PregelNode>;\n\n  protected skipDoneTasks: boolean;\n\n  protected prevCheckpointConfig: RunnableConfig | undefined;\n\n  protected updatedChannels: Set<string> | undefined;\n\n  status:\n    | \"pending\"\n    | \"done\"\n    | \"interrupt_before\"\n    | \"interrupt_after\"\n    | \"out_of_steps\" = \"pending\";\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tasks: Record<string, PregelExecutableTask<any, any>> = {};\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  stream: IterableReadableWritableStream;\n\n  checkpointerPromises: Promise<unknown>[] = [];\n\n  isNested: boolean;\n\n  protected _checkpointerChainedPromise: Promise<unknown> = Promise.resolve();\n\n  store?: AsyncBatchedStore;\n\n  cache?: AsyncBatchedCache;\n\n  manager?: CallbackManagerForChainRun;\n\n  interruptAfter: string[] | All;\n\n  interruptBefore: string[] | All;\n\n  toInterrupt: PregelExecutableTask<string, string>[] = [];\n\n  debug: boolean = false;\n\n  triggerToNodes: Record<string, string[]>;\n\n  get isResuming() {\n    let hasChannelVersions = false;\n    if (START in this.checkpoint.channel_versions) {\n      // For common channels, we can short-circuit the check\n      hasChannelVersions = true;\n    } else {\n      for (const chan in this.checkpoint.channel_versions) {\n        if (\n          Object.prototype.hasOwnProperty.call(\n            this.checkpoint.channel_versions,\n            chan\n          )\n        ) {\n          hasChannelVersions = true;\n          break;\n        }\n      }\n    }\n\n    const configHasResumingFlag =\n      this.config.configurable?.[CONFIG_KEY_RESUMING] !== undefined;\n    const configIsResuming =\n      configHasResumingFlag && this.config.configurable?.[CONFIG_KEY_RESUMING];\n\n    const inputIsNullOrUndefined =\n      this.input === null || this.input === undefined;\n    const inputIsCommandResuming =\n      isCommand(this.input) && this.input.resume != null;\n    const inputIsResuming = this.input === INPUT_RESUMING;\n\n    const runIdMatchesPrevious =\n      !this.isNested &&\n      this.config.metadata?.run_id !== undefined &&\n      (this.checkpointMetadata as { run_id?: unknown })?.run_id !== undefined &&\n      this.config.metadata.run_id ===\n        (this.checkpointMetadata as { run_id?: unknown })?.run_id;\n\n    return (\n      hasChannelVersions &&\n      (configIsResuming ||\n        inputIsNullOrUndefined ||\n        inputIsCommandResuming ||\n        inputIsResuming ||\n        runIdMatchesPrevious)\n    );\n  }\n\n  constructor(params: PregelLoopParams) {\n    this.input = params.input;\n    this.checkpointer = params.checkpointer;\n    // TODO: if managed values no longer needs graph we can replace with\n    // managed_specs, channel_specs\n    if (this.checkpointer !== undefined) {\n      this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(\n        this.checkpointer\n      );\n    } else {\n      this.checkpointerGetNextVersion = increment;\n    }\n    this.checkpoint = params.checkpoint;\n    this.checkpointMetadata = params.checkpointMetadata;\n    this.checkpointPreviousVersions = params.checkpointPreviousVersions;\n    this.channels = params.channels;\n    this.checkpointPendingWrites = params.checkpointPendingWrites;\n    this.step = params.step;\n    this.stop = params.stop;\n    this.config = params.config;\n    this.checkpointConfig = params.checkpointConfig;\n    this.isNested = params.isNested;\n    this.manager = params.manager;\n    this.outputKeys = params.outputKeys;\n    this.streamKeys = params.streamKeys;\n    this.nodes = params.nodes;\n    this.skipDoneTasks = params.skipDoneTasks;\n    this.store = params.store;\n    this.cache = params.cache ? new AsyncBatchedCache(params.cache) : undefined;\n    this.stream = params.stream;\n    this.checkpointNamespace = params.checkpointNamespace;\n    this.prevCheckpointConfig = params.prevCheckpointConfig;\n    this.interruptAfter = params.interruptAfter;\n    this.interruptBefore = params.interruptBefore;\n    this.durability = params.durability;\n    this.debug = params.debug;\n    this.triggerToNodes = params.triggerToNodes;\n  }\n\n  static async initialize(params: PregelLoopInitializeParams) {\n    let { config, stream } = params;\n    if (\n      stream !== undefined &&\n      config.configurable?.[CONFIG_KEY_STREAM] !== undefined\n    ) {\n      stream = createDuplexStream(\n        stream,\n        config.configurable[CONFIG_KEY_STREAM]\n      );\n    }\n    const skipDoneTasks = config.configurable\n      ? !(\"checkpoint_id\" in config.configurable)\n      : true;\n\n    const scratchpad = config.configurable?.[CONFIG_KEY_SCRATCHPAD] as\n      | PregelScratchpad\n      | undefined;\n\n    if (config.configurable && scratchpad) {\n      if (scratchpad.subgraphCounter > 0) {\n        config = patchConfigurable(config, {\n          [CONFIG_KEY_CHECKPOINT_NS]: [\n            config.configurable[CONFIG_KEY_CHECKPOINT_NS],\n            scratchpad.subgraphCounter.toString(),\n          ].join(CHECKPOINT_NAMESPACE_SEPARATOR),\n        });\n      }\n\n      scratchpad.subgraphCounter += 1;\n    }\n\n    const isNested = CONFIG_KEY_READ in (config.configurable ?? {});\n    if (\n      !isNested &&\n      config.configurable?.checkpoint_ns !== undefined &&\n      config.configurable?.checkpoint_ns !== \"\"\n    ) {\n      config = patchConfigurable(config, {\n        checkpoint_ns: \"\",\n        checkpoint_id: undefined,\n      });\n    }\n    let checkpointConfig = config;\n    if (\n      config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] !== undefined &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP]?.[\n        config.configurable?.checkpoint_ns\n      ]\n    ) {\n      checkpointConfig = patchConfigurable(config, {\n        checkpoint_id:\n          config.configurable[CONFIG_KEY_CHECKPOINT_MAP][\n            config.configurable?.checkpoint_ns\n          ],\n      });\n    }\n    const checkpointNamespace =\n      config.configurable?.checkpoint_ns?.split(\n        CHECKPOINT_NAMESPACE_SEPARATOR\n      ) ?? [];\n\n    const saved: CheckpointTuple = (await params.checkpointer?.getTuple(\n      checkpointConfig\n    )) ?? {\n      config,\n      checkpoint: emptyCheckpoint(),\n      metadata: { source: \"input\", step: -2, parents: {} },\n      pendingWrites: [],\n    };\n    checkpointConfig = {\n      ...config,\n      ...saved.config,\n      configurable: {\n        checkpoint_ns: \"\",\n        ...config.configurable,\n        ...saved.config.configurable,\n      },\n    };\n    const prevCheckpointConfig = saved.parentConfig;\n    const checkpoint = copyCheckpoint(saved.checkpoint);\n    const checkpointMetadata = { ...saved.metadata } as CheckpointMetadata;\n    const checkpointPendingWrites = saved.pendingWrites ?? [];\n\n    const channels = emptyChannels(params.channelSpecs, checkpoint);\n\n    const step = (checkpointMetadata.step ?? 0) + 1;\n    const stop = step + (config.recursionLimit ?? DEFAULT_LOOP_LIMIT) + 1;\n    const checkpointPreviousVersions = { ...checkpoint.channel_versions };\n\n    const store = params.store\n      ? new AsyncBatchedStore(params.store)\n      : undefined;\n\n    if (store) {\n      // Start the store. This is a batch store, so it will run continuously\n      await store.start();\n    }\n    return new PregelLoop({\n      input: params.input,\n      config,\n      checkpointer: params.checkpointer,\n      checkpoint,\n      checkpointMetadata,\n      checkpointConfig,\n      prevCheckpointConfig,\n      checkpointNamespace,\n      channels,\n      isNested,\n      manager: params.manager,\n      skipDoneTasks,\n      step,\n      stop,\n      checkpointPreviousVersions,\n      checkpointPendingWrites,\n      outputKeys: params.outputKeys ?? [],\n      streamKeys: params.streamKeys ?? [],\n      nodes: params.nodes,\n      stream,\n      store,\n      cache: params.cache,\n      interruptAfter: params.interruptAfter,\n      interruptBefore: params.interruptBefore,\n      durability: params.durability,\n      debug: params.debug,\n      triggerToNodes: params.triggerToNodes,\n    });\n  }\n\n  protected _checkpointerPutAfterPrevious(input: {\n    config: RunnableConfig;\n    checkpoint: Checkpoint;\n    metadata: CheckpointMetadata;\n    newVersions: Record<string, string | number>;\n  }) {\n    this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(\n      () => {\n        return this.checkpointer?.put(\n          input.config,\n          input.checkpoint,\n          input.metadata,\n          input.newVersions\n        );\n      }\n    );\n    this.checkpointerPromises.push(this._checkpointerChainedPromise);\n  }\n\n  /**\n   * Put writes for a task, to be read by the next tick.\n   * @param taskId\n   * @param writes\n   */\n  putWrites(taskId: string, writes: PendingWrite<string>[]) {\n    let writesCopy = writes;\n    if (writesCopy.length === 0) return;\n\n    // deduplicate writes to special channels, last write wins\n    if (writesCopy.every(([key]) => key in WRITES_IDX_MAP)) {\n      writesCopy = Array.from(\n        new Map(writesCopy.map((w) => [w[0], w])).values()\n      );\n    }\n\n    // remove existing writes for this task\n    this.checkpointPendingWrites = this.checkpointPendingWrites.filter(\n      (w) => w[0] !== taskId\n    );\n\n    // save writes\n    for (const [c, v] of writesCopy) {\n      this.checkpointPendingWrites.push([taskId, c, v]);\n    }\n\n    const config = patchConfigurable(this.checkpointConfig, {\n      [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? \"\",\n      [CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id,\n    });\n\n    if (this.durability !== \"exit\" && this.checkpointer != null) {\n      this.checkpointerPromises.push(\n        this.checkpointer.putWrites(config, writesCopy, taskId)\n      );\n    }\n\n    if (this.tasks) {\n      this._outputWrites(taskId, writesCopy);\n    }\n\n    if (!writes.length || !this.cache || !this.tasks) {\n      return;\n    }\n\n    // only cache tasks with a cache key\n    const task = this.tasks[taskId];\n    if (task == null || task.cache_key == null) {\n      return;\n    }\n\n    // only cache successful tasks\n    if (writes[0][0] === ERROR || writes[0][0] === INTERRUPT) {\n      return;\n    }\n\n    void this.cache.set([\n      {\n        key: [task.cache_key.ns, task.cache_key.key],\n        value: task.writes,\n        ttl: task.cache_key.ttl,\n      },\n    ]);\n  }\n\n  _outputWrites(taskId: string, writes: [string, unknown][], cached = false) {\n    const task = this.tasks[taskId];\n    if (task !== undefined) {\n      if (\n        task.config !== undefined &&\n        (task.config.tags ?? []).includes(TAG_HIDDEN)\n      ) {\n        return;\n      }\n\n      if (writes.length > 0) {\n        if (writes[0][0] === INTERRUPT) {\n          // in `algo.ts` we append a bool to the task path to indicate\n          // whether or not a call was present. If so, we don't emit the\n          // the interrupt as it'll be emitted by the parent.\n          if (task.path?.[0] === PUSH && task.path?.at(-1) === true) return;\n\n          const interruptWrites = writes\n            .filter((w) => w[0] === INTERRUPT)\n            .flatMap((w) => w[1] as string[]);\n\n          this._emit([\n            [\"updates\", { [INTERRUPT]: interruptWrites }],\n            [\"values\", { [INTERRUPT]: interruptWrites }],\n          ]);\n        } else if (writes[0][0] !== ERROR) {\n          this._emit(\n            gatherIteratorSync(\n              prefixGenerator(\n                mapOutputUpdates(this.outputKeys, [[task, writes]], cached),\n                \"updates\"\n              )\n            )\n          );\n        }\n      }\n      if (!cached) {\n        this._emit(\n          gatherIteratorSync(\n            prefixGenerator(\n              mapDebugTaskResults([[task, writes]], this.streamKeys),\n              \"tasks\"\n            )\n          )\n        );\n      }\n    }\n  }\n\n  async _matchCachedWrites() {\n    if (!this.cache) return [];\n\n    const matched: {\n      task: PregelExecutableTask<string, string>;\n      result: unknown;\n    }[] = [];\n\n    const serializeKey = ([ns, key]: CacheFullKey) => {\n      return `ns:${ns.join(\",\")}|key:${key}`;\n    };\n\n    const keys: CacheFullKey[] = [];\n    const keyMap: Record<string, PregelExecutableTask<string, string>> = {};\n\n    for (const task of Object.values(this.tasks)) {\n      if (task.cache_key != null && !task.writes.length) {\n        keys.push([task.cache_key.ns, task.cache_key.key]);\n        keyMap[serializeKey([task.cache_key.ns, task.cache_key.key])] = task;\n      }\n    }\n\n    if (keys.length === 0) return [];\n    const cache = await this.cache.get(keys);\n\n    for (const { key, value } of cache) {\n      const task = keyMap[serializeKey(key)];\n      if (task != null) {\n        // update the task with the cached writes\n        task.writes.push(...value);\n        matched.push({ task, result: value });\n      }\n    }\n\n    return matched;\n  }\n\n  /**\n   * Execute a single iteration of the Pregel loop.\n   * Returns true if more iterations are needed.\n   * @param params\n   */\n  async tick(params: { inputKeys?: string | string[] }): Promise<boolean> {\n    if (this.store && !this.store.isRunning) {\n      await this.store?.start();\n    }\n    const { inputKeys = [] } = params;\n    if (this.status !== \"pending\") {\n      throw new Error(\n        `Cannot tick when status is no longer \"pending\". Current status: \"${this.status}\"`\n      );\n    }\n    if (![INPUT_DONE, INPUT_RESUMING].includes(this.input)) {\n      await this._first(inputKeys);\n    } else if (this.toInterrupt.length > 0) {\n      this.status = \"interrupt_before\";\n      throw new GraphInterrupt();\n    } else if (\n      Object.values(this.tasks).every((task) => task.writes.length > 0)\n    ) {\n      // finish superstep\n      const writes = Object.values(this.tasks).flatMap((t) => t.writes);\n      // All tasks have finished\n      this.updatedChannels = _applyWrites(\n        this.checkpoint,\n        this.channels,\n        Object.values(this.tasks),\n        this.checkpointerGetNextVersion,\n        this.triggerToNodes\n      );\n      // produce values output\n      const valuesOutput = await gatherIterator(\n        prefixGenerator(\n          mapOutputValues(this.outputKeys, writes, this.channels),\n          \"values\"\n        )\n      );\n      this._emit(valuesOutput);\n      // clear pending writes\n      this.checkpointPendingWrites = [];\n      await this._putCheckpoint({ source: \"loop\" });\n      // after execution, check if we should interrupt\n      if (\n        shouldInterrupt(\n          this.checkpoint,\n          this.interruptAfter,\n          Object.values(this.tasks)\n        )\n      ) {\n        this.status = \"interrupt_after\";\n        throw new GraphInterrupt();\n      }\n\n      // unset resuming flag\n      if (this.config.configurable?.[CONFIG_KEY_RESUMING] !== undefined) {\n        delete this.config.configurable?.[CONFIG_KEY_RESUMING];\n      }\n    } else {\n      return false;\n    }\n    if (this.step > this.stop) {\n      this.status = \"out_of_steps\";\n      return false;\n    }\n\n    const nextTasks = _prepareNextTasks(\n      this.checkpoint,\n      this.checkpointPendingWrites,\n      this.nodes,\n      this.channels,\n      this.config,\n      true,\n      {\n        step: this.step,\n        checkpointer: this.checkpointer,\n        isResuming: this.isResuming,\n        manager: this.manager,\n        store: this.store,\n        stream: this.stream,\n        triggerToNodes: this.triggerToNodes,\n        updatedChannels: this.updatedChannels,\n      }\n    );\n    this.tasks = nextTasks;\n\n    // Produce debug output\n    if (this.checkpointer) {\n      this._emit(\n        await gatherIterator(\n          prefixGenerator(\n            mapDebugCheckpoint(\n              this.checkpointConfig,\n              this.channels,\n              this.streamKeys,\n              this.checkpointMetadata,\n              Object.values(this.tasks),\n              this.checkpointPendingWrites,\n              this.prevCheckpointConfig,\n              this.outputKeys\n            ),\n            \"checkpoints\"\n          )\n        )\n      );\n    }\n\n    if (Object.values(this.tasks).length === 0) {\n      this.status = \"done\";\n      return false;\n    }\n    // if there are pending writes from a previous loop, apply them\n    if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {\n      for (const [tid, k, v] of this.checkpointPendingWrites) {\n        if (k === ERROR || k === INTERRUPT || k === RESUME) {\n          continue;\n        }\n        const task = Object.values(this.tasks).find((t) => t.id === tid);\n        if (task) {\n          task.writes.push([k, v]);\n        }\n      }\n      for (const task of Object.values(this.tasks)) {\n        if (task.writes.length > 0) {\n          this._outputWrites(task.id, task.writes, true);\n        }\n      }\n    }\n    // if all tasks have finished, re-tick\n    if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {\n      return this.tick({ inputKeys });\n    }\n\n    // Before execution, check if we should interrupt\n    if (\n      shouldInterrupt(\n        this.checkpoint,\n        this.interruptBefore,\n        Object.values(this.tasks)\n      )\n    ) {\n      this.status = \"interrupt_before\";\n      throw new GraphInterrupt();\n    }\n\n    // Produce debug output\n    const debugOutput = await gatherIterator(\n      prefixGenerator(mapDebugTasks(Object.values(this.tasks)), \"tasks\")\n    );\n    this._emit(debugOutput);\n\n    return true;\n  }\n\n  async finishAndHandleError(error?: Error) {\n    // persist current checkpoint and writes\n    if (\n      this.durability === \"exit\" &&\n      // if it's a top graph\n      (!this.isNested ||\n        // or a nested graph with error or interrupt\n        typeof error !== \"undefined\" ||\n        // or a nested graph with checkpointer: true\n        this.checkpointNamespace.every(\n          (part) => !part.includes(CHECKPOINT_NAMESPACE_END)\n        ))\n    ) {\n      this._putCheckpoint(this.checkpointMetadata);\n      this._flushPendingWrites();\n    }\n\n    const suppress = this._suppressInterrupt(error);\n    if (suppress || error === undefined) {\n      this.output = readChannels(this.channels, this.outputKeys);\n    }\n    if (suppress) {\n      // emit one last \"values\" event, with pending writes applied\n      if (\n        this.tasks !== undefined &&\n        this.checkpointPendingWrites.length > 0 &&\n        Object.values(this.tasks).some((task) => task.writes.length > 0)\n      ) {\n        this.updatedChannels = _applyWrites(\n          this.checkpoint,\n          this.channels,\n          Object.values(this.tasks),\n          this.checkpointerGetNextVersion,\n          this.triggerToNodes\n        );\n\n        this._emit(\n          gatherIteratorSync(\n            prefixGenerator(\n              mapOutputValues(\n                this.outputKeys,\n                Object.values(this.tasks).flatMap((t) => t.writes),\n                this.channels\n              ),\n              \"values\"\n            )\n          )\n        );\n      }\n\n      // Emit INTERRUPT event\n      if (isGraphInterrupt(error) && !error.interrupts.length) {\n        this._emit([\n          [\"updates\", { [INTERRUPT]: [] }],\n          [\"values\", { [INTERRUPT]: [] }],\n        ]);\n      }\n    }\n    return suppress;\n  }\n\n  async acceptPush(\n    task: PregelExecutableTask<string, string>,\n    writeIdx: number,\n    call?: Call\n  ): Promise<PregelExecutableTask<string, string> | void> {\n    if (\n      this.interruptAfter?.length > 0 &&\n      shouldInterrupt(this.checkpoint, this.interruptAfter, [task])\n    ) {\n      this.toInterrupt.push(task);\n      return;\n    }\n\n    const pushed = _prepareSingleTask(\n      [PUSH, task.path ?? [], writeIdx, task.id, call] as CallTaskPath,\n      this.checkpoint,\n      this.checkpointPendingWrites,\n      this.nodes,\n      this.channels,\n      task.config ?? {},\n      true,\n      {\n        step: this.step,\n        checkpointer: this.checkpointer,\n        manager: this.manager,\n        store: this.store,\n        stream: this.stream,\n      }\n    );\n\n    if (!pushed) return;\n    if (\n      this.interruptBefore?.length > 0 &&\n      shouldInterrupt(this.checkpoint, this.interruptBefore, [pushed])\n    ) {\n      this.toInterrupt.push(pushed);\n      return;\n    }\n\n    this._emit(\n      gatherIteratorSync(prefixGenerator(mapDebugTasks([pushed]), \"tasks\"))\n    );\n\n    if (this.debug) printStepTasks(this.step, [pushed]);\n    this.tasks[pushed.id] = pushed;\n    if (this.skipDoneTasks) this._matchWrites({ [pushed.id]: pushed });\n\n    const tasks = await this._matchCachedWrites();\n    for (const { task } of tasks) {\n      this._outputWrites(task.id, task.writes, true);\n    }\n\n    return pushed;\n  }\n\n  protected _suppressInterrupt(e?: Error): boolean {\n    return isGraphInterrupt(e) && !this.isNested;\n  }\n\n  protected async _first(inputKeys: string | string[]) {\n    /*\n     * Resuming from previous checkpoint requires\n     * - finding a previous checkpoint\n     * - receiving null input (outer graph) or RESUMING flag (subgraph)\n     */\n\n    const { configurable } = this.config;\n\n    // take resume value from parent\n    const scratchpad = configurable?.[\n      CONFIG_KEY_SCRATCHPAD\n    ] as PregelScratchpad;\n\n    if (scratchpad && scratchpad.nullResume !== undefined) {\n      this.putWrites(NULL_TASK_ID, [[RESUME, scratchpad.nullResume]]);\n    }\n\n    // map command to writes\n    if (isCommand(this.input)) {\n      const hasResume = this.input.resume != null;\n\n      if (\n        this.input.resume != null &&\n        typeof this.input.resume === \"object\" &&\n        Object.keys(this.input.resume).every(isXXH3)\n      ) {\n        this.config.configurable ??= {};\n        this.config.configurable[CONFIG_KEY_RESUME_MAP] = this.input.resume;\n      }\n\n      if (hasResume && this.checkpointer == null) {\n        throw new Error(\"Cannot use Command(resume=...) without checkpointer\");\n      }\n\n      const writes: { [key: string]: PendingWrite[] } = {};\n\n      // group writes by task id\n      for (const [tid, key, value] of mapCommand(\n        this.input,\n        this.checkpointPendingWrites\n      )) {\n        writes[tid] ??= [];\n        writes[tid].push([key, value]);\n      }\n      if (Object.keys(writes).length === 0) {\n        throw new EmptyInputError(\"Received empty Command input\");\n      }\n\n      // save writes\n      for (const [tid, ws] of Object.entries(writes)) {\n        this.putWrites(tid, ws);\n      }\n    }\n\n    // apply null writes\n    const nullWrites = (this.checkpointPendingWrites ?? [])\n      .filter((w) => w[0] === NULL_TASK_ID)\n      .map((w) => w.slice(1)) as PendingWrite<string>[];\n    if (nullWrites.length > 0) {\n      _applyWrites(\n        this.checkpoint,\n        this.channels,\n        [\n          {\n            name: INPUT,\n            writes: nullWrites,\n            triggers: [],\n          },\n        ],\n        this.checkpointerGetNextVersion,\n        this.triggerToNodes\n      );\n    }\n    const isCommandUpdateOrGoto =\n      isCommand(this.input) && nullWrites.length > 0;\n    if (this.isResuming || isCommandUpdateOrGoto) {\n      for (const channelName in this.channels) {\n        if (!Object.prototype.hasOwnProperty.call(this.channels, channelName))\n          continue;\n        if (this.checkpoint.channel_versions[channelName] !== undefined) {\n          const version = this.checkpoint.channel_versions[channelName];\n          this.checkpoint.versions_seen[INTERRUPT] = {\n            ...this.checkpoint.versions_seen[INTERRUPT],\n            [channelName]: version,\n          };\n        }\n      }\n      // produce values output\n      const valuesOutput = await gatherIterator(\n        prefixGenerator(\n          mapOutputValues(this.outputKeys, true, this.channels),\n          \"values\"\n        )\n      );\n      this._emit(valuesOutput);\n    }\n    if (this.isResuming) {\n      this.input = INPUT_RESUMING;\n    } else if (isCommandUpdateOrGoto) {\n      // we need to create a new checkpoint for Command(update=...) or Command(goto=...)\n      // in case the result of Command(goto=...) is an interrupt.\n      // If not done, the checkpoint containing the interrupt will be lost.\n      await this._putCheckpoint({ source: \"input\" });\n      this.input = INPUT_DONE;\n    } else {\n      // map inputs to channel updates\n      const inputWrites = await gatherIterator(mapInput(inputKeys, this.input));\n      if (inputWrites.length > 0) {\n        const discardTasks = _prepareNextTasks(\n          this.checkpoint,\n          this.checkpointPendingWrites,\n          this.nodes,\n          this.channels,\n          this.config,\n          true,\n          { step: this.step }\n        );\n        this.updatedChannels = _applyWrites(\n          this.checkpoint,\n          this.channels,\n          (Object.values(discardTasks) as WritesProtocol[]).concat([\n            {\n              name: INPUT,\n              writes: inputWrites as PendingWrite[],\n              triggers: [],\n            },\n          ]),\n          this.checkpointerGetNextVersion,\n          this.triggerToNodes\n        );\n        // save input checkpoint\n        await this._putCheckpoint({ source: \"input\" });\n\n        this.input = INPUT_DONE;\n      } else if (!(CONFIG_KEY_RESUMING in (this.config.configurable ?? {}))) {\n        throw new EmptyInputError(\n          `Received no input writes for ${JSON.stringify(inputKeys, null, 2)}`\n        );\n      } else {\n        // done with input\n        this.input = INPUT_DONE;\n      }\n    }\n    if (!this.isNested) {\n      this.config = patchConfigurable(this.config, {\n        [CONFIG_KEY_RESUMING]: this.isResuming,\n      });\n    }\n  }\n\n  protected _emit(values: [StreamMode, unknown][]) {\n    for (const [mode, payload] of values) {\n      if (this.stream.modes.has(mode)) {\n        this.stream.push([this.checkpointNamespace, mode, payload]);\n      }\n\n      // debug mode is a \"checkpoints\" or \"tasks\" wrapped in an object\n      // TODO: consider deprecating this in 1.x\n      if (\n        (mode === \"checkpoints\" || mode === \"tasks\") &&\n        this.stream.modes.has(\"debug\")\n      ) {\n        const step = mode === \"checkpoints\" ? this.step - 1 : this.step;\n        const timestamp = new Date().toISOString();\n        const type = (() => {\n          if (mode === \"checkpoints\") {\n            return \"checkpoint\";\n          } else if (\n            typeof payload === \"object\" &&\n            payload != null &&\n            \"result\" in payload\n          ) {\n            return \"task_result\";\n          } else {\n            return \"task\";\n          }\n        })();\n\n        this.stream.push([\n          this.checkpointNamespace,\n          \"debug\",\n          { step, type, timestamp, payload },\n        ]);\n      }\n    }\n  }\n\n  protected _putCheckpoint(\n    inputMetadata: Omit<CheckpointMetadata, \"step\" | \"parents\">\n  ) {\n    const exiting = this.checkpointMetadata === inputMetadata;\n\n    const doCheckpoint =\n      this.checkpointer != null && (this.durability !== \"exit\" || exiting);\n\n    const storeCheckpoint = (checkpoint: Checkpoint) => {\n      // store the previous checkpoint config for debug events\n      this.prevCheckpointConfig = this.checkpointConfig?.configurable\n        ?.checkpoint_id\n        ? this.checkpointConfig\n        : undefined;\n\n      // child graphs keep at most one checkpoint per parent checkpoint\n      // this is achieved by writing child checkpoints as progress is made\n      // (so that error recovery / resuming from interrupt don't lose work)\n      // but doing so always with an id equal to that of the parent checkpoint\n      this.checkpointConfig = patchConfigurable(this.checkpointConfig, {\n        [CONFIG_KEY_CHECKPOINT_NS]:\n          this.config.configurable?.checkpoint_ns ?? \"\",\n      });\n\n      const channelVersions = { ...this.checkpoint.channel_versions };\n      const newVersions = getNewChannelVersions(\n        this.checkpointPreviousVersions,\n        channelVersions\n      );\n      this.checkpointPreviousVersions = channelVersions;\n      // save it, without blocking\n      // if there's a previous checkpoint save in progress, wait for it\n      // ensuring checkpointers receive checkpoints in order\n      void this._checkpointerPutAfterPrevious({\n        config: { ...this.checkpointConfig },\n        checkpoint: copyCheckpoint(checkpoint),\n        metadata: { ...this.checkpointMetadata },\n        newVersions,\n      });\n      this.checkpointConfig = {\n        ...this.checkpointConfig,\n        configurable: {\n          ...this.checkpointConfig.configurable,\n          checkpoint_id: this.checkpoint.id,\n        },\n      };\n    };\n\n    if (!exiting) {\n      this.checkpointMetadata = {\n        ...inputMetadata,\n        step: this.step,\n        parents: this.config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] ?? {},\n      };\n    }\n\n    // create new checkpoint\n    this.checkpoint = createCheckpoint(\n      this.checkpoint,\n      doCheckpoint ? this.channels : undefined,\n      this.step,\n      exiting ? { id: this.checkpoint.id } : undefined\n    );\n\n    // Bail if no checkpointer\n    if (doCheckpoint) storeCheckpoint(this.checkpoint);\n\n    if (!exiting) {\n      // increment step\n      this.step += 1;\n    }\n  }\n\n  protected _flushPendingWrites() {\n    if (this.checkpointer == null) return;\n    if (this.checkpointPendingWrites.length === 0) return;\n\n    // patch config\n    const config = patchConfigurable(this.checkpointConfig, {\n      [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? \"\",\n      [CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id,\n    });\n\n    // group writes by task id\n    const byTask: Record<string, PendingWrite<string>[]> = {};\n    for (const [tid, key, value] of this.checkpointPendingWrites) {\n      byTask[tid] ??= [];\n      byTask[tid].push([key, value]);\n    }\n\n    // submit writes to checkpointer\n    for (const [tid, ws] of Object.entries(byTask)) {\n      this.checkpointerPromises.push(\n        this.checkpointer.putWrites(config, ws, tid)\n      );\n    }\n  }\n\n  protected _matchWrites(\n    tasks: Record<string, PregelExecutableTask<string, string>>\n  ) {\n    for (const [tid, k, v] of this.checkpointPendingWrites) {\n      if (k === ERROR || k === INTERRUPT || k === RESUME) {\n        continue;\n      }\n      const task = Object.values(tasks).find((t) => t.id === tid);\n      if (task) {\n        task.writes.push([k, v]);\n      }\n    }\n    for (const task of Object.values(tasks)) {\n      if (task.writes.length > 0) {\n        this._outputWrites(task.id, task.writes, true);\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;AA4FA,MAAM,aAAa,OAAO,IAAI;AAC9B,MAAM,iBAAiB,OAAO,IAAI;AAClC,MAAM,qBAAqB;AAqD3B,SAAS,mBAAmB,GAAG,SAA2C;AACxE,QAAO,IAAIA,8CAA+B;EACxC,gBAAgB,UAAuB;AACrC,QAAK,MAAM,UAAU,QACnB,KAAI,OAAO,MAAM,IAAI,MAAM,IACzB,QAAO,KAAK;;EAIlB,OAAO,IAAI,IAAI,QAAQ,SAAS,MAAM,MAAM,KAAK,EAAE;;;AAIvD,IAAM,oBAAN,cAAgCC,2CAAkC;CAChE,AAAU;CAEV,AAAQ,QAA0B,QAAQ;CAE1C,YAAY,OAA2B;AACrC;AACA,OAAK,QAAQ;;CAGf,MAAM,IAAI,MAAsB;AAC9B,SAAO,KAAK,iBAAiB,OAAO;;CAGtC,MAAM,IACJ,OAKA;AACA,SAAO,KAAK,iBAAiB,OAAO;;CAGtC,MAAM,MAAM,YAA8B;AACxC,SAAO,KAAK,iBAAiB,SAAS;;CAGxC,MAAM,OAAO;AACX,QAAM,KAAK;;CAGb,AAAQ,iBACN,MACA,GAAG,MACH;EACA,MAAM,aAAa,KAAK,MAAM,WAAW;AAEvC,UAAO,KAAK,MAAM,MAAM,GAAG;;AAK7B,OAAK,QAAQ,WAAW,WAChB,KAAK,SACL,KAAK;AAGb,SAAO;;;AAIX,IAAa,aAAb,MAAa,WAAW;CAEtB,AAAU;CAGV;CAEA;CAEA,AAAU;CAEV,AAAU;CAEV;CAEA,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV;CAEA,AAAU;CAEV,AAAU,0BAAoD;CAE9D,AAAU;CAEV;CAEA,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV,SAKqB;CAGrB,QAAwD;CAGxD;CAEA,uBAA2C;CAE3C;CAEA,AAAU,8BAAgD,QAAQ;CAElE;CAEA;CAEA;CAEA;CAEA;CAEA,cAAsD;CAEtD,QAAiB;CAEjB;CAEA,IAAI,aAAa;EACf,IAAI,qBAAqB;AACzB,MAAIC,2BAAS,KAAK,WAAW,iBAE3B,sBAAqB;MAErB,MAAK,MAAM,QAAQ,KAAK,WAAW,iBACjC,KACE,OAAO,UAAU,eAAe,KAC9B,KAAK,WAAW,kBAChB,OAEF;AACA,wBAAqB;AACrB;;EAKN,MAAM,wBACJ,KAAK,OAAO,eAAeC,2CAAyB;EACtD,MAAM,mBACJ,yBAAyB,KAAK,OAAO,eAAeA;EAEtD,MAAM,yBACJ,KAAK,UAAU,QAAQ,KAAK,UAAU;EACxC,MAAM,yBACJC,4BAAU,KAAK,UAAU,KAAK,MAAM,UAAU;EAChD,MAAM,kBAAkB,KAAK,UAAU;EAEvC,MAAM,uBACJ,CAAC,KAAK,YACN,KAAK,OAAO,UAAU,WAAW,UAChC,KAAK,oBAA6C,WAAW,UAC9D,KAAK,OAAO,SAAS,WAClB,KAAK,oBAA6C;AAEvD,SACE,uBACC,oBACC,0BACA,0BACA,mBACA;;CAIN,YAAY,QAA0B;AACpC,OAAK,QAAQ,OAAO;AACpB,OAAK,eAAe,OAAO;AAG3B,MAAI,KAAK,iBAAiB,OACxB,MAAK,6BAA6B,KAAK,aAAa,eAAe,KACjE,KAAK;MAGP,MAAK,6BAA6BC;AAEpC,OAAK,aAAa,OAAO;AACzB,OAAK,qBAAqB,OAAO;AACjC,OAAK,6BAA6B,OAAO;AACzC,OAAK,WAAW,OAAO;AACvB,OAAK,0BAA0B,OAAO;AACtC,OAAK,OAAO,OAAO;AACnB,OAAK,OAAO,OAAO;AACnB,OAAK,SAAS,OAAO;AACrB,OAAK,mBAAmB,OAAO;AAC/B,OAAK,WAAW,OAAO;AACvB,OAAK,UAAU,OAAO;AACtB,OAAK,aAAa,OAAO;AACzB,OAAK,aAAa,OAAO;AACzB,OAAK,QAAQ,OAAO;AACpB,OAAK,gBAAgB,OAAO;AAC5B,OAAK,QAAQ,OAAO;AACpB,OAAK,QAAQ,OAAO,QAAQ,IAAI,kBAAkB,OAAO,SAAS;AAClE,OAAK,SAAS,OAAO;AACrB,OAAK,sBAAsB,OAAO;AAClC,OAAK,uBAAuB,OAAO;AACnC,OAAK,iBAAiB,OAAO;AAC7B,OAAK,kBAAkB,OAAO;AAC9B,OAAK,aAAa,OAAO;AACzB,OAAK,QAAQ,OAAO;AACpB,OAAK,iBAAiB,OAAO;;CAG/B,aAAa,WAAW,QAAoC;EAC1D,IAAI,EAAE,QAAQ,WAAW;AACzB,MACE,WAAW,UACX,OAAO,eAAeC,yCAAuB,OAE7C,UAAS,mBACP,QACA,OAAO,aAAaA;EAGxB,MAAM,gBAAgB,OAAO,eACzB,EAAE,mBAAmB,OAAO,gBAC5B;EAEJ,MAAM,aAAa,OAAO,eAAeC;AAIzC,MAAI,OAAO,gBAAgB,YAAY;AACrC,OAAI,WAAW,kBAAkB,EAC/B,UAASC,gCAAkB,QAAQ,GAChCC,6CAA2B,CAC1B,OAAO,aAAaA,6CACpB,WAAW,gBAAgB,YAC3B,KAAKC;AAIX,cAAW,mBAAmB;;EAGhC,MAAM,WAAWC,sCAAoB,OAAO,gBAAgB;AAC5D,MACE,CAAC,YACD,OAAO,cAAc,kBAAkB,UACvC,OAAO,cAAc,kBAAkB,GAEvC,UAASH,gCAAkB,QAAQ;GACjC,eAAe;GACf,eAAe;;EAGnB,IAAI,mBAAmB;AACvB,MACE,OAAO,eAAeI,iDAA+B,UACrD,OAAO,eAAeA,+CACpB,OAAO,cAAc,eAGvB,oBAAmBJ,gCAAkB,QAAQ,EAC3C,eACE,OAAO,aAAaI,6CAClB,OAAO,cAAc;EAI7B,MAAM,sBACJ,OAAO,cAAc,eAAe,MAClCF,qDACG;EAEP,MAAMG,QAA0B,MAAM,OAAO,cAAc,SACzD,qBACI;GACJ;GACA;GACA,UAAU;IAAE,QAAQ;IAAS,MAAM;IAAI,SAAS;;GAChD,eAAe;;AAEjB,qBAAmB;GACjB,GAAG;GACH,GAAG,MAAM;GACT,cAAc;IACZ,eAAe;IACf,GAAG,OAAO;IACV,GAAG,MAAM,OAAO;;;EAGpB,MAAM,uBAAuB,MAAM;EACnC,MAAM,kEAA4B,MAAM;EACxC,MAAM,qBAAqB,EAAE,GAAG,MAAM;EACtC,MAAM,0BAA0B,MAAM,iBAAiB;EAEvD,MAAM,WAAWC,2BAAc,OAAO,cAAc;EAEpD,MAAM,QAAQ,mBAAmB,QAAQ,KAAK;EAC9C,MAAM,OAAO,QAAQ,OAAO,kBAAkB,sBAAsB;EACpE,MAAM,6BAA6B,EAAE,GAAG,WAAW;EAEnD,MAAM,QAAQ,OAAO,QACjB,IAAIC,mDAAkB,OAAO,SAC7B;AAEJ,MAAI,MAEF,OAAM,MAAM;AAEd,SAAO,IAAI,WAAW;GACpB,OAAO,OAAO;GACd;GACA,cAAc,OAAO;GACrB;GACA;GACA;GACA;GACA;GACA;GACA;GACA,SAAS,OAAO;GAChB;GACA;GACA;GACA;GACA;GACA,YAAY,OAAO,cAAc;GACjC,YAAY,OAAO,cAAc;GACjC,OAAO,OAAO;GACd;GACA;GACA,OAAO,OAAO;GACd,gBAAgB,OAAO;GACvB,iBAAiB,OAAO;GACxB,YAAY,OAAO;GACnB,OAAO,OAAO;GACd,gBAAgB,OAAO;;;CAI3B,AAAU,8BAA8B,OAKrC;AACD,OAAK,8BAA8B,KAAK,4BAA4B,WAC5D;AACJ,UAAO,KAAK,cAAc,IACxB,MAAM,QACN,MAAM,YACN,MAAM,UACN,MAAM;;AAIZ,OAAK,qBAAqB,KAAK,KAAK;;;;;;;CAQtC,UAAU,QAAgB,QAAgC;EACxD,IAAI,aAAa;AACjB,MAAI,WAAW,WAAW,EAAG;AAG7B,MAAI,WAAW,OAAO,CAAC,SAAS,OAAOC,iDACrC,cAAa,MAAM,KACjB,IAAI,IAAI,WAAW,KAAK,MAAM,CAAC,EAAE,IAAI,KAAK;AAK9C,OAAK,0BAA0B,KAAK,wBAAwB,QACzD,MAAM,EAAE,OAAO;AAIlB,OAAK,MAAM,CAAC,GAAG,MAAM,WACnB,MAAK,wBAAwB,KAAK;GAAC;GAAQ;GAAG;;EAGhD,MAAM,SAASR,gCAAkB,KAAK,kBAAkB;IACrDC,6CAA2B,KAAK,OAAO,cAAc,iBAAiB;IACtEQ,6CAA2B,KAAK,WAAW;;AAG9C,MAAI,KAAK,eAAe,UAAU,KAAK,gBAAgB,KACrD,MAAK,qBAAqB,KACxB,KAAK,aAAa,UAAU,QAAQ,YAAY;AAIpD,MAAI,KAAK,MACP,MAAK,cAAc,QAAQ;AAG7B,MAAI,CAAC,OAAO,UAAU,CAAC,KAAK,SAAS,CAAC,KAAK,MACzC;EAIF,MAAM,OAAO,KAAK,MAAM;AACxB,MAAI,QAAQ,QAAQ,KAAK,aAAa,KACpC;AAIF,MAAI,OAAO,GAAG,OAAOC,2BAAS,OAAO,GAAG,OAAOC,4BAC7C;AAGF,EAAK,KAAK,MAAM,IAAI,CAClB;GACE,KAAK,CAAC,KAAK,UAAU,IAAI,KAAK,UAAU;GACxC,OAAO,KAAK;GACZ,KAAK,KAAK,UAAU;;;CAK1B,cAAc,QAAgB,QAA6B,SAAS,OAAO;EACzE,MAAM,OAAO,KAAK,MAAM;AACxB,MAAI,SAAS,QAAW;AACtB,OACE,KAAK,WAAW,WACf,KAAK,OAAO,QAAQ,IAAI,SAASC,8BAElC;AAGF,OAAI,OAAO,SAAS,GAClB;QAAI,OAAO,GAAG,OAAOD,6BAAW;AAI9B,SAAI,KAAK,OAAO,OAAOE,0BAAQ,KAAK,MAAM,GAAG,QAAQ,KAAM;KAE3D,MAAM,kBAAkB,OACrB,QAAQ,MAAM,EAAE,OAAOF,6BACvB,SAAS,MAAM,EAAE;AAEpB,UAAK,MAAM,CACT,CAAC,WAAW,GAAGA,8BAAY,oBAC3B,CAAC,UAAU,GAAGA,8BAAY;eAEnB,OAAO,GAAG,OAAOD,wBAC1B,MAAK,MACHI,iCACEC,8BACEC,4BAAiB,KAAK,YAAY,CAAC,CAAC,MAAM,UAAU,SACpD;;AAMV,OAAI,CAAC,OACH,MAAK,MACHF,iCACEC,8BACEE,kCAAoB,CAAC,CAAC,MAAM,UAAU,KAAK,aAC3C;;;CAQZ,MAAM,qBAAqB;AACzB,MAAI,CAAC,KAAK,MAAO,QAAO;EAExB,MAAMC,UAGA;EAEN,MAAM,gBAAgB,CAAC,IAAI,SAAuB;AAChD,UAAO,MAAM,GAAG,KAAK,KAAK,OAAO;;EAGnC,MAAMC,OAAuB;EAC7B,MAAMC,SAA+D;AAErE,OAAK,MAAM,QAAQ,OAAO,OAAO,KAAK,OACpC,KAAI,KAAK,aAAa,QAAQ,CAAC,KAAK,OAAO,QAAQ;AACjD,QAAK,KAAK,CAAC,KAAK,UAAU,IAAI,KAAK,UAAU;AAC7C,UAAO,aAAa,CAAC,KAAK,UAAU,IAAI,KAAK,UAAU,SAAS;;AAIpE,MAAI,KAAK,WAAW,EAAG,QAAO;EAC9B,MAAM,QAAQ,MAAM,KAAK,MAAM,IAAI;AAEnC,OAAK,MAAM,EAAE,KAAK,WAAW,OAAO;GAClC,MAAM,OAAO,OAAO,aAAa;AACjC,OAAI,QAAQ,MAAM;AAEhB,SAAK,OAAO,KAAK,GAAG;AACpB,YAAQ,KAAK;KAAE;KAAM,QAAQ;;;;AAIjC,SAAO;;;;;;;CAQT,MAAM,KAAK,QAA6D;AACtE,MAAI,KAAK,SAAS,CAAC,KAAK,MAAM,UAC5B,OAAM,KAAK,OAAO;EAEpB,MAAM,EAAE,YAAY,OAAO;AAC3B,MAAI,KAAK,WAAW,UAClB,OAAM,IAAI,MACR,oEAAoE,KAAK,OAAO;AAGpF,MAAI,CAAC,CAAC,YAAY,gBAAgB,SAAS,KAAK,OAC9C,OAAM,KAAK,OAAO;WACT,KAAK,YAAY,SAAS,GAAG;AACtC,QAAK,SAAS;AACd,SAAM,IAAIC;aAEV,OAAO,OAAO,KAAK,OAAO,OAAO,SAAS,KAAK,OAAO,SAAS,IAC/D;GAEA,MAAM,SAAS,OAAO,OAAO,KAAK,OAAO,SAAS,MAAM,EAAE;AAE1D,QAAK,kBAAkBC,0BACrB,KAAK,YACL,KAAK,UACL,OAAO,OAAO,KAAK,QACnB,KAAK,4BACL,KAAK;GAGP,MAAM,eAAe,MAAMC,6BACzBR,8BACES,2BAAgB,KAAK,YAAY,QAAQ,KAAK,WAC9C;AAGJ,QAAK,MAAM;AAEX,QAAK,0BAA0B;AAC/B,SAAM,KAAK,eAAe,EAAE,QAAQ;AAEpC,OACEC,6BACE,KAAK,YACL,KAAK,gBACL,OAAO,OAAO,KAAK,SAErB;AACA,SAAK,SAAS;AACd,UAAM,IAAIJ;;AAIZ,OAAI,KAAK,OAAO,eAAe1B,2CAAyB,OACtD,QAAO,KAAK,OAAO,eAAeA;QAGpC,QAAO;AAET,MAAI,KAAK,OAAO,KAAK,MAAM;AACzB,QAAK,SAAS;AACd,UAAO;;EAGT,MAAM,YAAY+B,+BAChB,KAAK,YACL,KAAK,yBACL,KAAK,OACL,KAAK,UACL,KAAK,QACL,MACA;GACE,MAAM,KAAK;GACX,cAAc,KAAK;GACnB,YAAY,KAAK;GACjB,SAAS,KAAK;GACd,OAAO,KAAK;GACZ,QAAQ,KAAK;GACb,gBAAgB,KAAK;GACrB,iBAAiB,KAAK;;AAG1B,OAAK,QAAQ;AAGb,MAAI,KAAK,aACP,MAAK,MACH,MAAMH,6BACJR,8BACEY,iCACE,KAAK,kBACL,KAAK,UACL,KAAK,YACL,KAAK,oBACL,OAAO,OAAO,KAAK,QACnB,KAAK,yBACL,KAAK,sBACL,KAAK,aAEP;AAMR,MAAI,OAAO,OAAO,KAAK,OAAO,WAAW,GAAG;AAC1C,QAAK,SAAS;AACd,UAAO;;AAGT,MAAI,KAAK,iBAAiB,KAAK,wBAAwB,SAAS,GAAG;AACjE,QAAK,MAAM,CAAC,KAAK,GAAG,MAAM,KAAK,yBAAyB;AACtD,QAAI,MAAMjB,2BAAS,MAAMC,+BAAa,MAAMiB,yBAC1C;IAEF,MAAM,OAAO,OAAO,OAAO,KAAK,OAAO,MAAM,MAAM,EAAE,OAAO;AAC5D,QAAI,KACF,MAAK,OAAO,KAAK,CAAC,GAAG;;AAGzB,QAAK,MAAM,QAAQ,OAAO,OAAO,KAAK,OACpC,KAAI,KAAK,OAAO,SAAS,EACvB,MAAK,cAAc,KAAK,IAAI,KAAK,QAAQ;;AAK/C,MAAI,OAAO,OAAO,KAAK,OAAO,OAAO,SAAS,KAAK,OAAO,SAAS,GACjE,QAAO,KAAK,KAAK,EAAE;AAIrB,MACEH,6BACE,KAAK,YACL,KAAK,iBACL,OAAO,OAAO,KAAK,SAErB;AACA,QAAK,SAAS;AACd,SAAM,IAAIJ;;EAIZ,MAAM,cAAc,MAAME,6BACxBR,8BAAgBc,4BAAc,OAAO,OAAO,KAAK,SAAS;AAE5D,OAAK,MAAM;AAEX,SAAO;;CAGT,MAAM,qBAAqB,OAAe;AAExC,MACE,KAAK,eAAe,WAEnB,CAAC,KAAK,YAEL,OAAO,UAAU,eAEjB,KAAK,oBAAoB,OACtB,SAAS,CAAC,KAAK,SAASC,+CAE7B;AACA,QAAK,eAAe,KAAK;AACzB,QAAK;;EAGP,MAAM,WAAW,KAAK,mBAAmB;AACzC,MAAI,YAAY,UAAU,OACxB,MAAK,SAASC,wBAAa,KAAK,UAAU,KAAK;AAEjD,MAAI,UAAU;AAEZ,OACE,KAAK,UAAU,UACf,KAAK,wBAAwB,SAAS,KACtC,OAAO,OAAO,KAAK,OAAO,MAAM,SAAS,KAAK,OAAO,SAAS,IAC9D;AACA,SAAK,kBAAkBT,0BACrB,KAAK,YACL,KAAK,UACL,OAAO,OAAO,KAAK,QACnB,KAAK,4BACL,KAAK;AAGP,SAAK,MACHR,iCACEC,8BACES,2BACE,KAAK,YACL,OAAO,OAAO,KAAK,OAAO,SAAS,MAAM,EAAE,SAC3C,KAAK,WAEP;;AAOR,OAAIQ,gCAAiB,UAAU,CAAC,MAAM,WAAW,OAC/C,MAAK,MAAM,CACT,CAAC,WAAW,GAAGrB,8BAAY,OAC3B,CAAC,UAAU,GAAGA,8BAAY;;AAIhC,SAAO;;CAGT,MAAM,WACJ,MACA,UACA,MACsD;AACtD,MACE,KAAK,gBAAgB,SAAS,KAC9Bc,6BAAgB,KAAK,YAAY,KAAK,gBAAgB,CAAC,QACvD;AACA,QAAK,YAAY,KAAK;AACtB;;EAGF,MAAM,SAASQ,gCACb;GAACpB;GAAM,KAAK,QAAQ;GAAI;GAAU,KAAK;GAAI;KAC3C,KAAK,YACL,KAAK,yBACL,KAAK,OACL,KAAK,UACL,KAAK,UAAU,IACf,MACA;GACE,MAAM,KAAK;GACX,cAAc,KAAK;GACnB,SAAS,KAAK;GACd,OAAO,KAAK;GACZ,QAAQ,KAAK;;AAIjB,MAAI,CAAC,OAAQ;AACb,MACE,KAAK,iBAAiB,SAAS,KAC/BY,6BAAgB,KAAK,YAAY,KAAK,iBAAiB,CAAC,UACxD;AACA,QAAK,YAAY,KAAK;AACtB;;AAGF,OAAK,MACHX,iCAAmBC,8BAAgBc,4BAAc,CAAC,UAAU;AAG9D,MAAI,KAAK,MAAO,8BAAe,KAAK,MAAM,CAAC;AAC3C,OAAK,MAAM,OAAO,MAAM;AACxB,MAAI,KAAK,cAAe,MAAK,aAAa,GAAG,OAAO,KAAK;EAEzD,MAAM,QAAQ,MAAM,KAAK;AACzB,OAAK,MAAM,EAAE,kBAAU,MACrB,MAAK,cAAcK,OAAK,IAAIA,OAAK,QAAQ;AAG3C,SAAO;;CAGT,AAAU,mBAAmB,GAAoB;AAC/C,SAAOF,gCAAiB,MAAM,CAAC,KAAK;;CAGtC,MAAgB,OAAO,WAA8B;EAOnD,MAAM,EAAE,iBAAiB,KAAK;EAG9B,MAAM,aAAa,eACjBjC;AAGF,MAAI,cAAc,WAAW,eAAe,OAC1C,MAAK,UAAUoC,gCAAc,CAAC,CAACP,0BAAQ,WAAW;AAIpD,MAAIhC,4BAAU,KAAK,QAAQ;GACzB,MAAM,YAAY,KAAK,MAAM,UAAU;AAEvC,OACE,KAAK,MAAM,UAAU,QACrB,OAAO,KAAK,MAAM,WAAW,YAC7B,OAAO,KAAK,KAAK,MAAM,QAAQ,MAAMwC,sBACrC;AACA,SAAK,OAAO,iBAAiB;AAC7B,SAAK,OAAO,aAAaC,2CAAyB,KAAK,MAAM;;AAG/D,OAAI,aAAa,KAAK,gBAAgB,KACpC,OAAM,IAAI,MAAM;GAGlB,MAAMC,SAA4C;AAGlD,QAAK,MAAM,CAAC,KAAK,KAAK,UAAUC,sBAC9B,KAAK,OACL,KAAK,0BACJ;AACD,WAAO,SAAS;AAChB,WAAO,KAAK,KAAK,CAAC,KAAK;;AAEzB,OAAI,OAAO,KAAK,QAAQ,WAAW,EACjC,OAAM,IAAIC,+BAAgB;AAI5B,QAAK,MAAM,CAAC,KAAK,OAAO,OAAO,QAAQ,QACrC,MAAK,UAAU,KAAK;;EAKxB,MAAM,cAAc,KAAK,2BAA2B,IACjD,QAAQ,MAAM,EAAE,OAAOL,gCACvB,KAAK,MAAM,EAAE,MAAM;AACtB,MAAI,WAAW,SAAS,EACtB,2BACE,KAAK,YACL,KAAK,UACL,CACE;GACE,MAAMM;GACN,QAAQ;GACR,UAAU;MAGd,KAAK,4BACL,KAAK;EAGT,MAAM,wBACJ7C,4BAAU,KAAK,UAAU,WAAW,SAAS;AAC/C,MAAI,KAAK,cAAc,uBAAuB;AAC5C,QAAK,MAAM,eAAe,KAAK,UAAU;AACvC,QAAI,CAAC,OAAO,UAAU,eAAe,KAAK,KAAK,UAAU,aACvD;AACF,QAAI,KAAK,WAAW,iBAAiB,iBAAiB,QAAW;KAC/D,MAAM,UAAU,KAAK,WAAW,iBAAiB;AACjD,UAAK,WAAW,cAAce,+BAAa;MACzC,GAAG,KAAK,WAAW,cAAcA;OAChC,cAAc;;;;GAKrB,MAAM,eAAe,MAAMY,6BACzBR,8BACES,2BAAgB,KAAK,YAAY,MAAM,KAAK,WAC5C;AAGJ,QAAK,MAAM;;AAEb,MAAI,KAAK,WACP,MAAK,QAAQ;WACJ,uBAAuB;AAIhC,SAAM,KAAK,eAAe,EAAE,QAAQ;AACpC,QAAK,QAAQ;SACR;GAEL,MAAM,cAAc,MAAMD,6BAAemB,oBAAS,WAAW,KAAK;AAClE,OAAI,YAAY,SAAS,GAAG;IAC1B,MAAM,eAAehB,+BACnB,KAAK,YACL,KAAK,yBACL,KAAK,OACL,KAAK,UACL,KAAK,QACL,MACA,EAAE,MAAM,KAAK;AAEf,SAAK,kBAAkBJ,0BACrB,KAAK,YACL,KAAK,UACJ,OAAO,OAAO,cAAmC,OAAO,CACvD;KACE,MAAMmB;KACN,QAAQ;KACR,UAAU;SAGd,KAAK,4BACL,KAAK;AAGP,UAAM,KAAK,eAAe,EAAE,QAAQ;AAEpC,SAAK,QAAQ;cACJ,EAAE9C,0CAAwB,KAAK,OAAO,gBAAgB,KAC/D,OAAM,IAAI6C,+BACR,gCAAgC,KAAK,UAAU,WAAW,MAAM;OAIlE,MAAK,QAAQ;;AAGjB,MAAI,CAAC,KAAK,SACR,MAAK,SAASxC,gCAAkB,KAAK,QAAQ,GAC1CL,wCAAsB,KAAK;;CAKlC,AAAU,MAAM,QAAiC;AAC/C,OAAK,MAAM,CAAC,MAAM,YAAY,QAAQ;AACpC,OAAI,KAAK,OAAO,MAAM,IAAI,MACxB,MAAK,OAAO,KAAK;IAAC,KAAK;IAAqB;IAAM;;AAKpD,QACG,SAAS,iBAAiB,SAAS,YACpC,KAAK,OAAO,MAAM,IAAI,UACtB;IACA,MAAM,OAAO,SAAS,gBAAgB,KAAK,OAAO,IAAI,KAAK;IAC3D,MAAM,6BAAY,IAAI,QAAO;IAC7B,MAAM,cAAc;AAClB,SAAI,SAAS,cACX,QAAO;cAEP,OAAO,YAAY,YACnB,WAAW,QACX,YAAY,QAEZ,QAAO;SAEP,QAAO;;AAIX,SAAK,OAAO,KAAK;KACf,KAAK;KACL;KACA;MAAE;MAAM;MAAM;MAAW;;;;;;CAMjC,AAAU,eACR,eACA;EACA,MAAM,UAAU,KAAK,uBAAuB;EAE5C,MAAM,eACJ,KAAK,gBAAgB,SAAS,KAAK,eAAe,UAAU;EAE9D,MAAM,mBAAmB,eAA2B;AAElD,QAAK,uBAAuB,KAAK,kBAAkB,cAC/C,gBACA,KAAK,mBACL;AAMJ,QAAK,mBAAmBK,gCAAkB,KAAK,kBAAkB,GAC9DC,6CACC,KAAK,OAAO,cAAc,iBAAiB;GAG/C,MAAM,kBAAkB,EAAE,GAAG,KAAK,WAAW;GAC7C,MAAM,cAAc0C,oCAClB,KAAK,4BACL;AAEF,QAAK,6BAA6B;AAIlC,GAAK,KAAK,8BAA8B;IACtC,QAAQ,EAAE,GAAG,KAAK;IAClB,iEAA2B;IAC3B,UAAU,EAAE,GAAG,KAAK;IACpB;;AAEF,QAAK,mBAAmB;IACtB,GAAG,KAAK;IACR,cAAc;KACZ,GAAG,KAAK,iBAAiB;KACzB,eAAe,KAAK,WAAW;;;;AAKrC,MAAI,CAAC,QACH,MAAK,qBAAqB;GACxB,GAAG;GACH,MAAM,KAAK;GACX,SAAS,KAAK,OAAO,eAAevC,gDAA8B;;AAKtE,OAAK,aAAawC,8BAChB,KAAK,YACL,eAAe,KAAK,WAAW,QAC/B,KAAK,MACL,UAAU,EAAE,IAAI,KAAK,WAAW,OAAO;AAIzC,MAAI,aAAc,iBAAgB,KAAK;AAEvC,MAAI,CAAC,QAEH,MAAK,QAAQ;;CAIjB,AAAU,sBAAsB;AAC9B,MAAI,KAAK,gBAAgB,KAAM;AAC/B,MAAI,KAAK,wBAAwB,WAAW,EAAG;EAG/C,MAAM,SAAS5C,gCAAkB,KAAK,kBAAkB;IACrDC,6CAA2B,KAAK,OAAO,cAAc,iBAAiB;IACtEQ,6CAA2B,KAAK,WAAW;;EAI9C,MAAMoC,SAAiD;AACvD,OAAK,MAAM,CAAC,KAAK,KAAK,UAAU,KAAK,yBAAyB;AAC5D,UAAO,SAAS;AAChB,UAAO,KAAK,KAAK,CAAC,KAAK;;AAIzB,OAAK,MAAM,CAAC,KAAK,OAAO,OAAO,QAAQ,QACrC,MAAK,qBAAqB,KACxB,KAAK,aAAa,UAAU,QAAQ,IAAI;;CAK9C,AAAU,aACR,OACA;AACA,OAAK,MAAM,CAAC,KAAK,GAAG,MAAM,KAAK,yBAAyB;AACtD,OAAI,MAAMnC,2BAAS,MAAMC,+BAAa,MAAMiB,yBAC1C;GAEF,MAAM,OAAO,OAAO,OAAO,OAAO,MAAM,MAAM,EAAE,OAAO;AACvD,OAAI,KACF,MAAK,OAAO,KAAK,CAAC,GAAG;;AAGzB,OAAK,MAAM,QAAQ,OAAO,OAAO,OAC/B,KAAI,KAAK,OAAO,SAAS,EACvB,MAAK,cAAc,KAAK,IAAI,KAAK,QAAQ"}