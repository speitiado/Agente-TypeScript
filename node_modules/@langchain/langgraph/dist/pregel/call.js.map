{"version":3,"file":"call.js","names":[],"sources":["../../src/pregel/call.ts"],"sourcesContent":["import {\n  Runnable,\n  RunnableConfig,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { CONFIG_KEY_CALL, RETURN, TAG_HIDDEN } from \"../constants.js\";\nimport { ChannelWrite, PASSTHROUGH } from \"./write.js\";\nimport { CachePolicy, RetryPolicy } from \"./utils/index.js\";\nimport { RunnableCallable, type RunnableCallableArgs } from \"../utils.js\";\nimport { EntrypointFunc, EntrypointReturnT, TaskFunc } from \"../func/types.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\n/**\n * Wraps a user function in a Runnable that writes the returned value to the RETURN channel.\n */\nexport function getRunnableForFunc<ArgsT extends unknown[], OutputT>(\n  name: string,\n  func: TaskFunc<ArgsT, OutputT>\n): Runnable<ArgsT, OutputT, LangGraphRunnableConfig> {\n  const run = new RunnableCallable<ArgsT, OutputT>({\n    func: (input: ArgsT) => func(...input),\n    name,\n    trace: false,\n    recurse: false,\n  } as RunnableCallableArgs);\n\n  return new RunnableSequence<ArgsT, OutputT>({\n    name,\n    first: run,\n    last: new ChannelWrite<OutputT>(\n      [{ channel: RETURN, value: PASSTHROUGH }],\n      [TAG_HIDDEN]\n    ),\n  });\n}\n\nexport function getRunnableForEntrypoint<InputT, OutputT>(\n  name: string,\n  func: EntrypointFunc<InputT, OutputT>\n): Runnable<InputT, EntrypointReturnT<OutputT>, LangGraphRunnableConfig> {\n  const run = new RunnableCallable<InputT, EntrypointReturnT<OutputT>>({\n    func: (input: InputT, config: LangGraphRunnableConfig) => {\n      return func(input, config);\n    },\n    name,\n    trace: false,\n    recurse: false,\n  });\n\n  return run;\n}\n\nexport type CallWrapperOptions<ArgsT extends unknown[], OutputT> = {\n  func: TaskFunc<ArgsT, OutputT>;\n  name: string;\n  retry?: RetryPolicy;\n  cache?: CachePolicy;\n};\n\nexport function call<ArgsT extends unknown[], OutputT>(\n  { func, name, cache, retry }: CallWrapperOptions<ArgsT, OutputT>,\n  ...args: ArgsT\n): Promise<OutputT> {\n  const config =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig() as RunnableConfig;\n  if (typeof config.configurable?.[CONFIG_KEY_CALL] === \"function\") {\n    return config.configurable[CONFIG_KEY_CALL](func, name, args, {\n      retry,\n      cache,\n      callbacks: config.callbacks,\n    });\n  }\n  throw new Error(\n    \"Async local storage not initialized. Please call initializeAsyncLocalStorageSingleton() before using this function.\"\n  );\n}\n"],"mappings":";;;;;;;;;;AAgBA,SAAgB,mBACd,MACA,MACmD;CACnD,MAAM,MAAM,IAAI,iBAAiC;EAC/C,OAAO,UAAiB,KAAK,GAAG;EAChC;EACA,OAAO;EACP,SAAS;;AAGX,QAAO,IAAI,iBAAiC;EAC1C;EACA,OAAO;EACP,MAAM,IAAI,aACR,CAAC;GAAE,SAAS;GAAQ,OAAO;MAC3B,CAAC;;;AAKP,SAAgB,yBACd,MACA,MACuE;CACvE,MAAM,MAAM,IAAI,iBAAqD;EACnE,OAAO,OAAe,WAAoC;AACxD,UAAO,KAAK,OAAO;;EAErB;EACA,OAAO;EACP,SAAS;;AAGX,QAAO;;AAUT,SAAgB,KACd,EAAE,MAAM,MAAM,OAAO,SACrB,GAAG,MACe;CAClB,MAAM,SACJ,mCAAmC;AACrC,KAAI,OAAO,OAAO,eAAe,qBAAqB,WACpD,QAAO,OAAO,aAAa,iBAAiB,MAAM,MAAM,MAAM;EAC5D;EACA;EACA,WAAW,OAAO;;AAGtB,OAAM,IAAI,MACR"}