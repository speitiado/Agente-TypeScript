{"version":3,"file":"standard.js","names":["block: ContentBlock.Standard","format","message: BaseMessage","model?: string","blocks: ContentBlock.Standard[]","currentMessage: OpenAIClient.Responses.EasyInputMessage | undefined","pushMessageContent: (\n      content: OpenAIClient.Responses.ResponseInputMessageContentList\n    ) => void","value: unknown","block: ContentBlock.Multimodal.Image","block: ContentBlock.Multimodal.File | ContentBlock.Multimodal.Video","block: ContentBlock.Reasoning","reasoningItem: OpenAIClient.Responses.ResponseReasoningItem","block: ContentBlock.Tools.ToolCall | ContentBlock.Tools.ServerToolCall","block: ContentBlock.Tools.ServerToolCallResult"],"sources":["../../src/utils/standard.ts"],"sourcesContent":["import type { OpenAI as OpenAIClient } from \"openai\";\nimport {\n  isAIMessage,\n  BaseMessage,\n  ToolMessage,\n  type ContentBlock,\n} from \"@langchain/core/messages\";\nimport { iife, isReasoningModel, messageToOpenAIRole } from \"./misc.js\";\n\nexport type ResponsesInputItem = OpenAIClient.Responses.ResponseInputItem;\n\ntype ChatCompletionContentData =\n  | OpenAIClient.Chat.Completions.ChatCompletionContentPartImage\n  | OpenAIClient.Chat.Completions.ChatCompletionContentPartInputAudio\n  | OpenAIClient.Chat.Completions.ChatCompletionContentPart.File;\n\nfunction _convertToChatCompletionsData(\n  block: ContentBlock.Standard\n): ChatCompletionContentData | undefined {\n  if (block.type === \"image\") {\n    if (block.url) {\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: block.url,\n        },\n      };\n    } else if (block.data) {\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: `data:${block.mimeType};base64,${block.data}`,\n        },\n      };\n    }\n  }\n  if (block.type === \"audio\") {\n    if (block.data) {\n      const format = iife(() => {\n        const [, format] = block.mimeType.split(\"/\");\n        if (format === \"wav\" || format === \"mp3\") {\n          return format;\n        }\n        return \"wav\";\n      });\n      return {\n        type: \"input_audio\",\n        input_audio: {\n          data: block.data.toString(),\n          format,\n        },\n      };\n    }\n  }\n  if (block.type === \"file\") {\n    if (block.data) {\n      return {\n        type: \"file\",\n        file: {\n          file_data: block.data.toString(),\n        },\n      };\n    }\n    if (block.fileId) {\n      return {\n        type: \"file\",\n        file: {\n          file_id: block.fileId,\n        },\n      };\n    }\n  }\n  return undefined;\n}\n\nexport function _convertToCompletionsMessageFromV1(\n  message: BaseMessage,\n  model?: string\n): OpenAIClient.Chat.Completions.ChatCompletionMessageParam {\n  let role = messageToOpenAIRole(message);\n  if (role === \"system\" && isReasoningModel(model)) {\n    role = \"developer\";\n  }\n  if (role === \"developer\") {\n    return {\n      role: \"developer\",\n      content: message.contentBlocks.filter((block) => block.type === \"text\"),\n    };\n  } else if (role === \"system\") {\n    return {\n      role: \"system\",\n      content: message.contentBlocks.filter((block) => block.type === \"text\"),\n    };\n  } else if (role === \"assistant\") {\n    return {\n      role: \"assistant\",\n      content: message.contentBlocks.filter((block) => block.type === \"text\"),\n    };\n  } else if (role === \"tool\" && ToolMessage.isInstance(message)) {\n    return {\n      role: \"tool\",\n      tool_call_id: message.tool_call_id,\n      content: message.contentBlocks.filter((block) => block.type === \"text\"),\n    };\n  } else if (role === \"function\") {\n    return {\n      role: \"function\",\n      name: message.name ?? \"\",\n      content: message.contentBlocks\n        .filter((block) => block.type === \"text\")\n        .join(\"\"),\n    };\n  }\n  // Default to user message handling\n  function* iterateUserContent(blocks: ContentBlock.Standard[]) {\n    for (const block of blocks) {\n      if (block.type === \"text\") {\n        yield {\n          type: \"text\" as const,\n          text: block.text,\n        };\n      }\n      const data = _convertToChatCompletionsData(block);\n      if (data) {\n        yield data;\n      }\n    }\n  }\n  return {\n    role: \"user\",\n    content: Array.from(iterateUserContent(message.contentBlocks)),\n  };\n}\n\nexport function _convertToResponsesMessageFromV1(message: BaseMessage) {\n  const isResponsesMessage =\n    isAIMessage(message) &&\n    message.response_metadata?.model_provider === \"openai\";\n\n  function* iterateItems(): Generator<OpenAIClient.Responses.ResponseInputItem> {\n    const messageRole = iife(() => {\n      try {\n        const role = messageToOpenAIRole(message);\n        if (\n          role === \"system\" ||\n          role === \"developer\" ||\n          role === \"assistant\" ||\n          role === \"user\"\n        ) {\n          return role;\n        }\n        return \"assistant\";\n      } catch {\n        return \"assistant\";\n      }\n    });\n\n    let currentMessage: OpenAIClient.Responses.EasyInputMessage | undefined =\n      undefined;\n\n    const functionCallIdsWithBlocks = new Set<string>();\n    const serverFunctionCallIdsWithBlocks = new Set<string>();\n\n    const pendingFunctionChunks = new Map<\n      string,\n      { name?: string; args: string[] }\n    >();\n    const pendingServerFunctionChunks = new Map<\n      string,\n      { name?: string; args: string[] }\n    >();\n\n    function* flushMessage() {\n      if (!currentMessage) return;\n      const content = currentMessage.content;\n      if (\n        (typeof content === \"string\" && content.length > 0) ||\n        (Array.isArray(content) && content.length > 0)\n      ) {\n        yield currentMessage;\n      }\n      currentMessage = undefined;\n    }\n\n    const pushMessageContent: (\n      content: OpenAIClient.Responses.ResponseInputMessageContentList\n    ) => void = (content) => {\n      if (!currentMessage) {\n        currentMessage = {\n          type: \"message\",\n          role: messageRole,\n          content: [],\n        };\n      }\n      if (typeof currentMessage.content === \"string\") {\n        currentMessage.content =\n          currentMessage.content.length > 0\n            ? [{ type: \"input_text\", text: currentMessage.content }, ...content]\n            : [...content];\n      } else {\n        currentMessage.content.push(...content);\n      }\n    };\n\n    const toJsonString = (value: unknown) => {\n      if (typeof value === \"string\") {\n        return value;\n      }\n      try {\n        return JSON.stringify(value ?? {});\n      } catch {\n        return \"{}\";\n      }\n    };\n\n    const resolveImageItem = (\n      block: ContentBlock.Multimodal.Image\n    ): OpenAIClient.Responses.ResponseInputImage | undefined => {\n      const detail = iife(() => {\n        const raw = block.metadata?.detail;\n        if (raw === \"low\" || raw === \"high\" || raw === \"auto\") {\n          return raw;\n        }\n        return \"auto\";\n      });\n      if (block.fileId) {\n        return {\n          type: \"input_image\",\n          detail,\n          file_id: block.fileId,\n        };\n      }\n      if (block.url) {\n        return {\n          type: \"input_image\",\n          detail,\n          image_url: block.url,\n        };\n      }\n      if (block.data) {\n        const base64Data =\n          typeof block.data === \"string\"\n            ? block.data\n            : Buffer.from(block.data).toString(\"base64\");\n        const mimeType = block.mimeType ?? \"image/png\";\n        return {\n          type: \"input_image\",\n          detail,\n          image_url: `data:${mimeType};base64,${base64Data}`,\n        };\n      }\n      return undefined;\n    };\n\n    const resolveFileItem = (\n      block: ContentBlock.Multimodal.File | ContentBlock.Multimodal.Video\n    ): OpenAIClient.Responses.ResponseInputFile | undefined => {\n      const filename =\n        block.metadata?.filename ??\n        block.metadata?.name ??\n        block.metadata?.title;\n      if (block.fileId && typeof filename === \"string\") {\n        return {\n          type: \"input_file\",\n          file_id: block.fileId,\n          ...(filename ? { filename } : {}),\n        };\n      }\n      if (block.url && typeof filename === \"string\") {\n        return {\n          type: \"input_file\",\n          file_url: block.url,\n          ...(filename ? { filename } : {}),\n        };\n      }\n      if (block.data && typeof filename === \"string\") {\n        const encoded =\n          typeof block.data === \"string\"\n            ? block.data\n            : Buffer.from(block.data).toString(\"base64\");\n        const mimeType = block.mimeType ?? \"application/octet-stream\";\n        return {\n          type: \"input_file\",\n          file_data: `data:${mimeType};base64,${encoded}`,\n          ...(filename ? { filename } : {}),\n        };\n      }\n      return undefined;\n    };\n\n    const convertReasoningBlock = (\n      block: ContentBlock.Reasoning\n    ): OpenAIClient.Responses.ResponseReasoningItem => {\n      const summaryEntries = iife(() => {\n        if (Array.isArray(block.summary)) {\n          const candidate = block.summary;\n          const mapped =\n            candidate\n              ?.map((item) => item?.text)\n              .filter((text): text is string => typeof text === \"string\") ?? [];\n          if (mapped.length > 0) {\n            return mapped;\n          }\n        }\n        return block.reasoning ? [block.reasoning] : [];\n      });\n\n      const summary =\n        summaryEntries.length > 0\n          ? summaryEntries.map((text) => ({\n              type: \"summary_text\" as const,\n              text,\n            }))\n          : [{ type: \"summary_text\" as const, text: \"\" }];\n\n      const reasoningItem: OpenAIClient.Responses.ResponseReasoningItem = {\n        type: \"reasoning\",\n        id: block.id ?? \"\",\n        summary,\n      };\n\n      if (block.reasoning) {\n        reasoningItem.content = [\n          {\n            type: \"reasoning_text\" as const,\n            text: block.reasoning,\n          },\n        ];\n      }\n      return reasoningItem;\n    };\n\n    const convertFunctionCall = (\n      block: ContentBlock.Tools.ToolCall | ContentBlock.Tools.ServerToolCall\n    ): OpenAIClient.Responses.ResponseFunctionToolCall => ({\n      type: \"function_call\",\n      name: block.name ?? \"\",\n      call_id: block.id ?? \"\",\n      arguments: toJsonString(block.args),\n    });\n\n    const convertFunctionCallOutput = (\n      block: ContentBlock.Tools.ServerToolCallResult\n    ): OpenAIClient.Responses.ResponseInputItem.FunctionCallOutput => {\n      const output = toJsonString(block.output);\n      const status =\n        block.status === \"success\"\n          ? \"completed\"\n          : block.status === \"error\"\n          ? \"incomplete\"\n          : undefined;\n      return {\n        type: \"function_call_output\",\n        call_id: block.toolCallId ?? \"\",\n        output,\n        ...(status ? { status } : {}),\n      };\n    };\n\n    for (const block of message.contentBlocks) {\n      if (block.type === \"text\") {\n        pushMessageContent([{ type: \"input_text\", text: block.text }]);\n      } else if (block.type === \"invalid_tool_call\") {\n        // no-op\n      } else if (block.type === \"reasoning\") {\n        yield* flushMessage();\n        yield convertReasoningBlock(\n          block as ContentBlock.Standard & { type: \"reasoning\" }\n        );\n      } else if (block.type === \"tool_call\") {\n        yield* flushMessage();\n        const id = block.id ?? \"\";\n        if (id) {\n          functionCallIdsWithBlocks.add(id);\n          pendingFunctionChunks.delete(id);\n        }\n        yield convertFunctionCall(\n          block as ContentBlock.Standard & { type: \"tool_call\" }\n        );\n      } else if (block.type === \"tool_call_chunk\") {\n        if (block.id) {\n          const existing = pendingFunctionChunks.get(block.id) ?? {\n            name: block.name,\n            args: [],\n          };\n          if (block.name) existing.name = block.name;\n          if (block.args) existing.args.push(block.args);\n          pendingFunctionChunks.set(block.id, existing);\n        }\n      } else if (block.type === \"server_tool_call\") {\n        yield* flushMessage();\n        const id = block.id ?? \"\";\n        if (id) {\n          serverFunctionCallIdsWithBlocks.add(id);\n          pendingServerFunctionChunks.delete(id);\n        }\n        yield convertFunctionCall(block);\n      } else if (block.type === \"server_tool_call_chunk\") {\n        if (block.id) {\n          const existing = pendingServerFunctionChunks.get(block.id) ?? {\n            name: block.name,\n            args: [],\n          };\n          if (block.name) existing.name = block.name;\n          if (block.args) existing.args.push(block.args);\n          pendingServerFunctionChunks.set(block.id, existing);\n        }\n      } else if (block.type === \"server_tool_call_result\") {\n        yield* flushMessage();\n        yield convertFunctionCallOutput(block);\n      } else if (block.type === \"audio\") {\n        // no-op\n      } else if (block.type === \"file\") {\n        const fileItem = resolveFileItem(block);\n        if (fileItem) {\n          pushMessageContent([fileItem]);\n        }\n      } else if (block.type === \"image\") {\n        const imageItem = resolveImageItem(block);\n        if (imageItem) {\n          pushMessageContent([imageItem]);\n        }\n      } else if (block.type === \"video\") {\n        const videoItem = resolveFileItem(block);\n        if (videoItem) {\n          pushMessageContent([videoItem]);\n        }\n      } else if (block.type === \"text-plain\") {\n        if (block.text) {\n          pushMessageContent([\n            {\n              type: \"input_text\",\n              text: block.text,\n            },\n          ]);\n        }\n      } else if (block.type === \"non_standard\" && isResponsesMessage) {\n        yield* flushMessage();\n        yield block.value as ResponsesInputItem;\n      }\n    }\n    yield* flushMessage();\n\n    for (const [id, chunk] of pendingFunctionChunks) {\n      if (!id || functionCallIdsWithBlocks.has(id)) continue;\n      const args = chunk.args.join(\"\");\n      if (!chunk.name && !args) continue;\n      yield {\n        type: \"function_call\",\n        call_id: id,\n        name: chunk.name ?? \"\",\n        arguments: args,\n      };\n    }\n\n    for (const [id, chunk] of pendingServerFunctionChunks) {\n      if (!id || serverFunctionCallIdsWithBlocks.has(id)) continue;\n      const args = chunk.args.join(\"\");\n      if (!chunk.name && !args) continue;\n      yield {\n        type: \"function_call\",\n        call_id: id,\n        name: chunk.name ?? \"\",\n        arguments: args,\n      };\n    }\n  }\n  return Array.from(iterateItems());\n}\n"],"mappings":"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"}