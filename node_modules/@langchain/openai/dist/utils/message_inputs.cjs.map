{"version":3,"file":"message_inputs.cjs","names":["completionsApiContentBlockConverter: StandardContentBlockConverter<{\n  text: ChatCompletionContentPartText;\n  image: ChatCompletionContentPartImage;\n  audio: ChatCompletionContentPartInputAudio;\n  file: ChatCompletionContentPart.File;\n}>","mimeType: { type: string; subtype: string }","messages: BaseMessage[]","model?: string","_convertToCompletionsMessageFromV1","messageToOpenAIRole","isReasoningModel","completionParam: Record<string, any>","convertLangChainToolCallToOpenAI"],"sources":["../../src/utils/message_inputs.ts"],"sourcesContent":["import {\n  BaseMessage,\n  convertToProviderContentBlock,\n  isAIMessage,\n  isDataContentBlock,\n  parseBase64DataUrl,\n  parseMimeType,\n  StandardContentBlockConverter,\n  ToolMessage,\n} from \"@langchain/core/messages\";\nimport { convertLangChainToolCallToOpenAI } from \"@langchain/core/output_parsers/openai_tools\";\nimport type { OpenAI as OpenAIClient } from \"openai\";\nimport type {\n  ChatCompletionContentPartText,\n  ChatCompletionContentPartImage,\n  ChatCompletionContentPartInputAudio,\n  ChatCompletionContentPart,\n} from \"openai/resources/chat/completions\";\nimport { _convertToCompletionsMessageFromV1 } from \"./standard.js\";\nimport { isReasoningModel, messageToOpenAIRole } from \"./misc.js\";\n\nexport const completionsApiContentBlockConverter: StandardContentBlockConverter<{\n  text: ChatCompletionContentPartText;\n  image: ChatCompletionContentPartImage;\n  audio: ChatCompletionContentPartInputAudio;\n  file: ChatCompletionContentPart.File;\n}> = {\n  providerName: \"ChatOpenAI\",\n\n  fromStandardTextBlock(block): ChatCompletionContentPartText {\n    return { type: \"text\", text: block.text };\n  },\n\n  fromStandardImageBlock(block): ChatCompletionContentPartImage {\n    if (block.source_type === \"url\") {\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: block.url,\n          ...(block.metadata?.detail\n            ? { detail: block.metadata.detail as \"auto\" | \"low\" | \"high\" }\n            : {}),\n        },\n      };\n    }\n\n    if (block.source_type === \"base64\") {\n      const url = `data:${block.mime_type ?? \"\"};base64,${block.data}`;\n      return {\n        type: \"image_url\",\n        image_url: {\n          url,\n          ...(block.metadata?.detail\n            ? { detail: block.metadata.detail as \"auto\" | \"low\" | \"high\" }\n            : {}),\n        },\n      };\n    }\n\n    throw new Error(\n      `Image content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`\n    );\n  },\n\n  fromStandardAudioBlock(block): ChatCompletionContentPartInputAudio {\n    if (block.source_type === \"url\") {\n      const data = parseBase64DataUrl({ dataUrl: block.url });\n      if (!data) {\n        throw new Error(\n          `URL audio blocks with source_type ${block.source_type} must be formatted as a data URL for ChatOpenAI`\n        );\n      }\n\n      const rawMimeType = data.mime_type || block.mime_type || \"\";\n      let mimeType: { type: string; subtype: string };\n\n      try {\n        mimeType = parseMimeType(rawMimeType);\n      } catch {\n        throw new Error(\n          `Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`\n        );\n      }\n\n      if (\n        mimeType.type !== \"audio\" ||\n        (mimeType.subtype !== \"wav\" && mimeType.subtype !== \"mp3\")\n      ) {\n        throw new Error(\n          `Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`\n        );\n      }\n\n      return {\n        type: \"input_audio\",\n        input_audio: {\n          format: mimeType.subtype,\n          data: data.data,\n        },\n      };\n    }\n\n    if (block.source_type === \"base64\") {\n      let mimeType: { type: string; subtype: string };\n\n      try {\n        mimeType = parseMimeType(block.mime_type ?? \"\");\n      } catch {\n        throw new Error(\n          `Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`\n        );\n      }\n\n      if (\n        mimeType.type !== \"audio\" ||\n        (mimeType.subtype !== \"wav\" && mimeType.subtype !== \"mp3\")\n      ) {\n        throw new Error(\n          `Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`\n        );\n      }\n\n      return {\n        type: \"input_audio\",\n        input_audio: {\n          format: mimeType.subtype,\n          data: block.data,\n        },\n      };\n    }\n\n    throw new Error(\n      `Audio content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`\n    );\n  },\n\n  fromStandardFileBlock(block): ChatCompletionContentPart.File {\n    if (block.source_type === \"url\") {\n      const data = parseBase64DataUrl({ dataUrl: block.url });\n      if (!data) {\n        throw new Error(\n          `URL file blocks with source_type ${block.source_type} must be formatted as a data URL for ChatOpenAI`\n        );\n      }\n\n      return {\n        type: \"file\",\n        file: {\n          file_data: block.url, // formatted as base64 data URL\n          ...(block.metadata?.filename || block.metadata?.name\n            ? {\n                filename: (block.metadata?.filename ||\n                  block.metadata?.name) as string,\n              }\n            : {}),\n        },\n      };\n    }\n\n    if (block.source_type === \"base64\") {\n      return {\n        type: \"file\",\n        file: {\n          file_data: `data:${block.mime_type ?? \"\"};base64,${block.data}`,\n          ...(block.metadata?.filename ||\n          block.metadata?.name ||\n          block.metadata?.title\n            ? {\n                filename: (block.metadata?.filename ||\n                  block.metadata?.name ||\n                  block.metadata?.title) as string,\n              }\n            : {}),\n        },\n      };\n    }\n\n    if (block.source_type === \"id\") {\n      return {\n        type: \"file\",\n        file: {\n          file_id: block.id,\n        },\n      };\n    }\n\n    throw new Error(\n      `File content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`\n    );\n  },\n};\n\nexport function _convertMessagesToOpenAIParams(\n  messages: BaseMessage[],\n  model?: string\n): OpenAIClient.Chat.Completions.ChatCompletionMessageParam[] {\n  return messages.flatMap((message) => {\n    if (\n      \"output_version\" in message.response_metadata &&\n      message.response_metadata?.output_version === \"v1\"\n    ) {\n      return _convertToCompletionsMessageFromV1(message);\n    }\n    let role = messageToOpenAIRole(message);\n    if (role === \"system\" && isReasoningModel(model)) {\n      role = \"developer\";\n    }\n\n    const content =\n      typeof message.content === \"string\"\n        ? message.content\n        : message.content.map((m) => {\n            if (isDataContentBlock(m)) {\n              return convertToProviderContentBlock(\n                m,\n                completionsApiContentBlockConverter\n              );\n            }\n            return m;\n          });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const completionParam: Record<string, any> = {\n      role,\n      content,\n    };\n    if (message.name != null) {\n      completionParam.name = message.name;\n    }\n    if (message.additional_kwargs.function_call != null) {\n      completionParam.function_call = message.additional_kwargs.function_call;\n      completionParam.content = \"\";\n    }\n    if (isAIMessage(message) && !!message.tool_calls?.length) {\n      completionParam.tool_calls = message.tool_calls.map(\n        convertLangChainToolCallToOpenAI\n      );\n      completionParam.content = \"\";\n    } else {\n      if (message.additional_kwargs.tool_calls != null) {\n        completionParam.tool_calls = message.additional_kwargs.tool_calls;\n      }\n      if ((message as ToolMessage).tool_call_id != null) {\n        completionParam.tool_call_id = (message as ToolMessage).tool_call_id;\n      }\n    }\n\n    if (\n      message.additional_kwargs.audio &&\n      typeof message.additional_kwargs.audio === \"object\" &&\n      \"id\" in message.additional_kwargs.audio\n    ) {\n      const audioMessage = {\n        role: \"assistant\",\n        audio: {\n          id: message.additional_kwargs.audio.id,\n        },\n      };\n      return [\n        completionParam,\n        audioMessage,\n      ] as OpenAIClient.Chat.Completions.ChatCompletionMessageParam[];\n    }\n\n    return completionParam as OpenAIClient.Chat.Completions.ChatCompletionMessageParam;\n  });\n}\n"],"mappings":"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"}